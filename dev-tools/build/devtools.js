/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 12);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function() {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		var result = [];
		for(var i = 0; i < this.length; i++) {
			var item = this[i];
			if(item[2]) {
				result.push("@media " + item[2] + "{" + item[1] + "}");
			} else {
				result.push(item[1]);
			}
		}
		return result.join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate
    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(55)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_events__);


class Bridge extends __WEBPACK_IMPORTED_MODULE_0_events__["EventEmitter"] {
  constructor (wall) {
    super()
    // Setting `this` to `self` here to fix an error in the Safari build:
    // ReferenceError: Cannot access uninitialized variable.
    // The error might be related to the webkit bug here:
    // https://bugs.webkit.org/show_bug.cgi?id=171543
    const self = this;
    self.setMaxListeners(Infinity);
    self.wall = wall;
    wall.listen(message => {
        if (typeof message === 'string') {
            self.emit(message)
        } else {
            self.emit(message.event, message.payload)
        }
    });
  };

  /**
   * Send an event.
   *
   * @param {String} event
   * @param {*} payload
   */

  send (event, payload) {
      this.wall.send({
          event,
          payload
      });
  };

  /**
   * Log a message to the devtools background page.
   *
   * @param {String} message
   */

  log (message) {
      this.send('log', message)
  };
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Bridge;
;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {/*!
 * Vue.js v2.4.2
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

var _toString = Object.prototype.toString;

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(val);
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str
    .replace(hyphenateRE, '$1-$2')
    .replace(hyphenateRE, '$1-$2')
    .toLowerCase()
});

/**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */


/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

var warn = noop;
var tip = noop;
var formatComponentName = (null); // work around flow check

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var name = typeof vm === 'string'
      ? vm
      : typeof vm === 'function' && vm.options
        ? vm.options.name
        : vm._isVue
          ? vm.$options.name || vm.$options._componentTag
          : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  var generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

function handleError (err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (process.env.NODE_ENV !== 'production') {
      warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err
    }
  }
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefix has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = (function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function (err) { console.error(err); };
    timerFunc = function () {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) { setTimeout(noop); }
    };
  } else if (typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function () {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve, reject) {
        _resolve = resolve;
      })
    }
  }
})();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */


var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value)) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this) : parentVal
      )
    }
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm)
        : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn.call(this, parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal
    ? extend(res, childVal)
    : res
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (parentVal, childVal) {
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + key
      );
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options) {
  var inject = options.inject;
  if (Array.isArray(inject)) {
    var normalized = options.inject = {};
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = inject[i];
    }
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child);
  normalizeInject(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (process.env.NODE_ENV !== 'production') {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      'Invalid prop: type check failed for prop "' + name + '".' +
      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    valid = typeof value === expectedType.toLowerCase();
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isType (type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type)
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true
    }
  }
  /* istanbul ignore next */
  return false
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      "referenced during render. Make sure to declare reactive data " +
      "properties in the data option.",
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' &&
    Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  return cloned
}

function cloneVNodes (vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      process.env.NODE_ENV !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        (last).text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (comp.__esModule && comp.default) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      process.env.NODE_ENV !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && isDef(c.componentOptions)) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (process.env.NODE_ENV !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) &&
      child.data && child.data.slot != null
    ) {
      var name = child.data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots
}

function isWhitespace (node) {
  return node.isComment || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure((name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure((name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listensers hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs;
  vm.$listeners = listeners;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options
) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production'
    ? expOrFn.toString()
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse (val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function checkOptionType (vm, name) {
  var option = vm.$options[name];
  if (!isPlainObject(option)) {
    warn(
      ("component option \"" + name + "\" should be an object."),
      vm
    );
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      if (isReservedAttribute(key) || config.isReservedAttr(key)) {
        warn(
          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  observerState.shouldConvert = true;
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  try {
    return data.call(vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  if (process.env.NODE_ENV !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn(
          "method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
    }
  }
}

function initWatch (vm, watch) {
  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  keyOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
        ? Reflect.ownKeys(inject)
        : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (process.env.NODE_ENV !== 'production' && !source) {
        warn(("Injection \"" + key + "\" not found"), vm);
      }
    }
    return result
  }
}

/*  */

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  context,
  children
) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || {});
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
  var vnode = Ctor.options.render.call(null, h, {
    data: data,
    props: props,
    children: children,
    parent: context,
    listeners: data.on || {},
    injections: resolveInject(Ctor.options.inject, context),
    slots: function () { return resolveSlots(children, context); }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    vnode.functionalOptions = Ctor.options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options)
}

function mergeHooks (data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1 (one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    warn(
      'Avoid using non-primitive value as key, ' +
      'use string/number value instead.',
      context
    );
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) { applyNS(vnode, ns); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && isUndef(child.ns)) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      props = extend(extend({}, bindObject), props);
    }
    return scopedSlotFn(props) || fallback
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && process.env.NODE_ENV !== 'production') {
      slotNodes._rendered && warn(
        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
        "- this will likely cause render errors.",
        this
      );
      slotNodes._rendered = true;
    }
    return slotNodes || fallback
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias
) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1
  } else {
    return keyCodes !== eventKeyCode
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] =
    this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      process.env.NODE_ENV !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(ours, existing) : ours;
      }
    }
  }
  return data
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);
    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);
  }
}

function renderMixin (Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        vnode = vm.$options.renderError
          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
          : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
  Vue.prototype._g = bindObjectListeners;
}

/*  */

var uid = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = "vue-perf-init:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(((vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue$3 (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue$3)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn(
          'Invalid component name: "' + name + '". Component names ' +
          'can only contain alphanumeric characters and the hyphen, ' +
          'and must start with a letter.'
        );
      }
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && config.isReservedTag(id)) {
            warn(
              'Do not use built-in or reserved HTML elements as component ' +
              'id: ' + id
            );
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp, Array];

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (cache, current, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        if (cachedNode !== current) {
          pruneCacheEntry(cachedNode);
        }
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry (vnode) {
  if (vnode) {
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created () {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include (val) {
      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });
    },
    exclude: function exclude (val) {
      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });
    }
  },

  render: function render () {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (
        (this.include && !matches(this.include, name)) ||
        (this.exclude && matches(this.exclude, name))
      )) {
        return vnode
      }
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

Vue$3.version = '2.4.2';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);



var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setAttribute (node, key, val) {
  node.setAttribute(key, val);
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

// Some browsers do not support dynamically changing type for <input>
// so they need to be treated as different nodes
function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          inPre++;
        }
        if (
          !inPre &&
          !vnode.ns &&
          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
          config.isUnknownElement(tag)
        ) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
            warn(
              'It seems there are duplicate keys that is causing an update error. ' +
              'Make sure each v-for item has a unique key.'
            );
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true
    }
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode)) {
        return false
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (process.env.NODE_ENV !== 'production' &&
              typeof console !== 'undefined' &&
              !bailed
            ) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode) {
    if (isDef(vnode.tag)) {
      return (
        vnode.tag.indexOf('vue-component') === 0 ||
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, key);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;



function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + "," + args)
  }
}

/*  */

/*  */

/**
 * Cross-platform code generation for component v-model
 */


/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var str;
var index$1;

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  var event;
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
  if (once$$1) {
    var oldHandler = handler;
    var _target = target$1; // save current target element in closure
    handler = function (ev) {
      var res = arguments.length === 1
        ? oldHandler(ev)
        : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (
  elm,
  vnode,
  checkVal
) {
  return (!elm.composing && (
    vnode.tag === 'option' ||
    isDirty(elm, checkVal) ||
    isInputChanged(elm, checkVal)
  ))
}

function isDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isInputChanged (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number) {
    return toNumber(value) !== toNumber(newVal)
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim()
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likley wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame
  ? window.requestAnimationFrame.bind(window)
  : setTimeout;

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted (el, binding, vnode) {
    if (vnode.tag === 'select') {
      var cb = function () {
        setSelected(el, binding, vnode.context);
      };
      cb();
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(cb, 0);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        trigger(el, 'change');
      }
    }
  }
};

function setSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$options._renderChildren;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log'](
        'Download the Vue Devtools extension for a better development experience:\n' +
        'https://github.com/vuejs/vue-devtools'
      );
    }
  }
  if (process.env.NODE_ENV !== 'production' &&
    config.productionTip !== false &&
    inBrowser && typeof console !== 'undefined'
  ) {
    console[console.info ? 'info' : 'log'](
      "You are running Vue in development mode.\n" +
      "Make sure to turn on production mode when deploying for production.\n" +
      "See more tips at https://vuejs.org/guide/deployment.html"
    );
  }
}, 0);

/*  */

/* harmony default export */ __webpack_exports__["a"] = (Vue$3);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(31), __webpack_require__(57)))

/***/ }),
/* 6 */,
/* 7 */,
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = initDevTools;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__App_vue__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__App_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__App_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__store__ = __webpack_require__(16);





function initDevTools (shell) {
    initUi(shell);
};

function initUi (shell) {
    let app = null;

    shell.connect(bridge => {
        window.MATCHBRIDGE = bridge;

        bridge.on('flush', function (data) {
            __WEBPACK_IMPORTED_MODULE_2__store__["a" /* default */].commit('flush', data);
        });

        app = new __WEBPACK_IMPORTED_MODULE_0_vue__["a" /* default */]({
            store: __WEBPACK_IMPORTED_MODULE_2__store__["a" /* default */],
            render (h) {
                return h(__WEBPACK_IMPORTED_MODULE_1__App_vue___default.a);
            }
        }).$mount('#app');
    });
};


/***/ }),
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_SRC_index__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_SRC_bridge__ = __webpack_require__(3);



/*
 * Inject backend.js connec to background, and send back the bridge.
 *
 * @param {Function} cb
 */

__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_SRC_index__["a" /* initDevTools */])({
    connect (cb) {
        // inject backend.js
        injectScript(chrome.runtime.getURL('build/backend.js'), () => {
            // connect to background
            const port = chrome.runtime.connect({
                name: '' + chrome.devtools.inspectedWindow.tabId
            });
            let disconnected = false;
            port.onDisconnect.addListener(() => {
                console.log('disconnected');
                disconnected = true;
            });

            const bridge = new __WEBPACK_IMPORTED_MODULE_1_SRC_bridge__["a" /* default */]({
                listen (fn) {
                    port.onMessage.addListener(fn);
                },
                send (data) {
                    if (!disconnected) {
                        port.postMessage(data);
                    }
                }
            });

            // send back bridge
            cb(bridge);
        });
    }
});

function injectScript (scriptName, cb) {
  const src = `
        var script = document.constructor.prototype.createElement.call(document, 'script');
        script.src = "${scriptName}";
        document.documentElement.appendChild(script);
        script.parentNode.removeChild(script);
  `;

  chrome.devtools.inspectedWindow.eval(src, function (res, err) {
      if (err) {
          console.log(err);
      }
      cb();
  });
};


/***/ }),
/* 13 */,
/* 14 */,
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export inDoc */
/* unused harmony export stringify */
/* unused harmony export parse */
/* harmony export (immutable) */ __webpack_exports__["d"] = isPlainObject;
/* unused harmony export searchDeepInObject */
/* harmony export (immutable) */ __webpack_exports__["e"] = sortByKey;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_circular_json_es6__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_circular_json_es6___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_circular_json_es6__);


function cached (fn) {
  const cache = Object.create(null)
  return function cachedFn (str) {
    const hit = cache[str]
    return hit || (cache[str] = fn(str))
  }
}

var classifyRE = /(?:^|[-_/])(\w)/g
const classify = cached((str) => {
  return str.replace(classifyRE, toUpper)
})
/* unused harmony export classify */


const camelizeRE = /-(\w)/g
const camelize = cached((str) => {
  return str.replace(camelizeRE, toUpper)
})
/* unused harmony export camelize */


function toUpper (_, c) {
  return c ? c.toUpperCase() : ''
}

function inDoc (node) {
  if (!node) { return false }
  var doc = node.ownerDocument.documentElement
  var parent = node.parentNode
  return doc === node ||
    doc === parent ||
    !!(parent && parent.nodeType === 1 && (doc.contains(parent)))
}

/**
 * Stringify/parse data using CircularJSON.
 */

const UNDEFINED = '__vue_devtool_undefined__'
/* harmony export (immutable) */ __webpack_exports__["a"] = UNDEFINED;

const INFINITY = '__vue_devtool_infinity__'
/* harmony export (immutable) */ __webpack_exports__["b"] = INFINITY;

const NAN = '__vue_devtool_nan__'
/* harmony export (immutable) */ __webpack_exports__["c"] = NAN;


function stringify (data) {
  return __WEBPACK_IMPORTED_MODULE_0_circular_json_es6___default.a.stringify(data, replacer)
}

function replacer (key, val) {
  if (val === undefined) {
    return UNDEFINED
  } else if (val === Infinity) {
    return INFINITY
  } else if (Number.isNaN(val)) {
    return NAN
  } else if (val instanceof RegExp) {
    // special handling of native type
    return `[native RegExp ${val.toString()}]`
  } else {
    return sanitize(val)
  }
}

function parse (data, revive) {
  return revive
    ? __WEBPACK_IMPORTED_MODULE_0_circular_json_es6___default.a.parse(data, reviver)
    : __WEBPACK_IMPORTED_MODULE_0_circular_json_es6___default.a.parse(data)
}

function reviver (key, val) {
  if (val === UNDEFINED) {
    return undefined
  } else if (val === INFINITY) {
    return Infinity
  } else if (val === NAN) {
    return NaN
  } else {
    return val
  }
}

/**
 * Sanitize data to be posted to the other side.
 * Since the message posted is sent with structured clone,
 * we need to filter out any types that might cause an error.
 *
 * @param {*} data
 * @return {*}
 */

function sanitize (data) {
  if (
    !isPrimitive(data) &&
    !Array.isArray(data) &&
    !isPlainObject(data)
  ) {
    // handle types that will probably cause issues in
    // the structured clone
    return Object.prototype.toString.call(data)
  } else {
    return data
  }
}

function isPlainObject (obj) {
  return Object.prototype.toString.call(obj) === '[object Object]'
}

function isPrimitive (data) {
  if (data == null) {
    return true
  }
  const type = typeof data
  return (
    type === 'string' ||
    type === 'number' ||
    type === 'boolean'
  )
}

function searchDeepInObject (obj, searchTerm) {
  var match = false
  const keys = Object.keys(obj)
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i]
    const value = obj[key]
    if (compare(key, searchTerm) || compare(value, searchTerm)) {
      match = true
      break
    }
    if (isPlainObject(value)) {
      match = searchDeepInObject(value, searchTerm)
      if (match) {
        break
      }
    }
  }
  return match
}

function compare (mixedValue, stringValue) {
  if (Array.isArray(mixedValue) && searchInArray(mixedValue, stringValue.toLowerCase())) {
    return true
  }
  if (('' + mixedValue).toLowerCase().indexOf(stringValue.toLowerCase()) !== -1) {
    return true
  }
  return false
}

function searchInArray (arr, searchTerm) {
  let found = false
  for (let i = 0; i < arr.length; i++) {
    if (('' + arr[i]).toLowerCase().indexOf(searchTerm) !== -1) {
      found = true
      break
    }
  }
  return found
}

function sortByKey (state) {
  return state && state.slice().sort((a, b) => {
    if (a.key < b.key) { return -1 }
    if (a.key > b.key) { return 1 }
    return 0
  })
}


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vuex__ = __webpack_require__(56);
/**
 * @description vuex 存储全局的match数据
 */



__WEBPACK_IMPORTED_MODULE_0_vue__["a" /* default */].use(__WEBPACK_IMPORTED_MODULE_1_vuex__["a" /* default */]);

const store = new __WEBPACK_IMPORTED_MODULE_1_vuex__["a" /* default */].Store({
    state: {
        matches: [
        ],
        showMatch: [
        ]
    },
    mutations: {
        flush (state, data) {
            state.matches = data;
        },
        chooseItem (state, item) {
            state.showMatch = [item];
        }
    }
});

/* harmony default export */ __webpack_exports__["a"] = (store);


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_COMPONENTS_matchContent_matchContent_vue__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_COMPONENTS_matchContent_matchContent_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_COMPONENTS_matchContent_matchContent_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["default"] = ({
    name: 'app',
    data () {
        return {
            message: 'match',
            tab: 'match',
            isDark: typeof chrome !== 'undefined' &&
            typeof chrome.devtools !== 'undefined' &&
            chrome.devtools.panels.themeName === 'dark'
        }
    },
    components: {
        match: __WEBPACK_IMPORTED_MODULE_0_COMPONENTS_matchContent_matchContent_vue___default.a 
    },
    methods: {
        refresh () {
            const refreshIcon = this.$refs.refresh;
            refreshIcon.style.animation = 'none';
            // flush按钮旋转
            MATCHBRIDGE.once('flush', () => {
                refreshIcon.style.animation = 'rotate 1s'
            });
            MATCHBRIDGE.send('flush');
        },
        updateActiveBar () {
            const activeButton = this.$el.querySelector('.button.active');
            const activeBar = this.$el.querySelector('.active-bar');
            activeBar.style.left = activeButton.offsetLeft + 'px';
            activeBar.style.width = activeButton.offsetWidth + 'px';
        }
    },
    mounted () {
        this.updateActiveBar();
        window.addEventListener('resize', this.updateActiveBar);
    },
    destroyed () {
        window.removeEventListener('resize', this.updateActiveBar);
    }
});


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(15);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



const rawTypeRE = /^\[object (\w+)]$/
const specialTypeRE = /^\[native \w+ (.*)\]$/

function subFieldCount (value) {
  if (Array.isArray(value)) {
    return value.length
  } else if (value && typeof value === 'object') {
    return Object.keys(value).length
  } else {
    return 0
  }
}

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'DataField',
  props: {
    field: Object,
    depth: Number
  },
  data () {
    return {
      limit: Array.isArray(this.field.value) ? 10 : Infinity,
      expanded: this.depth === 0 && this.field.key !== '$route' && (subFieldCount(this.field.value) < 5)
    }
  },
  computed: {
    valueType () {
      const value = this.field.value
      const type = typeof value
      if (value == null || value === __WEBPACK_IMPORTED_MODULE_0__util__["a" /* UNDEFINED */]) {
        return 'null'
      } else if (
        type === 'boolean' ||
        type === 'number' ||
        value === __WEBPACK_IMPORTED_MODULE_0__util__["b" /* INFINITY */] ||
        value === __WEBPACK_IMPORTED_MODULE_0__util__["c" /* NAN */]
      ) {
        return 'literal'
      } else if (specialTypeRE.test(value)) {
        return 'native'
      } else if (type === 'string' && !rawTypeRE.test(value)) {
        return 'string'
      }
    },
    isExpandableType () {
      const value = this.field.value
      return Array.isArray(value) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["d" /* isPlainObject */])(value)
    },
    formattedValue () {
      const value = this.field.value
      if (value === null) {
        return 'null'
      } else if (value === __WEBPACK_IMPORTED_MODULE_0__util__["a" /* UNDEFINED */]) {
        return 'undefined'
      } else if (value === __WEBPACK_IMPORTED_MODULE_0__util__["c" /* NAN */]) {
        return 'NaN'
      } else if (value === __WEBPACK_IMPORTED_MODULE_0__util__["b" /* INFINITY */]) {
        return 'Infinity'
      } else if (Array.isArray(value)) {
        return 'Array[' + value.length + ']'
      } else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["d" /* isPlainObject */])(value)) {
        return 'Object' + (Object.keys(value).length ? '' : ' (empty)')
      } else if (this.valueType === 'native') {
        return specialTypeRE.exec(value)[1]
      } else if (typeof value === 'string') {
        var typeMatch = value.match(rawTypeRE)
        if (typeMatch) {
          return typeMatch[1]
        } else {
          return JSON.stringify(value)
        }
      } else {
        return value
      }
    },
    formattedSubFields () {
      let value = this.field.value
      if (Array.isArray(value)) {
        value = value.map((item, i) => ({
          key: i,
          value: item
        }))
      } else if (typeof value === 'object') {
        value = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* sortByKey */])(Object.keys(value).map(key => ({
          key,
          value: value[key]
        })))
      }
      return value
    },
    limitedSubFields () {
      return this.formattedSubFields.slice(0, this.limit)
    }
  },
  methods: {
    toggle () {
      if (this.isExpandableType) {
        this.expanded = !this.expanded
      }
    },
    hyphen: v => v.replace(/\s/g, '-')
  }
});


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  data () {
      return {
          split: 50,
          dragging: false
      }
  },
  methods: {
      dragStart (e) {
          this.dragging = true;
          this.startX = e.pageX;
          this.startSplit = this.split;
      },
      dragMove (e) {
          if (this.dragging) {
              const dx = e.pageX - this.startX;
              const totalWidth = this.$el.offsetWidth;
              this.split = this.startSplit + ~~(dx / totalWidth * 100);
          }
      },
      dragEnd () {
          this.dragging = false;
      }
  }
});


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__splitPane_splitPane_vue__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__splitPane_splitPane_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__splitPane_splitPane_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__matchFilter_matchFilter_vue__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__matchFilter_matchFilter_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__matchFilter_matchFilter_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_COMPONENTS_matchObj_matchObj_vue__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_COMPONENTS_matchObj_matchObj_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_COMPONENTS_matchObj_matchObj_vue__);




/* harmony default export */ __webpack_exports__["default"] = ({
    computed: {
        matchArr () {
            return this.$store.state.showMatch;
        }
    },
    components: {
        matchFilter: __WEBPACK_IMPORTED_MODULE_1__matchFilter_matchFilter_vue___default.a,
        matchObj: __WEBPACK_IMPORTED_MODULE_2_COMPONENTS_matchObj_matchObj_vue___default.a,
        SplitPane: __WEBPACK_IMPORTED_MODULE_0__splitPane_splitPane_vue___default.a
    },
    beforeMount () {
        console.log(this.matchArr);
    },
    methods: {
        filter (e) {
            bridge.send('filter-instances', e.target.value)
        }
    }
});


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__actionTab_vue__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__actionTab_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__actionTab_vue__);


/* harmony default export */ __webpack_exports__["default"] = ({
    data () {
        return {
            filterKey: '',
            activeItem: {}
        }
    },
    computed: {
        matchArr () {
            return this.$store.state.matches;
        }
    },
    components: {
        ActionHeader: __WEBPACK_IMPORTED_MODULE_0__actionTab_vue___default.a
    },
    methods: {
        filterStacks (e) {
            this.filterKey = e.target.value;
        },
        chooseItem (item) {
            this.activeItem = item;
            this.$store.commit('chooseItem', item);
        }
    }
});


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dataField_vue__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dataField_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__dataField_vue__);


/* harmony default export */ __webpack_exports__["default"] = ({
    props: {
        stacks: Array
    },
    components: {
        DataField: __WEBPACK_IMPORTED_MODULE_0__dataField_vue___default.a
    }
});


/***/ }),
/* 23 */
/***/ (function(module, exports) {

function encode (data, replacer, list, seen) {
  var stored, key, value, i, l
  var seenIndex = seen.get(data)
  if (seenIndex != null) {
    return seenIndex
  }
  var index = list.length
  if (isPlainObject(data)) {
    stored = {}
    seen.set(data, index)
    list.push(stored)
    var keys = Object.keys(data)
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i]
      value = data[key]
      if (replacer) {
        value = replacer.call(data, key, value)
      }
      stored[key] = encode(value, replacer, list, seen)
    }
  } else if (Array.isArray(data)) {
    stored = []
    seen.set(data, index)
    list.push(stored)
    for (i = 0, l = data.length; i < l; i++) {
      value = data[i]
      if (replacer) {
       value = replacer.call(data, i, value)
      }
      stored[i] = encode(value, replacer, list, seen)
    }
  } else {
    index = list.length
    list.push(data)
  }
  return index
}

function decode (list, reviver) {
  var i = list.length
  var j, k, data, key, value
  while (i--) {
    var data = list[i]
    if (isPlainObject(data)) {
      var keys = Object.keys(data)
      for (j = 0, k = keys.length; j < k; j++) {
        key = keys[j]
        value = list[data[key]]
        if (reviver) value = reviver.call(data, key, value)
        data[key] = value
      }
    } else if (Array.isArray(data)) {
      for (j = 0, k = data.length; j < k; j++) {
        value = list[data[j]]
        if (reviver) value = reviver.call(data, j, value)
        data[j] = value
      }
    }
  }
}

function isPlainObject (obj) {
  return Object.prototype.toString.call(obj) === '[object Object]'
}

exports.stringify = function stringify (data, replacer, space) {
  try {
    return arguments.length === 1
      ? JSON.stringify(data)
      : JSON.stringify(data, replacer, space)
  } catch (e) {
    return exports.stringifyStrict(data, replacer, space)
  }
}

exports.parse = function parse (data, reviver) {
  var hasCircular = /^\s/.test(data)
  if (!hasCircular) {
    return arguments.length === 1
      ? JSON.parse(data)
      : JSON.parse(data, reviver)
  } else {
    var list = JSON.parse(data)
    decode(list, reviver)
    return list[0]
  }
}

exports.stringifyStrict = function (data, replacer, space) {
  var list = []
  encode(data, replacer, list, new Map())
  return space
    ? ' ' + JSON.stringify(list, null, space)
    : ' ' + JSON.stringify(list)
}


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.slide-up-enter {\n  opacity: 0;\n  transform: translate(0, 50%);\n}\n.slide-up-leave-to {\n  opacity: 0;\n  transform: translate(0, -50%);\n}\n.slide-down-enter,\n.slide-down-leave-to {\n  opacity: 0;\n  transform: translate(0, -20px);\n}\n@-moz-keyframes rotate {\n0% {\n    transform: rotate(0deg);\n}\n100% {\n    transform: rotate(360deg);\n}\n}\n@-webkit-keyframes rotate {\n0% {\n    transform: rotate(0deg);\n}\n100% {\n    transform: rotate(360deg);\n}\n}\n@-o-keyframes rotate {\n0% {\n    transform: rotate(0deg);\n}\n100% {\n    transform: rotate(360deg);\n}\n}\n@keyframes rotate {\n0% {\n    transform: rotate(0deg);\n}\n100% {\n    transform: rotate(360deg);\n}\n}\n@font-face {\n  font-family: 'Material Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: url(" + __webpack_require__(32) + ") format('woff2');\n}\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Roboto'), local('Roboto-Regular'), url(" + __webpack_require__(33) + ") format('woff2');\n}\n.material-icons {\n  font-family: 'Material Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 22px;\n  display: inline-block;\n  width: 1em;\n  height: 1em;\n  color: #999;\n  line-height: 1;\n  text-transform: none;\n  letter-spacing: normal;\n  word-wrap: normal;\n  white-space: nowrap;\n  direction: ltr;\n/* Support for all WebKit browsers. */\n  -webkit-font-smoothing: antialiased;\n/* Support for Safari and Chrome. */\n  text-rendering: optimizeLegibility;\n/* Support for Firefox. */\n  -moz-osx-font-smoothing: grayscale;\n}\n.material-icons.medium {\n  transform: scale(0.9);\n}\n.material-icons.small {\n  transform: scale(0.8);\n}\n.toggle-recording .material-icons {\n  color: #999 !important;\n}\n.toggle-recording .material-icons.enabled {\n  color: #f00 !important;\n  text-shadow: 0 0 3px rgba(255,0,0,0.4);\n}\nhtml,\nbody {\n  margin: 0;\n  padding: 0;\n  font-family: Roboto;\n  font-size: 16px;\n  color: #444;\n}\n* {\n  box-sizing: border-box;\n}\n.arrow {\n  display: inline-block;\n  width: 0;\n  height: 0;\n}\n.arrow.up {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-bottom: 6px solid #444;\n}\n.arrow.down {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 6px solid #444;\n}\n.arrow.right {\n  border-top: 4px solid transparent;\n  border-bottom: 4px solid transparent;\n  border-left: 6px solid #444;\n}\n.arrow.left {\n  border-top: 4px solid transparent;\n  border-bottom: 4px solid transparent;\n  border-right: 6px solid #444;\n}\n.notice {\n  display: flex;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n  color: #aaa;\n}\n.notice div {\n  text-align: center;\n  padding: 0.5em;\n  margin: 0 auto;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/transitions.styl","G:/luobata/lib/match-devtools/src/global.styl"],"names":[],"mappings":";AAAA;EACE,WAAA;EACA,6BAAA;CCCD;ADCD;EACE,WAAA;EACA,8BAAA;CCCD;ADCD;;EACE,WAAA;EACA,+BAAA;CCED;ADAU;AACT;IACE,wBAAA;CCED;ADDD;IACE,0BAAA;CCGD;CACF;ADRU;AACT;IACE,wBAAA;CCUD;ADTD;IACE,0BAAA;CCWD;CACF;ADhBU;AACT;IACE,wBAAA;CCkBD;ADjBD;IACE,0BAAA;CCmBD;CACF;ADxBU;AACT;IACE,wBAAA;CC0BD;ADzBD;IACE,0BAAA;CC2BD;CACF;AAzCD;EACE,8BAAA;EACA,mBAAA;EACA,iBAAA;EACA,mDAAA;CA2CD;AAzCD;EACE,sBAAA;EACA,mBAAA;EACA,iBAAA;EACA,6FAAA;CA2CD;AAzCD;EACE,8BAAA;EACA,oBAAA;EACA,mBAAA;EACA,gBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,YAAA;EACA,eAAA;EACA,qBAAA;EACA,uBAAA;EACA,kBAAA;EACA,oBAAA;EACA,eAAA;AACA,sCAAA;EACA,oCAAA;AACA,oCAAA;EACA,mCAAA;AACA,0BAAA;EACA,mCAAA;CA2CD;AA1CC;EACE,sBAAA;CA4CH;AA3CC;EACE,sBAAA;CA6CH;AA3CD;EACE,uBAAA;CA6CD;AA5CC;EACE,uBAAA;EACA,uCAAA;CA8CH;AA5CD;;EACE,UAAA;EACA,WAAA;EACA,oBAAA;EACA,gBAAA;EACA,YAAA;CA+CD;AA7CD;EACE,uBAAA;CA+CD;AA3CD;EACE,sBAAA;EACA,SAAA;EACA,UAAA;CA6CD;AA5CC;EACE,mCAAA;EACA,oCAAA;EACA,8BAAA;CA8CH;AA7CC;EACE,mCAAA;EACA,oCAAA;EACA,2BAAA;CA+CH;AA9CC;EACE,kCAAA;EACA,qCAAA;EACA,4BAAA;CAgDH;AA/CC;EACE,kCAAA;EACA,qCAAA;EACA,6BAAA;CAiDH;AA/CD;EACE,cAAA;EACA,oBAAA;EACA,aAAA;EACA,YAAA;EACA,YAAA;CAiDD;AAhDC;EACE,mBAAA;EACA,eAAA;EACA,eAAA;CAkDH","file":"global.styl","sourcesContent":[".slide-up-enter\r\n  opacity 0\r\n  transform translate(0, 50%)\r\n\r\n.slide-up-leave-to\r\n  opacity 0\r\n  transform translate(0, -50%)\r\n\r\n.slide-down-enter, .slide-down-leave-to\r\n  opacity 0\r\n  transform translate(0, -20px)\r\n\r\n@keyframes rotate\r\n  0%\r\n    transform rotate(0deg)\r\n  100%\r\n    transform rotate(360deg)\r\n","@import \"./variables\"\r\n@import \"./transitions\"\r\n\r\n@font-face\r\n  font-family 'Material Icons'\r\n  font-style normal\r\n  font-weight 400\r\n  src url(./assets/MaterialIcons-Regular.woff2) format('woff2')\r\n\r\n@font-face\r\n  font-family 'Roboto'\r\n  font-style normal\r\n  font-weight 400\r\n  src local('Roboto'), local('Roboto-Regular'), url(./assets/Roboto-Regular.woff2) format('woff2')\r\n\r\n.material-icons\r\n  font-family 'Material Icons'\r\n  font-weight normal\r\n  font-style normal\r\n  font-size 22px\r\n  display inline-block\r\n  width 1em\r\n  height 1em\r\n  color #999\r\n  line-height 1\r\n  text-transform none\r\n  letter-spacing normal\r\n  word-wrap normal\r\n  white-space nowrap\r\n  direction ltr\r\n  /* Support for all WebKit browsers. */\r\n  -webkit-font-smoothing: antialiased\r\n  /* Support for Safari and Chrome. */\r\n  text-rendering: optimizeLegibility\r\n  /* Support for Firefox. */\r\n  -moz-osx-font-smoothing: grayscale\r\n  &.medium\r\n    transform scale(0.9)\r\n  &.small\r\n    transform scale(0.8)\r\n\r\n.toggle-recording .material-icons\r\n  color #999 !important\r\n  &.enabled\r\n    color red !important\r\n    text-shadow 0 0 3px rgba(255, 0, 0, .4)\r\n\r\nhtml, body\r\n  margin 0\r\n  padding 0\r\n  font-family Roboto\r\n  font-size 16px\r\n  color #444\r\n\r\n*\r\n  box-sizing border-box\r\n\r\n$arrow-color = #444\r\n\r\n.arrow\r\n  display inline-block\r\n  width 0\r\n  height 0\r\n  &.up\r\n    border-left 4px solid transparent\r\n    border-right 4px solid transparent\r\n    border-bottom 6px solid $arrow-color\r\n  &.down\r\n    border-left 4px solid transparent\r\n    border-right 4px solid transparent\r\n    border-top 6px solid $arrow-color\r\n  &.right\r\n    border-top 4px solid transparent\r\n    border-bottom 4px solid transparent\r\n    border-left 6px solid $arrow-color\r\n  &.left\r\n    border-top 4px solid transparent\r\n    border-bottom 4px solid transparent\r\n    border-right 6px solid $arrow-color\r\n\r\n.notice\r\n  display flex\r\n  align-items center\r\n  height 100%\r\n  width 100%\r\n  color #aaa\r\n  div\r\n    text-align center\r\n    padding 0.5em\r\n    margin 0 auto\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.app[data-v-3499c881] {\n  width: 100%;\n  height: 100%;\n  user-select: none;\n  background-color: #fff;\n  display: flex;\n  flex-direction: column;\n}\n.app h1[data-v-3499c881] {\n  color: #42b983;\n}\n.app.dark[data-v-3499c881] {\n  background-color: #242424;\n}\n.header[data-v-3499c881] {\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid #ddd;\n  box-shadow: 0 0 8px rgba(0,0,0,0.15);\n  font-size: 14px;\n  position: relative;\n}\n.app.dark .header[data-v-3499c881] {\n  border-bottom: 1px solid #3a3a3a;\n}\n.message-container[data-v-3499c881] {\n  height: 1em;\n  cursor: default;\n}\n.message[data-v-3499c881] {\n  color: #3ba776;\n  transition: all 0.3s ease;\n  position: absolute;\n}\n.button[data-v-3499c881] {\n  padding: 10px;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  position: relative;\n  border-bottom-color: transparent;\n  background-color: #fff;\n  color: #888;\n  transition: color 0.35s ease;\n}\n.app.dark .button[data-v-3499c881] {\n  background-color: #242424;\n}\n.button[data-v-3499c881]:hover {\n  color: #555;\n}\n.button.active[data-v-3499c881] {\n  color: #3ba776;\n}\n.button[data-v-3499c881]:first-of-type {\n  margin-left: auto;\n}\n.button .material-icons[data-v-3499c881] {\n  font-size: 20px;\n  margin-right: 5px;\n  color: inherit;\n}\n.button .pane-name[data-v-3499c881] {\n  display: none;\n}\n@media (min-width: 820px) {\n.button[data-v-3499c881] {\n    padding-right: 20px;\n    padding-left: 20px;\n}\n.button .pane-name[data-v-3499c881] {\n    display: block;\n}\n}\n@media (min-height: 300px) {\n.button[data-v-3499c881] {\n    padding-top: 20px;\n    padding-bottom: 20px;\n}\n}\n.container[data-v-3499c881] {\n  overflow: hidden;\n  flex: 1;\n}\n.event-count[data-v-3499c881] {\n  background-color: #3ba776;\n  color: #fff;\n  border-radius: 50%;\n  width: 18px;\n  height: 18px;\n  text-align: center;\n  padding-top: 4px;\n  font-size: 9px;\n  position: absolute;\n  right: 0;\n  top: 12px;\n}\n.app.dark .event-count[data-v-3499c881] {\n  background-color: #242424;\n}\n.active-bar[data-v-3499c881] {\n  position: absolute;\n  bottom: 0;\n  width: 0px;\n  height: 3px;\n  background-color: #3ba776;\n  transition: all 0.32s cubic-bezier(0, 0.9, 0.6, 1);\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/App.vue"],"names":[],"mappings":";AA0EA;EACE,YAAA;EACA,aAAA;EACA,kBAAA;EACA,uBAAA;EACA,cAAA;EACA,uBAAA;CAzED;AA0EC;EACE,eAAA;CAxEH;AAyEC;EACE,0BAAA;CAvEH;AAwED;EACE,cAAA;EACA,oBAAA;EACA,8BAAA;EACA,qCAAA;EACA,gBAAA;EACA,mBAAA;CAtED;AAuEC;EACE,iCAAA;CArEH;AAsED;EACE,YAAA;EACA,gBAAA;CApED;AAqED;EACE,eAAA;EACA,0BAAA;EACA,mBAAA;CAnED;AAoED;EACE,cAAA;EACA,cAAA;EACA,oBAAA;EACA,gBAAA;EACA,mBAAA;EACA,iCAAA;EACA,uBAAA;EACA,YAAA;EACA,6BAAA;CAlED;AAmEC;EACE,0BAAA;CAjEH;AAkEC;EACE,YAAA;CAhEH;AAiEC;EACE,eAAA;CA/DH;AAgEC;EACE,kBAAA;CA9DH;AA+DC;EACE,gBAAA;EACA,kBAAA;EACA,eAAA;CA7DH;AA8DC;EACE,cAAA;CA5DH;AA6DyB;AAAA;IACtB,oBAAA;IACA,mBAAA;CA1DD;AA2DC;IACE,eAAA;CAzDH;CACF;AAyD0B;AAAA;IACvB,kBAAA;IACA,qBAAA;CAtDD;CACF;AAsDD;EACE,iBAAA;EACA,QAAA;CApDD;AAsDD;EACE,0BAAA;EACA,YAAA;EACA,mBAAA;EACA,YAAA;EACA,aAAA;EACA,mBAAA;EACA,iBAAA;EACA,eAAA;EACA,mBAAA;EACA,SAAA;EACA,UAAA;CApDD;AAqDC;EACE,0BAAA;CAnDH;AAoDD;EACE,mBAAA;EACA,UAAA;EACA,WAAA;EACA,YAAA;EACA,0BAAA;EACA,mDAAA;CAlDD","file":"App.vue","sourcesContent":[".app {\n  width: 100%;\n  height: 100%;\n  user-select: none;\n  background-color: #fff;\n  display: flex;\n  flex-direction: column;\n}\n.app h1 {\n  color: #42b983;\n}\n.app.dark {\n  background-color: #242424;\n}\n.header {\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid #ddd;\n  box-shadow: 0 0 8px rgba(0,0,0,0.15);\n  font-size: 14px;\n  position: relative;\n}\n.app.dark .header {\n  border-bottom: 1px solid #3a3a3a;\n}\n.message-container {\n  height: 1em;\n  cursor: default;\n}\n.message {\n  color: #3ba776;\n  transition: all 0.3s ease;\n  position: absolute;\n}\n.button {\n  padding: 10px;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  position: relative;\n  border-bottom-color: transparent;\n  background-color: #fff;\n  color: #888;\n  transition: color 0.35s ease;\n}\n.app.dark .button {\n  background-color: #242424;\n}\n.button:hover {\n  color: #555;\n}\n.button.active {\n  color: #3ba776;\n}\n.button:first-of-type {\n  margin-left: auto;\n}\n.button .material-icons {\n  font-size: 20px;\n  margin-right: 5px;\n  color: inherit;\n}\n.button .pane-name {\n  display: none;\n}\n@media (min-width: 820px) {\n  .button {\n    padding-right: 20px;\n    padding-left: 20px;\n  }\n  .button .pane-name {\n    display: block;\n  }\n}\n@media (min-height: 300px) {\n  .button {\n    padding-top: 20px;\n    padding-bottom: 20px;\n  }\n}\n.container {\n  overflow: hidden;\n  flex: 1;\n}\n.event-count {\n  background-color: #3ba776;\n  color: #fff;\n  border-radius: 50%;\n  width: 18px;\n  height: 18px;\n  text-align: center;\n  padding-top: 4px;\n  font-size: 9px;\n  position: absolute;\n  right: 0;\n  top: 12px;\n}\n.app.dark .event-count {\n  background-color: #242424;\n}\n.active-bar {\n  position: absolute;\n  bottom: 0;\n  width: 0px;\n  height: 3px;\n  background-color: #3ba776;\n  transition: all 0.32s cubic-bezier(0, 0.9, 0.6, 1);\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.split-pane[data-v-3d0b1c2c] {\n  display: flex;\n  height: 100%;\n}\n.split-pane.dragging[data-v-3d0b1c2c] {\n  cursor: ew-resize;\n}\n.left[data-v-3d0b1c2c],\n.right[data-v-3d0b1c2c] {\n  position: relative;\n}\n.left[data-v-3d0b1c2c] {\n  border-right: 1px solid #ddd;\n}\n.app.dark .left[data-v-3d0b1c2c] {\n  border-right: 1px solid #3a3a3a;\n}\n.dragger[data-v-3d0b1c2c] {\n  position: absolute;\n  z-index: 99;\n  top: 0;\n  bottom: 0;\n  right: -5px;\n  width: 10px;\n  cursor: ew-resize;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/components/src/components/splitPane/splitPane.vue","G:/luobata/lib/match-devtools/src/components/splitPane/splitPane.vue"],"names":[],"mappings":";AAgDA;EACE,cAAA;EACA,aAAA;CC/CD;ADgDC;EACE,kBAAA;CC9CH;ADgDD;;EACE,mBAAA;CC7CD;AD+CD;EACE,6BAAA;CC7CD;AD8CC;EACE,gCAAA;CC5CH;AD8CD;EACE,mBAAA;EACA,YAAA;EACA,OAAA;EACA,UAAA;EACA,YAAA;EACA,YAAA;EACA,kBAAA;CC5CD","file":"splitPane.vue","sourcesContent":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@import \"../../variables\"\n\n.split-pane\n  display flex\n  height 100%\n  &.dragging\n    cursor ew-resize\n\n.left, .right\n  position relative\n\n.left\n  border-right 1px solid $border-color\n  .app.dark &\n    border-right 1px solid $dark-border-color\n\n.dragger\n  position absolute\n  z-index 99\n  top 0\n  bottom 0\n  right -5px\n  width 10px\n  cursor ew-resize\n",".split-pane {\n  display: flex;\n  height: 100%;\n}\n.split-pane.dragging {\n  cursor: ew-resize;\n}\n.left,\n.right {\n  position: relative;\n}\n.left {\n  border-right: 1px solid #ddd;\n}\n.app.dark .left {\n  border-right: 1px solid #3a3a3a;\n}\n.dragger {\n  position: absolute;\n  z-index: 99;\n  top: 0;\n  bottom: 0;\n  right: -5px;\n  width: 10px;\n  cursor: ew-resize;\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.action-header[data-v-a8720af8] {\n  display: flex;\n  align-items: stretch;\n  padding: 0 10px;\n  font-size: 12px;\n  border-bottom: 1px solid #ddd;\n  color: #666;\n  height: 35px;\n}\n@media (min-height: 300px) {\n.action-header[data-v-a8720af8] {\n    height: 50px;\n}\n}\n.app.dark .action-header[data-v-a8720af8] {\n  border-bottom: 1px solid #3a3a3a;\n}\n.title[data-v-a8720af8] {\n  display: flex;\n  align-items: center;\n  font-size: 18px;\n  color: #3ba776;\n}\n.button[data-v-a8720af8] {\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0 10px;\n  transition: opacity 0.25s;\n  white-space: nowrap;\n  opacity: 0.8;\n  overflow: hidden;\n}\n.button[data-v-a8720af8]:first-of-type {\n  margin-left: auto;\n}\n.button[data-v-a8720af8]:not(.disabled):hover {\n  opacity: 1;\n  color: #3ba776;\n}\n.button.disabled[data-v-a8720af8] {\n  opacity: 0.45;\n  cursor: not-allowed;\n}\n.button span[data-v-a8720af8] {\n  display: none;\n}\n@media (min-width: 820px) {\n.button span[data-v-a8720af8] {\n    display: inline;\n}\n}\n.material-icons[data-v-a8720af8] {\n  font-size: 18px;\n  margin-right: 0;\n  color: inherit;\n}\n@media (min-width: 820px) {\n.material-icons[data-v-a8720af8] {\n    margin-right: 5px;\n}\n}\n.search[data-v-a8720af8] {\n  display: flex;\n  align-items: center;\n  flex: 1;\n}\n.search input[data-v-a8720af8] {\n  flex: 1;\n  height: 100%;\n  background-color: transparent;\n  border: 0;\n  margin-left: 5px;\n  font-size: inherit;\n  color: inherit;\n  outline: 0;\n  transition: color 0.25s;\n}\n.search input[data-v-a8720af8]:focus {\n  color: #3ba776;\n}\n.search input[data-v-a8720af8]::placeholder {\n  opacity: 0.8;\n}\n.search input.invalid[data-v-a8720af8] {\n  color: #4d0a09;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/components/src/components/matchFilter/actionTab.vue","G:/luobata/lib/match-devtools/src/components/matchFilter/actionTab.vue"],"names":[],"mappings":";AASA;EACE,cAAA;EACA,qBAAA;EACA,gBAAA;EACA,gBAAA;EACA,8BAAA;EACA,YAAA;EACA,aAAA;CCRD;ADS0B;AAAA;IACvB,aAAA;CCND;CACF;ADMC;EACE,iCAAA;CCJH;ADMD;EACE,cAAA;EACA,oBAAA;EACA,gBAAA;EACA,eAAA;CCJD;ADMD;EACE,gBAAA;EACA,cAAA;EACA,oBAAA;EACA,wBAAA;EACA,gBAAA;EACA,0BAAA;EACA,oBAAA;EACA,aAAA;EACA,iBAAA;CCJD;ADMC;EACE,kBAAA;CCJH;ADMC;EACE,WAAA;EACA,eAAA;CCJH;ADMC;EACE,cAAA;EACA,oBAAA;CCJH;ADMC;EACE,cAAA;CCJH;ADK2B;AAAA;IACtB,gBAAA;CCFH;CACF;ADGD;EACE,gBAAA;EACA,gBAAA;EACA,eAAA;CCDD;ADEyB;AAAA;IACtB,kBAAA;CCCD;CACF;ADAD;EACE,cAAA;EACA,oBAAA;EACA,QAAA;CCED;ADDC;EACE,QAAA;EACA,aAAA;EACA,8BAAA;EACA,UAAA;EACA,iBAAA;EACA,mBAAA;EACA,eAAA;EACA,WAAA;EACA,wBAAA;CCGH;ADFG;EACE,eAAA;CCIL;ADFG;EACE,aAAA;CCIL;ADFG;EACE,eAAA;CCIL","file":"actionTab.vue","sourcesContent":["\n\n\n\n\n\n\n@import \"../../variables\"\n\n.action-header\n  display flex\n  align-items stretch\n  padding 0 10px\n  font-size 12px\n  border-bottom 1px solid $border-color\n  color #666\n  height 35px\n  @media (min-height: $tall)\n    height 50px\n  .app.dark &\n    border-bottom 1px solid $dark-border-color\n\n.title\n  display flex\n  align-items center\n  font-size 18px\n  color $component-color\n\n.button\n  cursor pointer\n  display flex\n  align-items center\n  justify-content center\n  padding 0 10px\n  transition opacity 0.25s\n  white-space nowrap\n  opacity 0.8\n  overflow hidden\n\n  &:first-of-type\n    margin-left auto\n\n  &:not(.disabled):hover\n    opacity 1\n    color $active-color\n\n  &.disabled\n    opacity 0.45\n    cursor not-allowed\n\n  span\n    display none\n    @media (min-width: $wide)\n      display inline\n\n.material-icons\n  font-size 18px\n  margin-right 0\n  color inherit\n  @media (min-width: $wide)\n    margin-right 5px\n\n.search\n  display flex\n  align-items center\n  flex 1\n  input\n    flex 1\n    height 100%\n    background-color transparent\n    border 0\n    margin-left 5px\n    font-size inherit\n    color inherit\n    outline 0\n    transition color 0.25s\n    &:focus\n      color $active-color\n\n    &::placeholder\n      opacity 0.8\n\n    &.invalid\n      color rgba(77, 10, 9, 1)\n",".action-header {\n  display: flex;\n  align-items: stretch;\n  padding: 0 10px;\n  font-size: 12px;\n  border-bottom: 1px solid #ddd;\n  color: #666;\n  height: 35px;\n}\n@media (min-height: 300px) {\n  .action-header {\n    height: 50px;\n  }\n}\n.app.dark .action-header {\n  border-bottom: 1px solid #3a3a3a;\n}\n.title {\n  display: flex;\n  align-items: center;\n  font-size: 18px;\n  color: #3ba776;\n}\n.button {\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0 10px;\n  transition: opacity 0.25s;\n  white-space: nowrap;\n  opacity: 0.8;\n  overflow: hidden;\n}\n.button:first-of-type {\n  margin-left: auto;\n}\n.button:not(.disabled):hover {\n  opacity: 1;\n  color: #3ba776;\n}\n.button.disabled {\n  opacity: 0.45;\n  cursor: not-allowed;\n}\n.button span {\n  display: none;\n}\n@media (min-width: 820px) {\n  .button span {\n    display: inline;\n  }\n}\n.material-icons {\n  font-size: 18px;\n  margin-right: 0;\n  color: inherit;\n}\n@media (min-width: 820px) {\n  .material-icons {\n    margin-right: 5px;\n  }\n}\n.search {\n  display: flex;\n  align-items: center;\n  flex: 1;\n}\n.search input {\n  flex: 1;\n  height: 100%;\n  background-color: transparent;\n  border: 0;\n  margin-left: 5px;\n  font-size: inherit;\n  color: inherit;\n  outline: 0;\n  transition: color 0.25s;\n}\n.search input:focus {\n  color: #3ba776;\n}\n.search input::placeholder {\n  opacity: 0.8;\n}\n.search input.invalid {\n  color: #4d0a09;\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.matchArrs[data-v-dad06f3c] {\n  width: 100%;\n  height: 100%;\n}\n.matchArrs .arr-content[data-v-dad06f3c] {\n  width: 100%;\n  background: #f3f3f3;\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.matchArrs .arr-content .arr-items[data-v-dad06f3c] {\n  font: 12px 'microsoft yahei';\n  line-height: 25px;\n  height: 25px;\n  color: #000;\n  padding: 0 0 0 20px;\n  cursor: pointer;\n}\n.matchArrs .arr-content .arr-items[data-v-dad06f3c]:nth-child(even) {\n  background: #fff;\n}\n.matchArrs .arr-content .arr-items[data-v-dad06f3c]:hover {\n  text-decoration: underline;\n}\n.matchArrs .arr-content .arr-items.active[data-v-dad06f3c] {\n  background: #7171f7;\n  color: #fff;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/components/src/components/matchFilter/match.styl","G:/luobata/lib/match-devtools/src/components/matchFilter/match.styl"],"names":[],"mappings":";AAAA;EACI,YAAA;EACA,aAAA;CCCH;ADAG;EACI,YAAA;EACA,oBAAA;EACA,iBAAA;EACA,UAAA;EACA,WAAA;CCEP;ADDO;EACI,6BAAA;EACA,kBAAA;EACA,aAAA;EACA,YAAA;EACA,oBAAA;EACA,gBAAA;CCGX;ADFO;EACI,iBAAA;CCIX;ADHO;EACI,2BAAA;CCKX;ADJO;EACI,oBAAA;EACA,YAAA;CCMX","file":"match.styl","sourcesContent":[".matchArrs\n    width: 100%;\n    height: 100%;\n    .arr-content\n        width: 100%;\n        background: #f3f3f3;\n        list-style: none;\n        margin: 0;\n        padding: 0;\n        .arr-items\n            font: 12px 'microsoft yahei';\n            line-height: 25px;\n            height: 25px;\n            color: #000;\n            padding: 0 0 0 20px;\n            cursor: pointer;\n        .arr-items:nth-child(even)\n            background: #fff;\n        .arr-items:hover\n            text-decoration: underline;\n        .arr-items.active\n            background: #7171f7;\n            color: #fff;\n",".matchArrs {\n  width: 100%;\n  height: 100%;\n}\n.matchArrs .arr-content {\n  width: 100%;\n  background: #f3f3f3;\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.matchArrs .arr-content .arr-items {\n  font: 12px 'microsoft yahei';\n  line-height: 25px;\n  height: 25px;\n  color: #000;\n  padding: 0 0 0 20px;\n  cursor: pointer;\n}\n.matchArrs .arr-content .arr-items:nth-child(even) {\n  background: #fff;\n}\n.matchArrs .arr-content .arr-items:hover {\n  text-decoration: underline;\n}\n.matchArrs .arr-content .arr-items.active {\n  background: #7171f7;\n  color: #fff;\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.data-wrapper {\n  display: flex;\n  flex-wrap: wrap;\n  padding-top: 20px;\n}\n.data-fields {\n  padding: 20px 20px 40px;\n}\n.data-el {\n  padding: 0px 10px;\n  flex: 1 0 33.33%;\n  font-size: 14px;\n}\n.data-el .data-type {\n  color: #486887;\n  padding-left: 20px;\n  margin-bottom: -10px;\n}\n.app.dark .data-el .data-type {\n  color: #7595b5;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/components/src/components/matchObj/matchObj.vue","G:/luobata/lib/match-devtools/src/components/matchObj/matchObj.vue"],"names":[],"mappings":";AA4CA;EACE,cAAA;EACA,gBAAA;EACA,kBAAA;CC3CD;AD6CD;EACE,wBAAA;CC3CD;AD6CD;EACE,kBAAA;EACA,iBAAA;EACA,gBAAA;CC3CD;AD6CC;EACE,eAAA;EACA,mBAAA;EACA,qBAAA;CC3CH;AD6CG;EACE,eAAA;CC3CL","file":"matchObj.vue","sourcesContent":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.data-wrapper\n  display flex\n  flex-wrap wrap\n  padding-top 20px\n\n.data-fields\n  padding 20px 20px 40px\n\n.data-el\n  padding 0px 10px\n  flex 1 0 33.33%\n  font-size 14px\n\n  .data-type\n    color #486887\n    padding-left 20px\n    margin-bottom -10px\n\n    .app.dark &\n      color lighten(#486887, 30%)\n",".data-wrapper {\n  display: flex;\n  flex-wrap: wrap;\n  padding-top: 20px;\n}\n.data-fields {\n  padding: 20px 20px 40px;\n}\n.data-el {\n  padding: 0px 10px;\n  flex: 1 0 33.33%;\n  font-size: 14px;\n}\n.data-el .data-type {\n  color: #486887;\n  padding-left: 20px;\n  margin-bottom: -10px;\n}\n.app.dark .data-el .data-type {\n  color: #7595b5;\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.data-field[data-v-ecaaf5a8] {\n  user-select: text;\n  font-size: 12px;\n  font-family: Menlo, Consolas, monospace;\n  cursor: default;\n}\n.self[data-v-ecaaf5a8] {\n  height: 20px;\n  line-height: 20px;\n  position: relative;\n  white-space: nowrap;\n  padding-left: 14px;\n}\n.self span[data-v-ecaaf5a8],\n.self div[data-v-ecaaf5a8] {\n  display: inline-block;\n  vertical-align: middle;\n}\n.self .arrow[data-v-ecaaf5a8] {\n  position: absolute;\n  top: 7px;\n  left: 0px;\n  transition: transform 0.1s ease;\n}\n.self .arrow.rotated[data-v-ecaaf5a8] {\n  transform: rotate(90deg);\n}\n.self .key[data-v-ecaaf5a8] {\n  color: #881391;\n}\n.self .colon[data-v-ecaaf5a8] {\n  margin-right: 0.5em;\n  position: relative;\n}\n.self .value[data-v-ecaaf5a8] {\n  color: #444;\n}\n.self .value.string[data-v-ecaaf5a8],\n.self .value.native[data-v-ecaaf5a8] {\n  color: #c41a16;\n}\n.self .value.null[data-v-ecaaf5a8] {\n  color: #999;\n}\n.self .value.literal[data-v-ecaaf5a8] {\n  color: #03c;\n}\n.self .type[data-v-ecaaf5a8] {\n  color: #fff;\n  padding: 3px 6px;\n  font-size: 10px;\n  line-height: 10px;\n  height: 16px;\n  border-radius: 3px;\n  margin: 2px 6px;\n  position: relative;\n  background-color: #eee;\n}\n.self .type.prop[data-v-ecaaf5a8] {\n  background-color: #96afdd;\n}\n.self .type.computed[data-v-ecaaf5a8] {\n  background-color: #af90d5;\n}\n.self .type.vuex-getter[data-v-ecaaf5a8] {\n  background-color: #5dd5d5;\n}\n.self .type.firebase-binding[data-v-ecaaf5a8] {\n  background-color: #fc0;\n}\n.self .type.observable[data-v-ecaaf5a8] {\n  background-color: #f99;\n}\n.self .meta[data-v-ecaaf5a8] {\n  display: none;\n  position: absolute;\n  z-index: 999;\n  font-size: 11px;\n  color: #444;\n  top: 0;\n  left: calc(100% + 5px);\n  width: 150px;\n  border: 1px solid #e3e3e3;\n  border-radius: 3px;\n  padding: 8px 12px;\n  background-color: #fff;\n  line-height: 16px;\n  box-shadow: 0 2px 12px rgba(0,0,0,0.1);\n}\n.self .meta .key[data-v-ecaaf5a8] {\n  width: 65px;\n}\n.self .meta-field[data-v-ecaaf5a8] {\n  display: block;\n}\n.self[data-v-ecaaf5a8]:hover {\n  cursor: pointer;\n}\n.self:hover .meta[data-v-ecaaf5a8] {\n  display: block;\n}\n.app.dark .self .key[data-v-ecaaf5a8] {\n  color: #e36eec;\n}\n.app.dark .self .value[data-v-ecaaf5a8] {\n  color: #bdc6cf;\n}\n.app.dark .self .value.string[data-v-ecaaf5a8],\n.app.dark .self .value.native[data-v-ecaaf5a8] {\n  color: #e33e3a;\n}\n.app.dark .self .value.null[data-v-ecaaf5a8] {\n  color: #999;\n}\n.app.dark .self .value.literal[data-v-ecaaf5a8] {\n  color: #997fff;\n}\n.app.dark .self .type[data-v-ecaaf5a8] {\n  color: #242424;\n}\n.app.dark .self .type .meta[data-v-ecaaf5a8] {\n  border: 1px solid #3a3a3a;\n  background-color: #242424;\n}\n.more[data-v-ecaaf5a8] {\n  cursor: pointer;\n  display: inline-block;\n  border-radius: 4px;\n  padding: 0 4px 4px;\n}\n.more[data-v-ecaaf5a8]:hover {\n  background-color: #eee;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/components/src/components/matchObj/dataField.vue","G:/luobata/lib/match-devtools/src/components/matchObj/dataField.vue"],"names":[],"mappings":";AAyJA;EACE,kBAAA;EACA,gBAAA;EACA,wCAAA;EACA,gBAAA;CCxJD;AD0JD;EACE,aAAA;EACA,kBAAA;EACA,mBAAA;EACA,oBAAA;EACA,mBAAA;CCxJD;ADyJC;;EACE,sBAAA;EACA,uBAAA;CCtJH;ADuJC;EACE,mBAAA;EACA,SAAA;EACA,UAAA;EACA,gCAAA;CCrJH;ADsJG;EACE,yBAAA;CCpJL;ADqJC;EACE,eAAA;CCnJH;ADoJC;EACE,oBAAA;EACA,mBAAA;CClJH;ADmJC;EACE,YAAA;CCjJH;ADkJG;;EACE,eAAA;CC/IL;ADgJG;EACE,YAAA;CC9IL;AD+IG;EACE,YAAA;CC7IL;AD+IC;EACE,YAAA;EACA,iBAAA;EACA,gBAAA;EACA,kBAAA;EACA,aAAA;EACA,mBAAA;EACA,gBAAA;EACA,mBAAA;EACA,uBAAA;CC7IH;AD8IG;EACE,0BAAA;CC5IL;AD6IG;EACE,0BAAA;CC3IL;AD4IG;EACE,0BAAA;CC1IL;AD2IG;EACE,uBAAA;CCzIL;AD0IG;EACE,uBAAA;CCxIL;AD0IC;EACE,cAAA;EACA,mBAAA;EACA,aAAA;EACA,gBAAA;EACA,YAAA;EACA,OAAA;EACA,uBAAA;EACA,aAAA;EACA,0BAAA;EACA,mBAAA;EACA,kBAAA;EACA,uBAAA;EACA,kBAAA;EACA,uCAAA;CCxIH;ADyIG;EACE,YAAA;CCvIL;ADwIC;EACE,eAAA;CCtIH;ADuIC;EACE,gBAAA;CCrIH;ADsIG;EACE,eAAA;CCpIL;ADuIG;EACE,eAAA;CCrIL;ADsIG;EACE,eAAA;CCpIL;ADqIK;;EACE,eAAA;CClIP;ADmIK;EACE,YAAA;CCjIP;ADkIK;EACE,eAAA;CChIP;ADiIG;EACE,eAAA;CC/HL;ADgIK;EACE,0BAAA;EACA,0BAAA;CC9HP;ADiID;EACE,gBAAA;EACA,sBAAA;EACA,mBAAA;EACA,mBAAA;CC/HD;ADgIC;EACE,uBAAA;CC9HH","file":"dataField.vue","sourcesContent":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@import \"../../variables\"\n\n.data-field\n  user-select text\n  font-size 12px\n  font-family Menlo, Consolas, monospace\n  cursor default\n\n.self\n  height 20px\n  line-height 20px\n  position relative\n  white-space nowrap\n  padding-left 14px\n  span, div\n    display inline-block\n    vertical-align middle\n  .arrow\n    position absolute\n    top 7px\n    left 0px\n    transition transform .1s ease\n    &.rotated\n      transform rotate(90deg)\n  .key\n    color #881391\n  .colon\n    margin-right .5em\n    position relative\n  .value\n    color #444\n    &.string, &.native\n      color #c41a16\n    &.null\n      color #999\n    &.literal\n      color #0033cc\n\n  .type\n    color $background-color\n    padding 3px 6px\n    font-size 10px\n    line-height 10px\n    height 16px\n    border-radius 3px\n    margin 2px 6px\n    position relative\n    background-color #eee\n    &.prop\n      background-color #96afdd\n    &.computed\n      background-color #af90d5\n    &.vuex-getter\n      background-color #5dd5d5\n    &.firebase-binding\n      background-color #ffcc00\n    &.observable\n      background-color #ff9999\n\n  .meta\n    display none\n    position absolute\n    z-index 999\n    font-size 11px\n    color #444\n    top 0\n    left calc(100% + 5px)\n    width 150px\n    border 1px solid #e3e3e3\n    border-radius 3px\n    padding 8px 12px\n    background-color $background-color\n    line-height 16px\n    box-shadow 0 2px 12px rgba(0,0,0,.1)\n    .key\n      width 65px\n  .meta-field\n    display block\n  &:hover\n    cursor pointer\n    .meta\n      display block\n\n  .app.dark &\n    .key\n      color: #e36eec\n    .value\n      color #bdc6cf\n      &.string, &.native\n        color #e33e3a\n      &.null\n        color #999\n      &.literal\n        color #997fff\n    .type\n      color: #242424\n      .meta\n        border 1px solid $dark-border-color\n        background-color $dark-background-color\n\n\n.more\n  cursor pointer\n  display inline-block\n  border-radius 4px\n  padding 0 4px 4px\n  &:hover\n    background-color #eee\n",".data-field {\n  user-select: text;\n  font-size: 12px;\n  font-family: Menlo, Consolas, monospace;\n  cursor: default;\n}\n.self {\n  height: 20px;\n  line-height: 20px;\n  position: relative;\n  white-space: nowrap;\n  padding-left: 14px;\n}\n.self span,\n.self div {\n  display: inline-block;\n  vertical-align: middle;\n}\n.self .arrow {\n  position: absolute;\n  top: 7px;\n  left: 0px;\n  transition: transform 0.1s ease;\n}\n.self .arrow.rotated {\n  transform: rotate(90deg);\n}\n.self .key {\n  color: #881391;\n}\n.self .colon {\n  margin-right: 0.5em;\n  position: relative;\n}\n.self .value {\n  color: #444;\n}\n.self .value.string,\n.self .value.native {\n  color: #c41a16;\n}\n.self .value.null {\n  color: #999;\n}\n.self .value.literal {\n  color: #03c;\n}\n.self .type {\n  color: #fff;\n  padding: 3px 6px;\n  font-size: 10px;\n  line-height: 10px;\n  height: 16px;\n  border-radius: 3px;\n  margin: 2px 6px;\n  position: relative;\n  background-color: #eee;\n}\n.self .type.prop {\n  background-color: #96afdd;\n}\n.self .type.computed {\n  background-color: #af90d5;\n}\n.self .type.vuex-getter {\n  background-color: #5dd5d5;\n}\n.self .type.firebase-binding {\n  background-color: #fc0;\n}\n.self .type.observable {\n  background-color: #f99;\n}\n.self .meta {\n  display: none;\n  position: absolute;\n  z-index: 999;\n  font-size: 11px;\n  color: #444;\n  top: 0;\n  left: calc(100% + 5px);\n  width: 150px;\n  border: 1px solid #e3e3e3;\n  border-radius: 3px;\n  padding: 8px 12px;\n  background-color: #fff;\n  line-height: 16px;\n  box-shadow: 0 2px 12px rgba(0,0,0,0.1);\n}\n.self .meta .key {\n  width: 65px;\n}\n.self .meta-field {\n  display: block;\n}\n.self:hover {\n  cursor: pointer;\n}\n.self:hover .meta {\n  display: block;\n}\n.app.dark .self .key {\n  color: #e36eec;\n}\n.app.dark .self .value {\n  color: #bdc6cf;\n}\n.app.dark .self .value.string,\n.app.dark .self .value.native {\n  color: #e33e3a;\n}\n.app.dark .self .value.null {\n  color: #999;\n}\n.app.dark .self .value.literal {\n  color: #997fff;\n}\n.app.dark .self .type {\n  color: #242424;\n}\n.app.dark .self .type .meta {\n  border: 1px solid #3a3a3a;\n  background-color: #242424;\n}\n.more {\n  cursor: pointer;\n  display: inline-block;\n  border-radius: 4px;\n  padding: 0 4px 4px;\n}\n.more:hover {\n  background-color: #eee;\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 31 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff2;base64,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"

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff2;base64,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"

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(48)
  __webpack_require__(49)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(17),
  /* template */
  __webpack_require__(41),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-3499c881",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\App.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] App.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3499c881", Component.options)
  } else {
    hotAPI.reload("data-v-3499c881", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(20),
  /* template */
  __webpack_require__(43),
  /* styles */
  null,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\matchContent\\matchContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] matchContent.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-82d266b4", Component.options)
  } else {
    hotAPI.reload("data-v-82d266b4", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(51)
}
var Component = __webpack_require__(1)(
  /* script */
  null,
  /* template */
  __webpack_require__(44),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-a8720af8",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\matchFilter\\actionTab.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] actionTab.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-a8720af8", Component.options)
  } else {
    hotAPI.reload("data-v-a8720af8", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(52)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(21),
  /* template */
  __webpack_require__(45),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-dad06f3c",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\matchFilter\\matchFilter.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] matchFilter.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-dad06f3c", Component.options)
  } else {
    hotAPI.reload("data-v-dad06f3c", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(54)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(18),
  /* template */
  __webpack_require__(47),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-ecaaf5a8",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\matchObj\\dataField.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] dataField.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-ecaaf5a8", Component.options)
  } else {
    hotAPI.reload("data-v-ecaaf5a8", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(53)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(22),
  /* template */
  __webpack_require__(46),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\matchObj\\matchObj.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] matchObj.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-e1cca234", Component.options)
  } else {
    hotAPI.reload("data-v-e1cca234", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(50)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(19),
  /* template */
  __webpack_require__(42),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-3d0b1c2c",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\splitPane\\splitPane.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] splitPane.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3d0b1c2c", Component.options)
  } else {
    hotAPI.reload("data-v-3d0b1c2c", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    class: {
      app: true, dark: _vm.isDark
    },
    attrs: {
      "id": "app"
    }
  }, [_c('div', {
    staticClass: "header"
  }, [_c('span', {
    staticClass: "message-container"
  }, [_c('transition', {
    attrs: {
      "name": "slide-up"
    }
  }, [_c('span', {
    key: _vm.message,
    staticClass: "message"
  }, [_vm._v(_vm._s(_vm.message))])])], 1), _c('a', {
    staticClass: "button components",
    class: {
      active: _vm.tab === 'match'
    },
    attrs: {
      "title": "Switch to Components"
    }
  }, [_c('i', {
    staticClass: "material-icons"
  }, [_vm._v("device_hub")]), _c('span', {
    staticClass: "pane-name"
  }, [_vm._v("Components")])]), _c('a', {
    staticClass: "button refresh",
    attrs: {
      "title": "Force Refresh"
    },
    on: {
      "click": _vm.refresh
    }
  }, [_c('i', {
    ref: "refresh",
    staticClass: "material-icons"
  }, [_vm._v("refresh")]), _c('span', {
    staticClass: "pane-name"
  }, [_vm._v("Refresh")])]), _c('span', {
    staticClass: "active-bar"
  })]), _c('match', {
    staticClass: "container"
  })], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-3499c881", module.exports)
  }
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "split-pane",
    class: {
      dragging: _vm.dragging
    },
    on: {
      "mousemove": _vm.dragMove,
      "mouseup": _vm.dragEnd,
      "mouseleave": _vm.dragEnd
    }
  }, [_c('div', {
    staticClass: "left",
    style: ({
      width: _vm.split + '%'
    })
  }, [_vm._t("left"), _c('div', {
    staticClass: "dragger",
    on: {
      "mousedown": function($event) {
        $event.preventDefault();
        _vm.dragStart($event)
      }
    }
  })], 2), _c('div', {
    staticClass: "right",
    style: ({
      width: (100 - _vm.split) + '%'
    })
  }, [_vm._t("right")], 2)])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-3d0b1c2c", module.exports)
  }
}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('split-pane', [_c('match-filter', {
    slot: "left"
  }), _c('match-obj', {
    attrs: {
      "stacks": _vm.matchArr
    },
    slot: "right"
  })], 1)], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-82d266b4", module.exports)
  }
}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "action-header"
  }, [_vm._t("default")], 2)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-a8720af8", module.exports)
  }
}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "match"
  }, [_c('action-header', {
    slot: "header"
  }, [_c('div', {
    staticClass: "search"
  }, [_c('i', {
    staticClass: "material-icons"
  }, [_vm._v("search")]), _c('input', {
    attrs: {
      "placeholder": "Filter components"
    },
    on: {
      "input": _vm.filterStacks
    }
  })])]), _c('div', {
    staticClass: "matchArrs"
  }, [_c('ul', {
    staticClass: "arr-content"
  }, _vm._l((_vm.matchArr), function(item) {
    return _c('li', {
      class: ['arr-items', {
        'active': _vm.activeItem === item
      }],
      on: {
        "click": function($event) {
          _vm.chooseItem(item)
        }
      }
    }, [_vm._v("\n                " + _vm._s(item.url) + "\n            ")])
  }))])], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-dad06f3c", module.exports)
  }
}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "data-wraper"
  }, _vm._l((_vm.stacks), function(item) {
    return _c('div', {
      staticClass: "data-fields"
    }, [_c('div', {
      staticClass: "data-type"
    }, [_vm._v("beforeParams")]), (Array.isArray(item.beforeParams)) ? _vm._l((item.beforeParams), function(field) {
      return _c('data-field', {
        key: field,
        attrs: {
          "field": field,
          "depth": 0
        }
      })
    }) : _vm._l((item.beforeParams), function(value, key) {
      return _c('data-field', {
        key: key,
        attrs: {
          "field": {
            value: value,
            key: key
          },
          "depth": 0
        }
      })
    }), _c('div', {
      staticClass: "data-type"
    }, [_vm._v("afterParams")]), (Array.isArray(item.afterParams)) ? _vm._l((item.afterParams), function(field) {
      return _c('data-field', {
        key: field,
        attrs: {
          "field": field,
          "depth": 0
        }
      })
    }) : _vm._l((item.afterParams), function(value, key) {
      return _c('data-field', {
        key: key,
        attrs: {
          "field": {
            value: value,
            key: key
          },
          "depth": 0
        }
      })
    })], 2)
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-e1cca234", module.exports)
  }
}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "data-field"
  }, [_c('div', {
    staticClass: "self",
    style: ({
      marginLeft: _vm.depth * 14 + 'px'
    }),
    on: {
      "click": _vm.toggle
    }
  }, [_c('span', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.isExpandableType),
      expression: "isExpandableType"
    }],
    staticClass: "arrow right",
    class: {
      rotated: _vm.expanded
    }
  }), _c('span', {
    staticClass: "key"
  }, [_vm._v(_vm._s(_vm.field.key))]), _c('span', {
    staticClass: "colon"
  }, [_vm._v(":"), (_vm.field.meta) ? _c('div', {
    staticClass: "meta"
  }, _vm._l((_vm.field.meta), function(val, key) {
    return _c('div', {
      staticClass: "meta-field"
    }, [_c('span', {
      staticClass: "key"
    }, [_vm._v(_vm._s(key))]), _c('span', {
      staticClass: "value"
    }, [_vm._v(_vm._s(val))])])
  })) : _vm._e()]), _c('span', {
    staticClass: "value",
    class: _vm.valueType
  }, [_vm._v(_vm._s(_vm.formattedValue))])]), (_vm.expanded && _vm.isExpandableType) ? _c('div', {
    staticClass: "children"
  }, [_vm._l((_vm.limitedSubFields), function(subField) {
    return _c('data-field', {
      key: subField.key,
      attrs: {
        "field": subField,
        "depth": _vm.depth + 1
      }
    })
  }), (_vm.formattedSubFields.length > _vm.limit) ? _c('span', {
    staticClass: "more",
    style: ({
      marginLeft: (_vm.depth + 1) * 14 + 10 + 'px'
    }),
    on: {
      "click": function($event) {
        _vm.limit += 10
      }
    }
  }, [_vm._v("\n      ...\n    ")]) : _vm._e()], 2) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-ecaaf5a8", module.exports)
  }
}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(24);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("dbac6168", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3499c881\",\"scoped\":false,\"hasInlineConfig\":false}!../node_modules/stylus-loader/index.js!./global.styl", function() {
     var newContent = require("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3499c881\",\"scoped\":false,\"hasInlineConfig\":false}!../node_modules/stylus-loader/index.js!./global.styl");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(25);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("519ef131", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3499c881\",\"scoped\":true,\"hasInlineConfig\":false}!../node_modules/stylus-loader/index.js!../node_modules/vue-loader/lib/selector.js?type=styles&index=1!./App.vue", function() {
     var newContent = require("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3499c881\",\"scoped\":true,\"hasInlineConfig\":false}!../node_modules/stylus-loader/index.js!../node_modules/vue-loader/lib/selector.js?type=styles&index=1!./App.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(26);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("3deabcb0", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3d0b1c2c\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./splitPane.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3d0b1c2c\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./splitPane.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(27);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("49b8c93a", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-a8720af8\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./actionTab.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-a8720af8\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./actionTab.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(28);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("75437019", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-dad06f3c\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!./match.styl", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-dad06f3c\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!./match.styl");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(29);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("0e98de01", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-e1cca234\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./matchObj.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-e1cca234\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./matchObj.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(30);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("30049f50", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-ecaaf5a8\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dataField.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-ecaaf5a8\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dataField.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 55 */
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Store */
/* unused harmony export mapState */
/* unused harmony export mapMutations */
/* unused harmony export mapGetters */
/* unused harmony export mapActions */
/**
 * vuex v2.3.0
 * (c) 2017 Evan You
 * @license MIT
 */
var applyMixin = function (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;
    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook =
  typeof window !== 'undefined' &&
  window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */


/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: {} };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors$1 );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  var this$1 = this;

  // register root module (Vuex.Store options)
  this.root = new Module(rawRootModule, false);

  // register all nested modules
  if (rawRootModule.modules) {
    forEachValue(rawRootModule.modules, function (rawModule, key) {
      this$1.register([key], rawModule, false);
    });
  }
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update(this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  var parent = this.get(path.slice(0, -1));
  var newModule = new Module(rawModule, runtime);
  parent.addChild(path[path.length - 1], newModule);

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) { return }

  parent.removeChild(key);
};

function update (targetModule, newModule) {
  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        console.warn(
          "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
          'manual reload is needed'
        );
        return
      }
      update(targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
  assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");

  var state = options.state; if ( state === void 0 ) state = {};
  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); });
};

var prototypeAccessors = { state: {} };

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors.state.set = function (v) {
  assert(false, "Use store.replaceState() to explicit replace store state.");
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    console.error(("[vuex] unknown mutation type: " + type));
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });

  if (options && options.silent) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var entry = this._actions[type];
  if (!entry) {
    console.error(("[vuex] unknown action type: " + type));
    return
  }
  return entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload)
};

Store.prototype.subscribe = function subscribe (fn) {
  var subs = this._subscribers;
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  assert(typeof getter === 'function', "store.watch only accepts a function.");
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule) {
  if (typeof path === 'string') { path = [path]; }
  assert(Array.isArray(path), "module path must be a string or an Array.");
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path));
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }
  assert(Array.isArray(path), "module path must be a string or an Array.");
  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors );

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () { return fn(store); };
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var namespacedType = namespace + key;
    registerAction(store, namespacedType, action, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (!store._actions[type]) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (!store._mutations[type]) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) { return }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function () { return store.getters[type]; },
      enumerable: true
    });
  });

  return gettersProxy
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler(local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload, cb) {
    var res = handler({
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    console.error(("[vuex] duplicate getter key: " + type));
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.length
    ? path.reduce(function (state, key) { return state[key]; }, state)
    : state
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  assert(typeof type === 'string', ("Expects string as the type, but found " + (typeof type) + "."));

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue) {
    console.error(
      '[vuex] already installed. Vue.use(Vuex) should be called only once.'
    );
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

// auto install in dist mode
if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {
        return
      }
      return this.$store.commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (!(val in this.$store.getters)) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {
        return
      }
      return this.$store.dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

function normalizeMap (map) {
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (!module) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

var index_esm = {
  Store: Store,
  install: install,
  version: '2.3.0',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions
};

/* harmony default export */ __webpack_exports__["a"] = (index_esm);


/***/ }),
/* 57 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgM2NjOTA1NWQ1ZjE3NDU2YjYzMDMiLCJ3ZWJwYWNrOi8vLy4uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzIiwid2VicGFjazovLy8uLy4uL3NyYy9icmlkZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vfi92dWUvZGlzdC92dWUucnVudGltZS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vLi4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9kZXZ0b29scy5qcyIsIndlYnBhY2s6Ly8vLi8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai91dGlsLmpzIiwid2VicGFjazovLy8uLy4uL3NyYy9zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi8uLi9zcmMvQXBwLnZ1ZSIsIndlYnBhY2s6Ly8vLi8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlIiwid2VicGFjazovLy8uLy4uL3NyYy9jb21wb25lbnRzL3NwbGl0UGFuZS9zcGxpdFBhbmUudnVlIiwid2VicGFjazovLy8uLy4uL3NyYy9jb21wb25lbnRzL21hdGNoQ29udGVudC9tYXRjaENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvbWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovbWF0Y2hPYmouanMiLCJ3ZWJwYWNrOi8vLy4uL34vY2lyY3VsYXItanNvbi1lczYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nbG9iYWwuc3R5bCIsIndlYnBhY2s6Ly8vLi4vc3JjL0FwcC52dWU/NzhhZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc3BsaXRQYW5lL3NwbGl0UGFuZS52dWU/OTI4ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvYWN0aW9uVGFiLnZ1ZT8zZjYwIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaEZpbHRlci9tYXRjaC5zdHlsIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9tYXRjaE9iai52dWU/NDQ2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovZGF0YUZpZWxkLnZ1ZT8xOWJiIiwid2VicGFjazovLy8uLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vc3JjL2Fzc2V0cy9NYXRlcmlhbEljb25zLVJlZ3VsYXIud29mZjIiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9hc3NldHMvUm9ib3RvLVJlZ3VsYXIud29mZjIiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9BcHAudnVlIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaENvbnRlbnQvbWF0Y2hDb250ZW50LnZ1ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvYWN0aW9uVGFiLnZ1ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvbWF0Y2hGaWx0ZXIudnVlIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9tYXRjaE9iai52dWUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb21wb25lbnRzL3NwbGl0UGFuZS9zcGxpdFBhbmUudnVlIiwid2VicGFjazovLy8uLi9zcmMvQXBwLnZ1ZT8wMDMxIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9zcGxpdFBhbmUvc3BsaXRQYW5lLnZ1ZT9hMzYxIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaENvbnRlbnQvbWF0Y2hDb250ZW50LnZ1ZT81NTVlIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaEZpbHRlci9hY3Rpb25UYWIudnVlP2E4OTQiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb21wb25lbnRzL21hdGNoRmlsdGVyL21hdGNoRmlsdGVyLnZ1ZT8wZDE1Iiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9tYXRjaE9iai52dWU/MjJiYiIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovZGF0YUZpZWxkLnZ1ZT8zZmMzIiwid2VicGFjazovLy8uLi9zcmMvZ2xvYmFsLnN0eWw/OGZjMCIsIndlYnBhY2s6Ly8vLi4vc3JjL0FwcC52dWU/OTJhOCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc3BsaXRQYW5lL3NwbGl0UGFuZS52dWU/YTZiZCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvYWN0aW9uVGFiLnZ1ZT80YTBlIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaEZpbHRlci9tYXRjaC5zdHlsPzk3MzQiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL21hdGNoT2JqLnZ1ZT80YjY4Iiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlPzI2M2MiLCJ3ZWJwYWNrOi8vLy4uL34vdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzIiwid2VicGFjazovLy8uLi9+L3Z1ZXgvZGlzdC92dWV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQixpQkFB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SztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsVUFBVTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDLEdBQUc7QUFDSDtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdUZBQXVGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsK0JBQStCO0FBQy9GLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0EsNkNBQTZDLDRDQUE0Qzs7QUFFekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDJEQUEyRCwyQkFBMkIsRUFBRTtBQUN4RixLQUFLO0FBQ0w7QUFDQSwyREFBMkQsNEJBQTRCLEVBQUU7QUFDekY7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw2Q0FBNkMsRUFBRTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCLEVBQUU7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0JBQStCLEVBQUU7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUNBQXVDLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qyx1Q0FBdUMsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsMEJBQTBCLEVBQUU7QUFDdEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixFQUFFO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxD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QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7QUN2Q0EsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7QUN6REEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxxQkFBcUIsRUFBRSxFQUFFO0FBQ2pFLDJDQUEyQyxVQUFVLDBCQUEwQixFQUFFLEVBQUU7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUU7Ozs7Ozs7QUNoeUJqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QyIsImZpbGUiOiJkZXZ0b29scy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDNjYzkwNTVkNWYxNzQ1NmI2MzAzIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICBpZiAoIWZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xuKi9cblxudmFyIGhhc0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5pZiAodHlwZW9mIERFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBERUJVRykge1xuICBpZiAoIWhhc0RvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2dWUtc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuICcgK1xuICAgIFwiVXNlIHsgdGFyZ2V0OiAnbm9kZScgfSBpbiB5b3VyIFdlYnBhY2sgY29uZmlnIHRvIGluZGljYXRlIGEgc2VydmVyLXJlbmRlcmluZyBlbnZpcm9ubWVudC5cIlxuICApIH1cbn1cblxudmFyIGxpc3RUb1N0eWxlcyA9IHJlcXVpcmUoJy4vbGlzdFRvU3R5bGVzJylcblxuLypcbnR5cGUgU3R5bGVPYmplY3QgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XG59XG5cbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xuICBjc3M6IHN0cmluZztcbiAgbWVkaWE6IHN0cmluZztcbiAgc291cmNlTWFwOiA/c3RyaW5nXG59XG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7LypcbiAgW2lkOiBudW1iZXJdOiB7XG4gICAgaWQ6IG51bWJlcixcbiAgICByZWZzOiBudW1iZXIsXG4gICAgcGFydHM6IEFycmF5PChvYmo/OiBTdHlsZU9iamVjdFBhcnQpID0+IHZvaWQ+XG4gIH1cbiovfVxuXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXG52YXIgc2luZ2xldG9uRWxlbWVudCA9IG51bGxcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMFxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxudmFyIGlzT2xkSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKCkge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLXZ1ZS1zc3ItaWR+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJpZGdlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICBjb25zdHJ1Y3RvciAod2FsbCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgLy8gU2V0dGluZyBgdGhpc2AgdG8gYHNlbGZgIGhlcmUgdG8gZml4IGFuIGVycm9yIGluIHRoZSBTYWZhcmkgYnVpbGQ6XHJcbiAgICAvLyBSZWZlcmVuY2VFcnJvcjogQ2Fubm90IGFjY2VzcyB1bmluaXRpYWxpemVkIHZhcmlhYmxlLlxyXG4gICAgLy8gVGhlIGVycm9yIG1pZ2h0IGJlIHJlbGF0ZWQgdG8gdGhlIHdlYmtpdCBidWcgaGVyZTpcclxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzE1NDNcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgc2VsZi5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xyXG4gICAgc2VsZi53YWxsID0gd2FsbDtcclxuICAgIHdhbGwubGlzdGVuKG1lc3NhZ2UgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgc2VsZi5lbWl0KG1lc3NhZ2UpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5lbWl0KG1lc3NhZ2UuZXZlbnQsIG1lc3NhZ2UucGF5bG9hZClcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZW5kIGFuIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAgICovXHJcblxyXG4gIHNlbmQgKGV2ZW50LCBwYXlsb2FkKSB7XHJcbiAgICAgIHRoaXMud2FsbC5zZW5kKHtcclxuICAgICAgICAgIGV2ZW50LFxyXG4gICAgICAgICAgcGF5bG9hZFxyXG4gICAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBMb2cgYSBtZXNzYWdlIHRvIHRoZSBkZXZ0b29scyBiYWNrZ3JvdW5kIHBhZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxyXG4gICAqL1xyXG5cclxuICBsb2cgKG1lc3NhZ2UpIHtcclxuICAgICAgdGhpcy5zZW5kKCdsb2cnLCBtZXNzYWdlKVxyXG4gIH07XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLy4uL3NyYy9icmlkZ2UuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi40LjJcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3QsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cblxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobnVsbCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmaXggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAqL1xudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuLmNhbGwodGhpcywgcGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMpIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSBpbmplY3RbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyArXG4gICAgICAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpICtcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgXCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuICAgICAgXCJwcm9wZXJ0aWVzIGluIHRoZSBkYXRhIG9wdGlvbi5cIixcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICAobGFzdCkudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChjb21wLl9fZXNNb2R1bGUgJiYgY29tcC5kZWZhdWx0KSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgY2hpbGQuZGF0YSAmJiBjaGlsZC5kYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBjaGlsZC5kYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICAgIC8vIG5vIG5lZWQgZm9yIHRoZSByZWYgbm9kZXMgYWZ0ZXIgaW5pdGlhbCBwYXRjaFxuICAgICAgLy8gdGhpcyBwcmV2ZW50cyBrZWVwaW5nIGEgZGV0YWNoZWQgRE9NIHRyZWUgaW4gbWVtb3J5ICgjNTg1MSlcbiAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICB2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuc2VycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhICYmIHBhcmVudFZub2RlLmRhdGEuYXR0cnM7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3B0aW9uVHlwZSAodm0sIG5hbWUpIHtcbiAgdmFyIG9wdGlvbiA9IHZtLiRvcHRpb25zW25hbWVdO1xuICBpZiAoIWlzUGxhaW5PYmplY3Qob3B0aW9uKSkge1xuICAgIHdhcm4oXG4gICAgICAoXCJjb21wb25lbnQgb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgc2hvdWxkIGJlIGFuIG9iamVjdC5cIiksXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KSB8fCBjb25maWcuaXNSZXNlcnZlZEF0dHIoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ2NvbXB1dGVkJyk7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIgfHwgbm9vcCwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAodGFyZ2V0LCBrZXksIHVzZXJEZWYpIHtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSk7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnbWV0aG9kcycpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ3dhdGNoJyk7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAga2V5T3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goa2V5T3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc291cmNlKSB7XG4gICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IHt9LFxuICAgIGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlQ29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIGlzVW5kZWYoY2hpbGQubnMpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2RlcyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQob3VycywgZXhpc3RpbmcpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycywgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycywgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzLCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzLCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSB0b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgVnVlLnByb3RvdHlwZS5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtaW5pdDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGN1cnJlbnQsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBpZiAoY2FjaGVkTm9kZSAhPT0gY3VycmVudCkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5ICh2bm9kZSkge1xuICBpZiAodm5vZGUpIHtcbiAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG59XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZVtrZXldKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cblZ1ZSQzLnZlcnNpb24gPSAnMi40LjInO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxuXG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKHJlZiQkMS5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuZWxtID0gZWxtO1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgIWJhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cblxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cblxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5cblxuLyoqXG4gKiBwYXJzZSBkaXJlY3RpdmUgbW9kZWwgdG8gZG8gdGhlIGFycmF5IHVwZGF0ZSB0cmFuc2Zvcm0uIGFbaWR4XSA9IHZhbCA9PiAkJGEuc3BsaWNlKCQkaWR4LCAxLCB2YWwpXG4gKlxuICogZm9yIGxvb3AgcG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3RbaWR4XVxuICogLSB0ZXN0W3Rlc3QxW2lkeF1dXG4gKiAtIHRlc3RbXCJhXCJdW2lkeF1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtpZHhdXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2lkeF1dXG4gKlxuICovXG5cbnZhciBzdHI7XG52YXIgaW5kZXgkMTtcblxuLyogICovXG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgdmFyIGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKFxuICBlbG0sXG4gIHZub2RlLFxuICBjaGVja1ZhbFxuKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHxcbiAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrbGV5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICB2YXIgZiA9IGJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZSQzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUvZGlzdC92dWUucnVudGltZS5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IEFwcCBmcm9tICcuL0FwcC52dWUnO1xuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUnO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0RGV2VG9vbHMgKHNoZWxsKSB7XG4gICAgaW5pdFVpKHNoZWxsKTtcbn07XG5cbmZ1bmN0aW9uIGluaXRVaSAoc2hlbGwpIHtcbiAgICBsZXQgYXBwID0gbnVsbDtcblxuICAgIHNoZWxsLmNvbm5lY3QoYnJpZGdlID0+IHtcbiAgICAgICAgd2luZG93Lk1BVENIQlJJREdFID0gYnJpZGdlO1xuXG4gICAgICAgIGJyaWRnZS5vbignZmx1c2gnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgc3RvcmUuY29tbWl0KCdmbHVzaCcsIGRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBhcHAgPSBuZXcgVnVlKHtcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgcmVuZGVyIChoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGgoQXBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuJG1vdW50KCcjYXBwJyk7XG4gICAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vLi4vc3JjL2luZGV4LmpzIiwiaW1wb3J0IHsgaW5pdERldlRvb2xzIH0gZnJvbSAnU1JDL2luZGV4JztcbmltcG9ydCBCcmlkZ2UgZnJvbSAnU1JDL2JyaWRnZSc7XG5cbi8qXG4gKiBJbmplY3QgYmFja2VuZC5qcyBjb25uZWMgdG8gYmFja2dyb3VuZCwgYW5kIHNlbmQgYmFjayB0aGUgYnJpZGdlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuaW5pdERldlRvb2xzKHtcbiAgICBjb25uZWN0IChjYikge1xuICAgICAgICAvLyBpbmplY3QgYmFja2VuZC5qc1xuICAgICAgICBpbmplY3RTY3JpcHQoY2hyb21lLnJ1bnRpbWUuZ2V0VVJMKCdidWlsZC9iYWNrZW5kLmpzJyksICgpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gYmFja2dyb3VuZFxuICAgICAgICAgICAgY29uc3QgcG9ydCA9IGNocm9tZS5ydW50aW1lLmNvbm5lY3Qoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICcnICsgY2hyb21lLmRldnRvb2xzLmluc3BlY3RlZFdpbmRvdy50YWJJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBwb3J0Lm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgYnJpZGdlID0gbmV3IEJyaWRnZSh7XG4gICAgICAgICAgICAgICAgbGlzdGVuIChmbikge1xuICAgICAgICAgICAgICAgICAgICBwb3J0Lm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihmbik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZW5kIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNlbmQgYmFjayBicmlkZ2VcbiAgICAgICAgICAgIGNiKGJyaWRnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBpbmplY3RTY3JpcHQgKHNjcmlwdE5hbWUsIGNiKSB7XG4gIGNvbnN0IHNyYyA9IGBcbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LmNhbGwoZG9jdW1lbnQsICdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IFwiJHtzY3JpcHROYW1lfVwiO1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgYDtcblxuICBjaHJvbWUuZGV2dG9vbHMuaW5zcGVjdGVkV2luZG93LmV2YWwoc3JjLCBmdW5jdGlvbiAocmVzLCBlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgfVxuICAgICAgY2IoKTtcbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RldnRvb2xzLmpzIiwiaW1wb3J0IENpcmN1bGFySlNPTiBmcm9tICdjaXJjdWxhci1qc29uLWVzNidcblxuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdXG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH1cbn1cblxudmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV8vXSkoXFx3KS9nXG5leHBvcnQgY29uc3QgY2xhc3NpZnkgPSBjYWNoZWQoKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgdG9VcHBlcilcbn0pXG5cbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2dcbmV4cG9ydCBjb25zdCBjYW1lbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCB0b1VwcGVyKVxufSlcblxuZnVuY3Rpb24gdG9VcHBlciAoXywgYykge1xuICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbkRvYyAobm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZVxuICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG4gIHJldHVybiBkb2MgPT09IG5vZGUgfHxcbiAgICBkb2MgPT09IHBhcmVudCB8fFxuICAgICEhKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDEgJiYgKGRvYy5jb250YWlucyhwYXJlbnQpKSlcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkvcGFyc2UgZGF0YSB1c2luZyBDaXJjdWxhckpTT04uXG4gKi9cblxuZXhwb3J0IGNvbnN0IFVOREVGSU5FRCA9ICdfX3Z1ZV9kZXZ0b29sX3VuZGVmaW5lZF9fJ1xuZXhwb3J0IGNvbnN0IElORklOSVRZID0gJ19fdnVlX2RldnRvb2xfaW5maW5pdHlfXydcbmV4cG9ydCBjb25zdCBOQU4gPSAnX192dWVfZGV2dG9vbF9uYW5fXydcblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeSAoZGF0YSkge1xuICByZXR1cm4gQ2lyY3VsYXJKU09OLnN0cmluZ2lmeShkYXRhLCByZXBsYWNlcilcbn1cblxuZnVuY3Rpb24gcmVwbGFjZXIgKGtleSwgdmFsKSB7XG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBVTkRFRklORURcbiAgfSBlbHNlIGlmICh2YWwgPT09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIElORklOSVRZXG4gIH0gZWxzZSBpZiAoTnVtYmVyLmlzTmFOKHZhbCkpIHtcbiAgICByZXR1cm4gTkFOXG4gIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gc3BlY2lhbCBoYW5kbGluZyBvZiBuYXRpdmUgdHlwZVxuICAgIHJldHVybiBgW25hdGl2ZSBSZWdFeHAgJHt2YWwudG9TdHJpbmcoKX1dYFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzYW5pdGl6ZSh2YWwpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlIChkYXRhLCByZXZpdmUpIHtcbiAgcmV0dXJuIHJldml2ZVxuICAgID8gQ2lyY3VsYXJKU09OLnBhcnNlKGRhdGEsIHJldml2ZXIpXG4gICAgOiBDaXJjdWxhckpTT04ucGFyc2UoZGF0YSlcbn1cblxuZnVuY3Rpb24gcmV2aXZlciAoa2V5LCB2YWwpIHtcbiAgaWYgKHZhbCA9PT0gVU5ERUZJTkVEKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9IGVsc2UgaWYgKHZhbCA9PT0gSU5GSU5JVFkpIHtcbiAgICByZXR1cm4gSW5maW5pdHlcbiAgfSBlbHNlIGlmICh2YWwgPT09IE5BTikge1xuICAgIHJldHVybiBOYU5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsXG4gIH1cbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSBkYXRhIHRvIGJlIHBvc3RlZCB0byB0aGUgb3RoZXIgc2lkZS5cbiAqIFNpbmNlIHRoZSBtZXNzYWdlIHBvc3RlZCBpcyBzZW50IHdpdGggc3RydWN0dXJlZCBjbG9uZSxcbiAqIHdlIG5lZWQgdG8gZmlsdGVyIG91dCBhbnkgdHlwZXMgdGhhdCBtaWdodCBjYXVzZSBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZnVuY3Rpb24gc2FuaXRpemUgKGRhdGEpIHtcbiAgaWYgKFxuICAgICFpc1ByaW1pdGl2ZShkYXRhKSAmJlxuICAgICFBcnJheS5pc0FycmF5KGRhdGEpICYmXG4gICAgIWlzUGxhaW5PYmplY3QoZGF0YSlcbiAgKSB7XG4gICAgLy8gaGFuZGxlIHR5cGVzIHRoYXQgd2lsbCBwcm9iYWJseSBjYXVzZSBpc3N1ZXMgaW5cbiAgICAvLyB0aGUgc3RydWN0dXJlZCBjbG9uZVxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAoZGF0YSkge1xuICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZW9mIGRhdGFcbiAgcmV0dXJuIChcbiAgICB0eXBlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgdHlwZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaERlZXBJbk9iamVjdCAob2JqLCBzZWFyY2hUZXJtKSB7XG4gIHZhciBtYXRjaCA9IGZhbHNlXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldXG4gICAgaWYgKGNvbXBhcmUoa2V5LCBzZWFyY2hUZXJtKSB8fCBjb21wYXJlKHZhbHVlLCBzZWFyY2hUZXJtKSkge1xuICAgICAgbWF0Y2ggPSB0cnVlXG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIG1hdGNoID0gc2VhcmNoRGVlcEluT2JqZWN0KHZhbHVlLCBzZWFyY2hUZXJtKVxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaFxufVxuXG5mdW5jdGlvbiBjb21wYXJlIChtaXhlZFZhbHVlLCBzdHJpbmdWYWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShtaXhlZFZhbHVlKSAmJiBzZWFyY2hJbkFycmF5KG1peGVkVmFsdWUsIHN0cmluZ1ZhbHVlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoKCcnICsgbWl4ZWRWYWx1ZSkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cmluZ1ZhbHVlLnRvTG93ZXJDYXNlKCkpICE9PSAtMSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHNlYXJjaEluQXJyYXkgKGFyciwgc2VhcmNoVGVybSkge1xuICBsZXQgZm91bmQgPSBmYWxzZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgoJycgKyBhcnJbaV0pLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2hUZXJtKSAhPT0gLTEpIHtcbiAgICAgIGZvdW5kID0gdHJ1ZVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0QnlLZXkgKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZSAmJiBzdGF0ZS5zbGljZSgpLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5rZXkgPCBiLmtleSkgcmV0dXJuIC0xXG4gICAgaWYgKGEua2V5ID4gYi5rZXkpIHJldHVybiAxXG4gICAgcmV0dXJuIDBcbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLy4uL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL3V0aWwuanMiLCIvKipcbiAqIEBkZXNjcmlwdGlvbiB2dWV4IOWtmOWCqOWFqOWxgOeahG1hdGNo5pWw5o2uXG4gKi9cbmltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBWdWV4IGZyb20gJ3Z1ZXgnO1xuXG5WdWUudXNlKFZ1ZXgpO1xuXG5jb25zdCBzdG9yZSA9IG5ldyBWdWV4LlN0b3JlKHtcbiAgICBzdGF0ZToge1xuICAgICAgICBtYXRjaGVzOiBbXG4gICAgICAgIF0sXG4gICAgICAgIHNob3dNYXRjaDogW1xuICAgICAgICBdXG4gICAgfSxcbiAgICBtdXRhdGlvbnM6IHtcbiAgICAgICAgZmx1c2ggKHN0YXRlLCBkYXRhKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYXRjaGVzID0gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hvb3NlSXRlbSAoc3RhdGUsIGl0ZW0pIHtcbiAgICAgICAgICAgIHN0YXRlLnNob3dNYXRjaCA9IFtpdGVtXTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdG9yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLy4uL3NyYy9zdG9yZS5qcyIsIi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmltcG9ydCBtYXRjaENvbnRlbnQgZnJvbSAnQ09NUE9ORU5UUy9tYXRjaENvbnRlbnQvbWF0Y2hDb250ZW50LnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAnYXBwJyxcbiAgICBkYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdtYXRjaCcsXG4gICAgICAgICAgICB0YWI6ICdtYXRjaCcsXG4gICAgICAgICAgICBpc0Rhcms6IHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YgY2hyb21lLmRldnRvb2xzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY2hyb21lLmRldnRvb2xzLnBhbmVscy50aGVtZU5hbWUgPT09ICdkYXJrJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIG1hdGNoOiBtYXRjaENvbnRlbnQgXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHJlZnJlc2ggKCkge1xuICAgICAgICAgICAgY29uc3QgcmVmcmVzaEljb24gPSB0aGlzLiRyZWZzLnJlZnJlc2g7XG4gICAgICAgICAgICByZWZyZXNoSWNvbi5zdHlsZS5hbmltYXRpb24gPSAnbm9uZSc7XG4gICAgICAgICAgICAvLyBmbHVzaOaMiemSruaXi+i9rFxuICAgICAgICAgICAgTUFUQ0hCUklER0Uub25jZSgnZmx1c2gnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVmcmVzaEljb24uc3R5bGUuYW5pbWF0aW9uID0gJ3JvdGF0ZSAxcydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgTUFUQ0hCUklER0Uuc2VuZCgnZmx1c2gnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQWN0aXZlQmFyICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUJ1dHRvbiA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5idXR0b24uYWN0aXZlJyk7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVCYXIgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuYWN0aXZlLWJhcicpO1xuICAgICAgICAgICAgYWN0aXZlQmFyLnN0eWxlLmxlZnQgPSBhY3RpdmVCdXR0b24ub2Zmc2V0TGVmdCArICdweCc7XG4gICAgICAgICAgICBhY3RpdmVCYXIuc3R5bGUud2lkdGggPSBhY3RpdmVCdXR0b24ub2Zmc2V0V2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVCYXIoKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMudXBkYXRlQWN0aXZlQmFyKTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZCAoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnVwZGF0ZUFjdGl2ZUJhcik7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vLi4vc3JjL0FwcC52dWUiLCIvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmltcG9ydCB7XG4gIFVOREVGSU5FRCxcbiAgSU5GSU5JVFksXG4gIE5BTixcbiAgaXNQbGFpbk9iamVjdCxcbiAgc29ydEJ5S2V5XG59IGZyb20gJy4vdXRpbCdcblxuY29uc3QgcmF3VHlwZVJFID0gL15cXFtvYmplY3QgKFxcdyspXSQvXG5jb25zdCBzcGVjaWFsVHlwZVJFID0gL15cXFtuYXRpdmUgXFx3KyAoLiopXFxdJC9cblxuZnVuY3Rpb24gc3ViRmllbGRDb3VudCAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aFxuICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHJldHVybiAwXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnRGF0YUZpZWxkJyxcbiAgcHJvcHM6IHtcbiAgICBmaWVsZDogT2JqZWN0LFxuICAgIGRlcHRoOiBOdW1iZXJcbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbWl0OiBBcnJheS5pc0FycmF5KHRoaXMuZmllbGQudmFsdWUpID8gMTAgOiBJbmZpbml0eSxcbiAgICAgIGV4cGFuZGVkOiB0aGlzLmRlcHRoID09PSAwICYmIHRoaXMuZmllbGQua2V5ICE9PSAnJHJvdXRlJyAmJiAoc3ViRmllbGRDb3VudCh0aGlzLmZpZWxkLnZhbHVlKSA8IDUpXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHZhbHVlVHlwZSAoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZmllbGQudmFsdWVcbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWVcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdHlwZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgIHR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgIHZhbHVlID09PSBJTkZJTklUWSB8fFxuICAgICAgICB2YWx1ZSA9PT0gTkFOXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuICdsaXRlcmFsJ1xuICAgICAgfSBlbHNlIGlmIChzcGVjaWFsVHlwZVJFLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnbmF0aXZlJ1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiAhcmF3VHlwZVJFLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnc3RyaW5nJ1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNFeHBhbmRhYmxlVHlwZSAoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZmllbGQudmFsdWVcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKVxuICAgIH0sXG4gICAgZm9ybWF0dGVkVmFsdWUgKCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmZpZWxkLnZhbHVlXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJ1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gTkFOKSB7XG4gICAgICAgIHJldHVybiAnTmFOJ1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkpIHtcbiAgICAgICAgcmV0dXJuICdJbmZpbml0eSdcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdBcnJheVsnICsgdmFsdWUubGVuZ3RoICsgJ10nXG4gICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnT2JqZWN0JyArIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID8gJycgOiAnIChlbXB0eSknKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlVHlwZSA9PT0gJ25hdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpYWxUeXBlUkUuZXhlYyh2YWx1ZSlbMV1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdHlwZU1hdGNoID0gdmFsdWUubWF0Y2gocmF3VHlwZVJFKVxuICAgICAgICBpZiAodHlwZU1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVNYXRjaFsxXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9XG4gICAgfSxcbiAgICBmb3JtYXR0ZWRTdWJGaWVsZHMgKCkge1xuICAgICAgbGV0IHZhbHVlID0gdGhpcy5maWVsZC52YWx1ZVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKChpdGVtLCBpKSA9PiAoe1xuICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICB9KSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWx1ZSA9IHNvcnRCeUtleShPYmplY3Qua2V5cyh2YWx1ZSkubWFwKGtleSA9PiAoe1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVba2V5XVxuICAgICAgICB9KSkpXG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIGxpbWl0ZWRTdWJGaWVsZHMgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkU3ViRmllbGRzLnNsaWNlKDAsIHRoaXMubGltaXQpXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdG9nZ2xlICgpIHtcbiAgICAgIGlmICh0aGlzLmlzRXhwYW5kYWJsZVR5cGUpIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkXG4gICAgICB9XG4gICAgfSxcbiAgICBoeXBoZW46IHYgPT4gdi5yZXBsYWNlKC9cXHMvZywgJy0nKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlIiwiLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0YSAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwbGl0OiA1MCxcbiAgICAgICAgICBkcmFnZ2luZzogZmFsc2VcbiAgICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgICAgZHJhZ1N0YXJ0IChlKSB7XG4gICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zdGFydFggPSBlLnBhZ2VYO1xuICAgICAgICAgIHRoaXMuc3RhcnRTcGxpdCA9IHRoaXMuc3BsaXQ7XG4gICAgICB9LFxuICAgICAgZHJhZ01vdmUgKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICBjb25zdCBkeCA9IGUucGFnZVggLSB0aGlzLnN0YXJ0WDtcbiAgICAgICAgICAgICAgY29uc3QgdG90YWxXaWR0aCA9IHRoaXMuJGVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICB0aGlzLnNwbGl0ID0gdGhpcy5zdGFydFNwbGl0ICsgfn4oZHggLyB0b3RhbFdpZHRoICogMTAwKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZHJhZ0VuZCAoKSB7XG4gICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi8uLi9zcmMvY29tcG9uZW50cy9zcGxpdFBhbmUvc3BsaXRQYW5lLnZ1ZSIsImltcG9ydCBTcGxpdFBhbmUgZnJvbSAnLi4vc3BsaXRQYW5lL3NwbGl0UGFuZS52dWUnO1xuaW1wb3J0IG1hdGNoRmlsdGVyIGZyb20gJy4uL21hdGNoRmlsdGVyL21hdGNoRmlsdGVyLnZ1ZSc7XG5pbXBvcnQgbWF0Y2hPYmogZnJvbSAnQ09NUE9ORU5UUy9tYXRjaE9iai9tYXRjaE9iai52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgbWF0Y2hBcnIgKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLnN0YXRlLnNob3dNYXRjaDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBtYXRjaEZpbHRlcixcbiAgICAgICAgbWF0Y2hPYmosXG4gICAgICAgIFNwbGl0UGFuZVxuICAgIH0sXG4gICAgYmVmb3JlTW91bnQgKCkge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLm1hdGNoQXJyKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZmlsdGVyIChlKSB7XG4gICAgICAgICAgICBicmlkZ2Uuc2VuZCgnZmlsdGVyLWluc3RhbmNlcycsIGUudGFyZ2V0LnZhbHVlKVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLy4uL3NyYy9jb21wb25lbnRzL21hdGNoQ29udGVudC9tYXRjaENvbnRlbnQuanMiLCJpbXBvcnQgQWN0aW9uSGVhZGVyIGZyb20gJy4vYWN0aW9uVGFiLnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbHRlcktleTogJycsXG4gICAgICAgICAgICBhY3RpdmVJdGVtOiB7fVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBtYXRjaEFyciAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuc3RhdGUubWF0Y2hlcztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBBY3Rpb25IZWFkZXJcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZmlsdGVyU3RhY2tzIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcktleSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBjaG9vc2VJdGVtIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCdjaG9vc2VJdGVtJywgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvbWF0Y2guanMiLCJpbXBvcnQgRGF0YUZpZWxkIGZyb20gJy4vZGF0YUZpZWxkLnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczoge1xuICAgICAgICBzdGFja3M6IEFycmF5XG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIERhdGFGaWVsZFxuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9tYXRjaE9iai5qcyIsImZ1bmN0aW9uIGVuY29kZSAoZGF0YSwgcmVwbGFjZXIsIGxpc3QsIHNlZW4pIHtcbiAgdmFyIHN0b3JlZCwga2V5LCB2YWx1ZSwgaSwgbFxuICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5nZXQoZGF0YSlcbiAgaWYgKHNlZW5JbmRleCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNlZW5JbmRleFxuICB9XG4gIHZhciBpbmRleCA9IGxpc3QubGVuZ3RoXG4gIGlmIChpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgc3RvcmVkID0ge31cbiAgICBzZWVuLnNldChkYXRhLCBpbmRleClcbiAgICBsaXN0LnB1c2goc3RvcmVkKVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV1cbiAgICAgIHZhbHVlID0gZGF0YVtrZXldXG4gICAgICBpZiAocmVwbGFjZXIpIHtcbiAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKGRhdGEsIGtleSwgdmFsdWUpXG4gICAgICB9XG4gICAgICBzdG9yZWRba2V5XSA9IGVuY29kZSh2YWx1ZSwgcmVwbGFjZXIsIGxpc3QsIHNlZW4pXG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBzdG9yZWQgPSBbXVxuICAgIHNlZW4uc2V0KGRhdGEsIGluZGV4KVxuICAgIGxpc3QucHVzaChzdG9yZWQpXG4gICAgZm9yIChpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IGRhdGFbaV1cbiAgICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgIHZhbHVlID0gcmVwbGFjZXIuY2FsbChkYXRhLCBpLCB2YWx1ZSlcbiAgICAgIH1cbiAgICAgIHN0b3JlZFtpXSA9IGVuY29kZSh2YWx1ZSwgcmVwbGFjZXIsIGxpc3QsIHNlZW4pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGluZGV4ID0gbGlzdC5sZW5ndGhcbiAgICBsaXN0LnB1c2goZGF0YSlcbiAgfVxuICByZXR1cm4gaW5kZXhcbn1cblxuZnVuY3Rpb24gZGVjb2RlIChsaXN0LCByZXZpdmVyKSB7XG4gIHZhciBpID0gbGlzdC5sZW5ndGhcbiAgdmFyIGosIGssIGRhdGEsIGtleSwgdmFsdWVcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkYXRhID0gbGlzdFtpXVxuICAgIGlmIChpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gICAgICBmb3IgKGogPSAwLCBrID0ga2V5cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tqXVxuICAgICAgICB2YWx1ZSA9IGxpc3RbZGF0YVtrZXldXVxuICAgICAgICBpZiAocmV2aXZlcikgdmFsdWUgPSByZXZpdmVyLmNhbGwoZGF0YSwga2V5LCB2YWx1ZSlcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGZvciAoaiA9IDAsIGsgPSBkYXRhLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICB2YWx1ZSA9IGxpc3RbZGF0YVtqXV1cbiAgICAgICAgaWYgKHJldml2ZXIpIHZhbHVlID0gcmV2aXZlci5jYWxsKGRhdGEsIGosIHZhbHVlKVxuICAgICAgICBkYXRhW2pdID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkgKGRhdGEsIHJlcGxhY2VyLCBzcGFjZSkge1xuICB0cnkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICA6IEpTT04uc3RyaW5naWZ5KGRhdGEsIHJlcGxhY2VyLCBzcGFjZSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBleHBvcnRzLnN0cmluZ2lmeVN0cmljdChkYXRhLCByZXBsYWNlciwgc3BhY2UpXG4gIH1cbn1cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChkYXRhLCByZXZpdmVyKSB7XG4gIHZhciBoYXNDaXJjdWxhciA9IC9eXFxzLy50ZXN0KGRhdGEpXG4gIGlmICghaGFzQ2lyY3VsYXIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgPyBKU09OLnBhcnNlKGRhdGEpXG4gICAgICA6IEpTT04ucGFyc2UoZGF0YSwgcmV2aXZlcilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGlzdCA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICBkZWNvZGUobGlzdCwgcmV2aXZlcilcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG59XG5cbmV4cG9ydHMuc3RyaW5naWZ5U3RyaWN0ID0gZnVuY3Rpb24gKGRhdGEsIHJlcGxhY2VyLCBzcGFjZSkge1xuICB2YXIgbGlzdCA9IFtdXG4gIGVuY29kZShkYXRhLCByZXBsYWNlciwgbGlzdCwgbmV3IE1hcCgpKVxuICByZXR1cm4gc3BhY2VcbiAgICA/ICcgJyArIEpTT04uc3RyaW5naWZ5KGxpc3QsIG51bGwsIHNwYWNlKVxuICAgIDogJyAnICsgSlNPTi5zdHJpbmdpZnkobGlzdClcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY2lyY3VsYXItanNvbi1lczYvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5zbGlkZS11cC1lbnRlciB7XFxuICBvcGFjaXR5OiAwO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgNTAlKTtcXG59XFxuLnNsaWRlLXVwLWxlYXZlLXRvIHtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAtNTAlKTtcXG59XFxuLnNsaWRlLWRvd24tZW50ZXIsXFxuLnNsaWRlLWRvd24tbGVhdmUtdG8ge1xcbiAgb3BhY2l0eTogMDtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIC0yMHB4KTtcXG59XFxuQC1tb3ota2V5ZnJhbWVzIHJvdGF0ZSB7XFxuMCUge1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG59XFxuMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxufVxcbn1cXG5ALXdlYmtpdC1rZXlmcmFtZXMgcm90YXRlIHtcXG4wJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbn1cXG4xMDAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG59XFxufVxcbkAtby1rZXlmcmFtZXMgcm90YXRlIHtcXG4wJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbn1cXG4xMDAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG59XFxufVxcbkBrZXlmcmFtZXMgcm90YXRlIHtcXG4wJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbn1cXG4xMDAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG59XFxufVxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6ICdNYXRlcmlhbCBJY29ucyc7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgc3JjOiB1cmwoXCIgKyByZXF1aXJlKFwiLi9hc3NldHMvTWF0ZXJpYWxJY29ucy1SZWd1bGFyLndvZmYyXCIpICsgXCIpIGZvcm1hdCgnd29mZjInKTtcXG59XFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ1JvYm90byc7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgc3JjOiBsb2NhbCgnUm9ib3RvJyksIGxvY2FsKCdSb2JvdG8tUmVndWxhcicpLCB1cmwoXCIgKyByZXF1aXJlKFwiLi9hc3NldHMvUm9ib3RvLVJlZ3VsYXIud29mZjJcIikgKyBcIikgZm9ybWF0KCd3b2ZmMicpO1xcbn1cXG4ubWF0ZXJpYWwtaWNvbnMge1xcbiAgZm9udC1mYW1pbHk6ICdNYXRlcmlhbCBJY29ucyc7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC1zaXplOiAyMnB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgd2lkdGg6IDFlbTtcXG4gIGhlaWdodDogMWVtO1xcbiAgY29sb3I6ICM5OTk7XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgbGV0dGVyLXNwYWNpbmc6IG5vcm1hbDtcXG4gIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIGRpcmVjdGlvbjogbHRyO1xcbi8qIFN1cHBvcnQgZm9yIGFsbCBXZWJLaXQgYnJvd3NlcnMuICovXFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4vKiBTdXBwb3J0IGZvciBTYWZhcmkgYW5kIENocm9tZS4gKi9cXG4gIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XFxuLyogU3VwcG9ydCBmb3IgRmlyZWZveC4gKi9cXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XFxufVxcbi5tYXRlcmlhbC1pY29ucy5tZWRpdW0ge1xcbiAgdHJhbnNmb3JtOiBzY2FsZSgwLjkpO1xcbn1cXG4ubWF0ZXJpYWwtaWNvbnMuc21hbGwge1xcbiAgdHJhbnNmb3JtOiBzY2FsZSgwLjgpO1xcbn1cXG4udG9nZ2xlLXJlY29yZGluZyAubWF0ZXJpYWwtaWNvbnMge1xcbiAgY29sb3I6ICM5OTkgIWltcG9ydGFudDtcXG59XFxuLnRvZ2dsZS1yZWNvcmRpbmcgLm1hdGVyaWFsLWljb25zLmVuYWJsZWQge1xcbiAgY29sb3I6ICNmMDAgIWltcG9ydGFudDtcXG4gIHRleHQtc2hhZG93OiAwIDAgM3B4IHJnYmEoMjU1LDAsMCwwLjQpO1xcbn1cXG5odG1sLFxcbmJvZHkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGZvbnQtZmFtaWx5OiBSb2JvdG87XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBjb2xvcjogIzQ0NDtcXG59XFxuKiB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG4uYXJyb3cge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7XFxufVxcbi5hcnJvdy51cCB7XFxuICBib3JkZXItbGVmdDogNHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJpZ2h0OiA0cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItYm90dG9tOiA2cHggc29saWQgIzQ0NDtcXG59XFxuLmFycm93LmRvd24ge1xcbiAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1yaWdodDogNHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXRvcDogNnB4IHNvbGlkICM0NDQ7XFxufVxcbi5hcnJvdy5yaWdodCB7XFxuICBib3JkZXItdG9wOiA0cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItYm90dG9tOiA0cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItbGVmdDogNnB4IHNvbGlkICM0NDQ7XFxufVxcbi5hcnJvdy5sZWZ0IHtcXG4gIGJvcmRlci10b3A6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1ib3R0b206IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1yaWdodDogNnB4IHNvbGlkICM0NDQ7XFxufVxcbi5ub3RpY2Uge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB3aWR0aDogMTAwJTtcXG4gIGNvbG9yOiAjYWFhO1xcbn1cXG4ubm90aWNlIGRpdiB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBwYWRkaW5nOiAwLjVlbTtcXG4gIG1hcmdpbjogMCBhdXRvO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL3RyYW5zaXRpb25zLnN0eWxcIixcIkc6L2x1b2JhdGEvbGliL21hdGNoLWRldnRvb2xzL3NyYy9nbG9iYWwuc3R5bFwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBQUE7RUFDRSxXQUFBO0VBQ0EsNkJBQUE7Q0NDRDtBRENEO0VBQ0UsV0FBQTtFQUNBLDhCQUFBO0NDQ0Q7QURDRDs7RUFDRSxXQUFBO0VBQ0EsK0JBQUE7Q0NFRDtBREFVO0FBQ1Q7SUFDRSx3QkFBQTtDQ0VEO0FEREQ7SUFDRSwwQkFBQTtDQ0dEO0NBQ0Y7QURSVTtBQUNUO0lBQ0Usd0JBQUE7Q0NVRDtBRFREO0lBQ0UsMEJBQUE7Q0NXRDtDQUNGO0FEaEJVO0FBQ1Q7SUFDRSx3QkFBQTtDQ2tCRDtBRGpCRDtJQUNFLDBCQUFBO0NDbUJEO0NBQ0Y7QUR4QlU7QUFDVDtJQUNFLHdCQUFBO0NDMEJEO0FEekJEO0lBQ0UsMEJBQUE7Q0MyQkQ7Q0FDRjtBQXpDRDtFQUNFLDhCQUFBO0VBQ0EsbUJBQUE7RUFDQSxpQkFBQTtFQUNBLG1EQUFBO0NBMkNEO0FBekNEO0VBQ0Usc0JBQUE7RUFDQSxtQkFBQTtFQUNBLGlCQUFBO0VBQ0EsNkZBQUE7Q0EyQ0Q7QUF6Q0Q7RUFDRSw4QkFBQTtFQUNBLG9CQUFBO0VBQ0EsbUJBQUE7RUFDQSxnQkFBQTtFQUNBLHNCQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7RUFDQSxZQUFBO0VBQ0EsZUFBQTtFQUNBLHFCQUFBO0VBQ0EsdUJBQUE7RUFDQSxrQkFBQTtFQUNBLG9CQUFBO0VBQ0EsZUFBQTtBQUNBLHNDQUFBO0VBQ0Esb0NBQUE7QUFDQSxvQ0FBQTtFQUNBLG1DQUFBO0FBQ0EsMEJBQUE7RUFDQSxtQ0FBQTtDQTJDRDtBQTFDQztFQUNFLHNCQUFBO0NBNENIO0FBM0NDO0VBQ0Usc0JBQUE7Q0E2Q0g7QUEzQ0Q7RUFDRSx1QkFBQTtDQTZDRDtBQTVDQztFQUNFLHVCQUFBO0VBQ0EsdUNBQUE7Q0E4Q0g7QUE1Q0Q7O0VBQ0UsVUFBQTtFQUNBLFdBQUE7RUFDQSxvQkFBQTtFQUNBLGdCQUFBO0VBQ0EsWUFBQTtDQStDRDtBQTdDRDtFQUNFLHVCQUFBO0NBK0NEO0FBM0NEO0VBQ0Usc0JBQUE7RUFDQSxTQUFBO0VBQ0EsVUFBQTtDQTZDRDtBQTVDQztFQUNFLG1DQUFBO0VBQ0Esb0NBQUE7RUFDQSw4QkFBQTtDQThDSDtBQTdDQztFQUNFLG1DQUFBO0VBQ0Esb0NBQUE7RUFDQSwyQkFBQTtDQStDSDtBQTlDQztFQUNFLGtDQUFBO0VBQ0EscUNBQUE7RUFDQSw0QkFBQTtDQWdESDtBQS9DQztFQUNFLGtDQUFBO0VBQ0EscUNBQUE7RUFDQSw2QkFBQTtDQWlESDtBQS9DRDtFQUNFLGNBQUE7RUFDQSxvQkFBQTtFQUNBLGFBQUE7RUFDQSxZQUFBO0VBQ0EsWUFBQTtDQWlERDtBQWhEQztFQUNFLG1CQUFBO0VBQ0EsZUFBQTtFQUNBLGVBQUE7Q0FrREhcIixcImZpbGVcIjpcImdsb2JhbC5zdHlsXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zbGlkZS11cC1lbnRlclxcclxcbiAgb3BhY2l0eSAwXFxyXFxuICB0cmFuc2Zvcm0gdHJhbnNsYXRlKDAsIDUwJSlcXHJcXG5cXHJcXG4uc2xpZGUtdXAtbGVhdmUtdG9cXHJcXG4gIG9wYWNpdHkgMFxcclxcbiAgdHJhbnNmb3JtIHRyYW5zbGF0ZSgwLCAtNTAlKVxcclxcblxcclxcbi5zbGlkZS1kb3duLWVudGVyLCAuc2xpZGUtZG93bi1sZWF2ZS10b1xcclxcbiAgb3BhY2l0eSAwXFxyXFxuICB0cmFuc2Zvcm0gdHJhbnNsYXRlKDAsIC0yMHB4KVxcclxcblxcclxcbkBrZXlmcmFtZXMgcm90YXRlXFxyXFxuICAwJVxcclxcbiAgICB0cmFuc2Zvcm0gcm90YXRlKDBkZWcpXFxyXFxuICAxMDAlXFxyXFxuICAgIHRyYW5zZm9ybSByb3RhdGUoMzYwZGVnKVxcclxcblwiLFwiQGltcG9ydCBcXFwiLi92YXJpYWJsZXNcXFwiXFxyXFxuQGltcG9ydCBcXFwiLi90cmFuc2l0aW9uc1xcXCJcXHJcXG5cXHJcXG5AZm9udC1mYWNlXFxyXFxuICBmb250LWZhbWlseSAnTWF0ZXJpYWwgSWNvbnMnXFxyXFxuICBmb250LXN0eWxlIG5vcm1hbFxcclxcbiAgZm9udC13ZWlnaHQgNDAwXFxyXFxuICBzcmMgdXJsKC4vYXNzZXRzL01hdGVyaWFsSWNvbnMtUmVndWxhci53b2ZmMikgZm9ybWF0KCd3b2ZmMicpXFxyXFxuXFxyXFxuQGZvbnQtZmFjZVxcclxcbiAgZm9udC1mYW1pbHkgJ1JvYm90bydcXHJcXG4gIGZvbnQtc3R5bGUgbm9ybWFsXFxyXFxuICBmb250LXdlaWdodCA0MDBcXHJcXG4gIHNyYyBsb2NhbCgnUm9ib3RvJyksIGxvY2FsKCdSb2JvdG8tUmVndWxhcicpLCB1cmwoLi9hc3NldHMvUm9ib3RvLVJlZ3VsYXIud29mZjIpIGZvcm1hdCgnd29mZjInKVxcclxcblxcclxcbi5tYXRlcmlhbC1pY29uc1xcclxcbiAgZm9udC1mYW1pbHkgJ01hdGVyaWFsIEljb25zJ1xcclxcbiAgZm9udC13ZWlnaHQgbm9ybWFsXFxyXFxuICBmb250LXN0eWxlIG5vcm1hbFxcclxcbiAgZm9udC1zaXplIDIycHhcXHJcXG4gIGRpc3BsYXkgaW5saW5lLWJsb2NrXFxyXFxuICB3aWR0aCAxZW1cXHJcXG4gIGhlaWdodCAxZW1cXHJcXG4gIGNvbG9yICM5OTlcXHJcXG4gIGxpbmUtaGVpZ2h0IDFcXHJcXG4gIHRleHQtdHJhbnNmb3JtIG5vbmVcXHJcXG4gIGxldHRlci1zcGFjaW5nIG5vcm1hbFxcclxcbiAgd29yZC13cmFwIG5vcm1hbFxcclxcbiAgd2hpdGUtc3BhY2Ugbm93cmFwXFxyXFxuICBkaXJlY3Rpb24gbHRyXFxyXFxuICAvKiBTdXBwb3J0IGZvciBhbGwgV2ViS2l0IGJyb3dzZXJzLiAqL1xcclxcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWRcXHJcXG4gIC8qIFN1cHBvcnQgZm9yIFNhZmFyaSBhbmQgQ2hyb21lLiAqL1xcclxcbiAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eVxcclxcbiAgLyogU3VwcG9ydCBmb3IgRmlyZWZveC4gKi9cXHJcXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGVcXHJcXG4gICYubWVkaXVtXFxyXFxuICAgIHRyYW5zZm9ybSBzY2FsZSgwLjkpXFxyXFxuICAmLnNtYWxsXFxyXFxuICAgIHRyYW5zZm9ybSBzY2FsZSgwLjgpXFxyXFxuXFxyXFxuLnRvZ2dsZS1yZWNvcmRpbmcgLm1hdGVyaWFsLWljb25zXFxyXFxuICBjb2xvciAjOTk5ICFpbXBvcnRhbnRcXHJcXG4gICYuZW5hYmxlZFxcclxcbiAgICBjb2xvciByZWQgIWltcG9ydGFudFxcclxcbiAgICB0ZXh0LXNoYWRvdyAwIDAgM3B4IHJnYmEoMjU1LCAwLCAwLCAuNClcXHJcXG5cXHJcXG5odG1sLCBib2R5XFxyXFxuICBtYXJnaW4gMFxcclxcbiAgcGFkZGluZyAwXFxyXFxuICBmb250LWZhbWlseSBSb2JvdG9cXHJcXG4gIGZvbnQtc2l6ZSAxNnB4XFxyXFxuICBjb2xvciAjNDQ0XFxyXFxuXFxyXFxuKlxcclxcbiAgYm94LXNpemluZyBib3JkZXItYm94XFxyXFxuXFxyXFxuJGFycm93LWNvbG9yID0gIzQ0NFxcclxcblxcclxcbi5hcnJvd1xcclxcbiAgZGlzcGxheSBpbmxpbmUtYmxvY2tcXHJcXG4gIHdpZHRoIDBcXHJcXG4gIGhlaWdodCAwXFxyXFxuICAmLnVwXFxyXFxuICAgIGJvcmRlci1sZWZ0IDRweCBzb2xpZCB0cmFuc3BhcmVudFxcclxcbiAgICBib3JkZXItcmlnaHQgNHB4IHNvbGlkIHRyYW5zcGFyZW50XFxyXFxuICAgIGJvcmRlci1ib3R0b20gNnB4IHNvbGlkICRhcnJvdy1jb2xvclxcclxcbiAgJi5kb3duXFxyXFxuICAgIGJvcmRlci1sZWZ0IDRweCBzb2xpZCB0cmFuc3BhcmVudFxcclxcbiAgICBib3JkZXItcmlnaHQgNHB4IHNvbGlkIHRyYW5zcGFyZW50XFxyXFxuICAgIGJvcmRlci10b3AgNnB4IHNvbGlkICRhcnJvdy1jb2xvclxcclxcbiAgJi5yaWdodFxcclxcbiAgICBib3JkZXItdG9wIDRweCBzb2xpZCB0cmFuc3BhcmVudFxcclxcbiAgICBib3JkZXItYm90dG9tIDRweCBzb2xpZCB0cmFuc3BhcmVudFxcclxcbiAgICBib3JkZXItbGVmdCA2cHggc29saWQgJGFycm93LWNvbG9yXFxyXFxuICAmLmxlZnRcXHJcXG4gICAgYm9yZGVyLXRvcCA0cHggc29saWQgdHJhbnNwYXJlbnRcXHJcXG4gICAgYm9yZGVyLWJvdHRvbSA0cHggc29saWQgdHJhbnNwYXJlbnRcXHJcXG4gICAgYm9yZGVyLXJpZ2h0IDZweCBzb2xpZCAkYXJyb3ctY29sb3JcXHJcXG5cXHJcXG4ubm90aWNlXFxyXFxuICBkaXNwbGF5IGZsZXhcXHJcXG4gIGFsaWduLWl0ZW1zIGNlbnRlclxcclxcbiAgaGVpZ2h0IDEwMCVcXHJcXG4gIHdpZHRoIDEwMCVcXHJcXG4gIGNvbG9yICNhYWFcXHJcXG4gIGRpdlxcclxcbiAgICB0ZXh0LWFsaWduIGNlbnRlclxcclxcbiAgICBwYWRkaW5nIDAuNWVtXFxyXFxuICAgIG1hcmdpbiAwIGF1dG9cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTM0OTljODgxXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3N0eWx1cy1sb2FkZXIhLi4vc3JjL2dsb2JhbC5zdHlsXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uYXBwW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuLmFwcCBoMVtkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIGNvbG9yOiAjNDJiOTgzO1xcbn1cXG4uYXBwLmRhcmtbZGF0YS12LTM0OTljODgxXSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjQyNDI0O1xcbn1cXG4uaGVhZGVyW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcXG4gIGJveC1zaGFkb3c6IDAgMCA4cHggcmdiYSgwLDAsMCwwLjE1KTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmFwcC5kYXJrIC5oZWFkZXJbZGF0YS12LTM0OTljODgxXSB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzNhM2EzYTtcXG59XFxuLm1lc3NhZ2UtY29udGFpbmVyW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgaGVpZ2h0OiAxZW07XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcbi5tZXNzYWdlW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgY29sb3I6ICMzYmE3NzY7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4uYnV0dG9uW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgY29sb3I6ICM4ODg7XFxuICB0cmFuc2l0aW9uOiBjb2xvciAwLjM1cyBlYXNlO1xcbn1cXG4uYXBwLmRhcmsgLmJ1dHRvbltkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyNDI0MjQ7XFxufVxcbi5idXR0b25bZGF0YS12LTM0OTljODgxXTpob3ZlciB7XFxuICBjb2xvcjogIzU1NTtcXG59XFxuLmJ1dHRvbi5hY3RpdmVbZGF0YS12LTM0OTljODgxXSB7XFxuICBjb2xvcjogIzNiYTc3NjtcXG59XFxuLmJ1dHRvbltkYXRhLXYtMzQ5OWM4ODFdOmZpcnN0LW9mLXR5cGUge1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxufVxcbi5idXR0b24gLm1hdGVyaWFsLWljb25zW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBjb2xvcjogaW5oZXJpdDtcXG59XFxuLmJ1dHRvbiAucGFuZS1uYW1lW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDgyMHB4KSB7XFxuLmJ1dHRvbltkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gICAgcGFkZGluZy1yaWdodDogMjBweDtcXG4gICAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcbn1cXG4uYnV0dG9uIC5wYW5lLW5hbWVbZGF0YS12LTM0OTljODgxXSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG59XFxuQG1lZGlhIChtaW4taGVpZ2h0OiAzMDBweCkge1xcbi5idXR0b25bZGF0YS12LTM0OTljODgxXSB7XFxuICAgIHBhZGRpbmctdG9wOiAyMHB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMjBweDtcXG59XFxufVxcbi5jb250YWluZXJbZGF0YS12LTM0OTljODgxXSB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZmxleDogMTtcXG59XFxuLmV2ZW50LWNvdW50W2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzNiYTc3NjtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgd2lkdGg6IDE4cHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBwYWRkaW5nLXRvcDogNHB4O1xcbiAgZm9udC1zaXplOiA5cHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMDtcXG4gIHRvcDogMTJweDtcXG59XFxuLmFwcC5kYXJrIC5ldmVudC1jb3VudFtkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyNDI0MjQ7XFxufVxcbi5hY3RpdmUtYmFyW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYm90dG9tOiAwO1xcbiAgd2lkdGg6IDBweDtcXG4gIGhlaWdodDogM3B4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzNiYTc3NjtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjMycyBjdWJpYy1iZXppZXIoMCwgMC45LCAwLjYsIDEpO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL0FwcC52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQTBFQTtFQUNFLFlBQUE7RUFDQSxhQUFBO0VBQ0Esa0JBQUE7RUFDQSx1QkFBQTtFQUNBLGNBQUE7RUFDQSx1QkFBQTtDQXpFRDtBQTBFQztFQUNFLGVBQUE7Q0F4RUg7QUF5RUM7RUFDRSwwQkFBQTtDQXZFSDtBQXdFRDtFQUNFLGNBQUE7RUFDQSxvQkFBQTtFQUNBLDhCQUFBO0VBQ0EscUNBQUE7RUFDQSxnQkFBQTtFQUNBLG1CQUFBO0NBdEVEO0FBdUVDO0VBQ0UsaUNBQUE7Q0FyRUg7QUFzRUQ7RUFDRSxZQUFBO0VBQ0EsZ0JBQUE7Q0FwRUQ7QUFxRUQ7RUFDRSxlQUFBO0VBQ0EsMEJBQUE7RUFDQSxtQkFBQTtDQW5FRDtBQW9FRDtFQUNFLGNBQUE7RUFDQSxjQUFBO0VBQ0Esb0JBQUE7RUFDQSxnQkFBQTtFQUNBLG1CQUFBO0VBQ0EsaUNBQUE7RUFDQSx1QkFBQTtFQUNBLFlBQUE7RUFDQSw2QkFBQTtDQWxFRDtBQW1FQztFQUNFLDBCQUFBO0NBakVIO0FBa0VDO0VBQ0UsWUFBQTtDQWhFSDtBQWlFQztFQUNFLGVBQUE7Q0EvREg7QUFnRUM7RUFDRSxrQkFBQTtDQTlESDtBQStEQztFQUNFLGdCQUFBO0VBQ0Esa0JBQUE7RUFDQSxlQUFBO0NBN0RIO0FBOERDO0VBQ0UsY0FBQTtDQTVESDtBQTZEeUI7QUFBQTtJQUN0QixvQkFBQTtJQUNBLG1CQUFBO0NBMUREO0FBMkRDO0lBQ0UsZUFBQTtDQXpESDtDQUNGO0FBeUQwQjtBQUFBO0lBQ3ZCLGtCQUFBO0lBQ0EscUJBQUE7Q0F0REQ7Q0FDRjtBQXNERDtFQUNFLGlCQUFBO0VBQ0EsUUFBQTtDQXBERDtBQXNERDtFQUNFLDBCQUFBO0VBQ0EsWUFBQTtFQUNBLG1CQUFBO0VBQ0EsWUFBQTtFQUNBLGFBQUE7RUFDQSxtQkFBQTtFQUNBLGlCQUFBO0VBQ0EsZUFBQTtFQUNBLG1CQUFBO0VBQ0EsU0FBQTtFQUNBLFVBQUE7Q0FwREQ7QUFxREM7RUFDRSwwQkFBQTtDQW5ESDtBQW9ERDtFQUNFLG1CQUFBO0VBQ0EsVUFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0EsMEJBQUE7RUFDQSxtREFBQTtDQWxERFwiLFwiZmlsZVwiOlwiQXBwLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuYXBwIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcbi5hcHAgaDEge1xcbiAgY29sb3I6ICM0MmI5ODM7XFxufVxcbi5hcHAuZGFyayB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjQyNDI0O1xcbn1cXG4uaGVhZGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxuICBib3gtc2hhZG93OiAwIDAgOHB4IHJnYmEoMCwwLDAsMC4xNSk7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5hcHAuZGFyayAuaGVhZGVyIHtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjM2EzYTNhO1xcbn1cXG4ubWVzc2FnZS1jb250YWluZXIge1xcbiAgaGVpZ2h0OiAxZW07XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcbi5tZXNzYWdlIHtcXG4gIGNvbG9yOiAjM2JhNzc2O1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLmJ1dHRvbiB7XFxuICBwYWRkaW5nOiAxMHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBjb2xvcjogIzg4ODtcXG4gIHRyYW5zaXRpb246IGNvbG9yIDAuMzVzIGVhc2U7XFxufVxcbi5hcHAuZGFyayAuYnV0dG9uIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyNDI0MjQ7XFxufVxcbi5idXR0b246aG92ZXIge1xcbiAgY29sb3I6ICM1NTU7XFxufVxcbi5idXR0b24uYWN0aXZlIHtcXG4gIGNvbG9yOiAjM2JhNzc2O1xcbn1cXG4uYnV0dG9uOmZpcnN0LW9mLXR5cGUge1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxufVxcbi5idXR0b24gLm1hdGVyaWFsLWljb25zIHtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcbi5idXR0b24gLnBhbmUtbmFtZSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5AbWVkaWEgKG1pbi13aWR0aDogODIwcHgpIHtcXG4gIC5idXR0b24ge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAyMHB4O1xcbiAgICBwYWRkaW5nLWxlZnQ6IDIwcHg7XFxuICB9XFxuICAuYnV0dG9uIC5wYW5lLW5hbWUge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gIH1cXG59XFxuQG1lZGlhIChtaW4taGVpZ2h0OiAzMDBweCkge1xcbiAgLmJ1dHRvbiB7XFxuICAgIHBhZGRpbmctdG9wOiAyMHB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMjBweDtcXG4gIH1cXG59XFxuLmNvbnRhaW5lciB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZmxleDogMTtcXG59XFxuLmV2ZW50LWNvdW50IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMzYmE3NzY7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIHdpZHRoOiAxOHB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgcGFkZGluZy10b3A6IDRweDtcXG4gIGZvbnQtc2l6ZTogOXB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IDEycHg7XFxufVxcbi5hcHAuZGFyayAuZXZlbnQtY291bnQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzI0MjQyNDtcXG59XFxuLmFjdGl2ZS1iYXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYm90dG9tOiAwO1xcbiAgd2lkdGg6IDBweDtcXG4gIGhlaWdodDogM3B4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzNiYTc3NjtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjMycyBjdWJpYy1iZXppZXIoMCwgMC45LCAwLjYsIDEpO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTM0OTljODgxXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc3R5bHVzLWxvYWRlciEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTEhLi4vc3JjL0FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5zcGxpdC1wYW5lW2RhdGEtdi0zZDBiMWMyY10ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuLnNwbGl0LXBhbmUuZHJhZ2dpbmdbZGF0YS12LTNkMGIxYzJjXSB7XFxuICBjdXJzb3I6IGV3LXJlc2l6ZTtcXG59XFxuLmxlZnRbZGF0YS12LTNkMGIxYzJjXSxcXG4ucmlnaHRbZGF0YS12LTNkMGIxYzJjXSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5sZWZ0W2RhdGEtdi0zZDBiMWMyY10ge1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2RkZDtcXG59XFxuLmFwcC5kYXJrIC5sZWZ0W2RhdGEtdi0zZDBiMWMyY10ge1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgIzNhM2EzYTtcXG59XFxuLmRyYWdnZXJbZGF0YS12LTNkMGIxYzJjXSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiA5OTtcXG4gIHRvcDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIHJpZ2h0OiAtNXB4O1xcbiAgd2lkdGg6IDEwcHg7XFxuICBjdXJzb3I6IGV3LXJlc2l6ZTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkc6L2x1b2JhdGEvbGliL21hdGNoLWRldnRvb2xzL3NyYy9jb21wb25lbnRzL3NyYy9jb21wb25lbnRzL3NwbGl0UGFuZS9zcGxpdFBhbmUudnVlXCIsXCJHOi9sdW9iYXRhL2xpYi9tYXRjaC1kZXZ0b29scy9zcmMvY29tcG9uZW50cy9zcGxpdFBhbmUvc3BsaXRQYW5lLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBZ0RBO0VBQ0UsY0FBQTtFQUNBLGFBQUE7Q0MvQ0Q7QURnREM7RUFDRSxrQkFBQTtDQzlDSDtBRGdERDs7RUFDRSxtQkFBQTtDQzdDRDtBRCtDRDtFQUNFLDZCQUFBO0NDN0NEO0FEOENDO0VBQ0UsZ0NBQUE7Q0M1Q0g7QUQ4Q0Q7RUFDRSxtQkFBQTtFQUNBLFlBQUE7RUFDQSxPQUFBO0VBQ0EsVUFBQTtFQUNBLFlBQUE7RUFDQSxZQUFBO0VBQ0Esa0JBQUE7Q0M1Q0RcIixcImZpbGVcIjpcInNwbGl0UGFuZS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuQGltcG9ydCBcXFwiLi4vLi4vdmFyaWFibGVzXFxcIlxcblxcbi5zcGxpdC1wYW5lXFxuICBkaXNwbGF5IGZsZXhcXG4gIGhlaWdodCAxMDAlXFxuICAmLmRyYWdnaW5nXFxuICAgIGN1cnNvciBldy1yZXNpemVcXG5cXG4ubGVmdCwgLnJpZ2h0XFxuICBwb3NpdGlvbiByZWxhdGl2ZVxcblxcbi5sZWZ0XFxuICBib3JkZXItcmlnaHQgMXB4IHNvbGlkICRib3JkZXItY29sb3JcXG4gIC5hcHAuZGFyayAmXFxuICAgIGJvcmRlci1yaWdodCAxcHggc29saWQgJGRhcmstYm9yZGVyLWNvbG9yXFxuXFxuLmRyYWdnZXJcXG4gIHBvc2l0aW9uIGFic29sdXRlXFxuICB6LWluZGV4IDk5XFxuICB0b3AgMFxcbiAgYm90dG9tIDBcXG4gIHJpZ2h0IC01cHhcXG4gIHdpZHRoIDEwcHhcXG4gIGN1cnNvciBldy1yZXNpemVcXG5cIixcIi5zcGxpdC1wYW5lIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcbi5zcGxpdC1wYW5lLmRyYWdnaW5nIHtcXG4gIGN1cnNvcjogZXctcmVzaXplO1xcbn1cXG4ubGVmdCxcXG4ucmlnaHQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4ubGVmdCB7XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjZGRkO1xcbn1cXG4uYXBwLmRhcmsgLmxlZnQge1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgIzNhM2EzYTtcXG59XFxuLmRyYWdnZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogOTk7XFxuICB0b3A6IDA7XFxuICBib3R0b206IDA7XFxuICByaWdodDogLTVweDtcXG4gIHdpZHRoOiAxMHB4O1xcbiAgY3Vyc29yOiBldy1yZXNpemU7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtM2QwYjFjMmNcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zdHlsdXMtbG9hZGVyIS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9zcGxpdFBhbmUvc3BsaXRQYW5lLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmFjdGlvbi1oZWFkZXJbZGF0YS12LWE4NzIwYWY4XSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxuICBwYWRkaW5nOiAwIDEwcHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcXG4gIGNvbG9yOiAjNjY2O1xcbiAgaGVpZ2h0OiAzNXB4O1xcbn1cXG5AbWVkaWEgKG1pbi1oZWlnaHQ6IDMwMHB4KSB7XFxuLmFjdGlvbi1oZWFkZXJbZGF0YS12LWE4NzIwYWY4XSB7XFxuICAgIGhlaWdodDogNTBweDtcXG59XFxufVxcbi5hcHAuZGFyayAuYWN0aW9uLWhlYWRlcltkYXRhLXYtYTg3MjBhZjhdIHtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjM2EzYTNhO1xcbn1cXG4udGl0bGVbZGF0YS12LWE4NzIwYWY4XSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMThweDtcXG4gIGNvbG9yOiAjM2JhNzc2O1xcbn1cXG4uYnV0dG9uW2RhdGEtdi1hODcyMGFmOF0ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDAgMTBweDtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXM7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgb3BhY2l0eTogMC44O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuLmJ1dHRvbltkYXRhLXYtYTg3MjBhZjhdOmZpcnN0LW9mLXR5cGUge1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxufVxcbi5idXR0b25bZGF0YS12LWE4NzIwYWY4XTpub3QoLmRpc2FibGVkKTpob3ZlciB7XFxuICBvcGFjaXR5OiAxO1xcbiAgY29sb3I6ICMzYmE3NzY7XFxufVxcbi5idXR0b24uZGlzYWJsZWRbZGF0YS12LWE4NzIwYWY4XSB7XFxuICBvcGFjaXR5OiAwLjQ1O1xcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG59XFxuLmJ1dHRvbiBzcGFuW2RhdGEtdi1hODcyMGFmOF0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDgyMHB4KSB7XFxuLmJ1dHRvbiBzcGFuW2RhdGEtdi1hODcyMGFmOF0ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmU7XFxufVxcbn1cXG4ubWF0ZXJpYWwtaWNvbnNbZGF0YS12LWE4NzIwYWY4XSB7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxuICBjb2xvcjogaW5oZXJpdDtcXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDgyMHB4KSB7XFxuLm1hdGVyaWFsLWljb25zW2RhdGEtdi1hODcyMGFmOF0ge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDVweDtcXG59XFxufVxcbi5zZWFyY2hbZGF0YS12LWE4NzIwYWY4XSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGZsZXg6IDE7XFxufVxcbi5zZWFyY2ggaW5wdXRbZGF0YS12LWE4NzIwYWY4XSB7XFxuICBmbGV4OiAxO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXI6IDA7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBvdXRsaW5lOiAwO1xcbiAgdHJhbnNpdGlvbjogY29sb3IgMC4yNXM7XFxufVxcbi5zZWFyY2ggaW5wdXRbZGF0YS12LWE4NzIwYWY4XTpmb2N1cyB7XFxuICBjb2xvcjogIzNiYTc3NjtcXG59XFxuLnNlYXJjaCBpbnB1dFtkYXRhLXYtYTg3MjBhZjhdOjpwbGFjZWhvbGRlciB7XFxuICBvcGFjaXR5OiAwLjg7XFxufVxcbi5zZWFyY2ggaW5wdXQuaW52YWxpZFtkYXRhLXYtYTg3MjBhZjhdIHtcXG4gIGNvbG9yOiAjNGQwYTA5O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL2NvbXBvbmVudHMvc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvYWN0aW9uVGFiLnZ1ZVwiLFwiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvYWN0aW9uVGFiLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBU0E7RUFDRSxjQUFBO0VBQ0EscUJBQUE7RUFDQSxnQkFBQTtFQUNBLGdCQUFBO0VBQ0EsOEJBQUE7RUFDQSxZQUFBO0VBQ0EsYUFBQTtDQ1JEO0FEUzBCO0FBQUE7SUFDdkIsYUFBQTtDQ05EO0NBQ0Y7QURNQztFQUNFLGlDQUFBO0NDSkg7QURNRDtFQUNFLGNBQUE7RUFDQSxvQkFBQTtFQUNBLGdCQUFBO0VBQ0EsZUFBQTtDQ0pEO0FETUQ7RUFDRSxnQkFBQTtFQUNBLGNBQUE7RUFDQSxvQkFBQTtFQUNBLHdCQUFBO0VBQ0EsZ0JBQUE7RUFDQSwwQkFBQTtFQUNBLG9CQUFBO0VBQ0EsYUFBQTtFQUNBLGlCQUFBO0NDSkQ7QURNQztFQUNFLGtCQUFBO0NDSkg7QURNQztFQUNFLFdBQUE7RUFDQSxlQUFBO0NDSkg7QURNQztFQUNFLGNBQUE7RUFDQSxvQkFBQTtDQ0pIO0FETUM7RUFDRSxjQUFBO0NDSkg7QURLMkI7QUFBQTtJQUN0QixnQkFBQTtDQ0ZIO0NBQ0Y7QURHRDtFQUNFLGdCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxlQUFBO0NDREQ7QURFeUI7QUFBQTtJQUN0QixrQkFBQTtDQ0NEO0NBQ0Y7QURBRDtFQUNFLGNBQUE7RUFDQSxvQkFBQTtFQUNBLFFBQUE7Q0NFRDtBRERDO0VBQ0UsUUFBQTtFQUNBLGFBQUE7RUFDQSw4QkFBQTtFQUNBLFVBQUE7RUFDQSxpQkFBQTtFQUNBLG1CQUFBO0VBQ0EsZUFBQTtFQUNBLFdBQUE7RUFDQSx3QkFBQTtDQ0dIO0FERkc7RUFDRSxlQUFBO0NDSUw7QURGRztFQUNFLGFBQUE7Q0NJTDtBREZHO0VBQ0UsZUFBQTtDQ0lMXCIsXCJmaWxlXCI6XCJhY3Rpb25UYWIudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIlxcblxcblxcblxcblxcblxcblxcbkBpbXBvcnQgXFxcIi4uLy4uL3ZhcmlhYmxlc1xcXCJcXG5cXG4uYWN0aW9uLWhlYWRlclxcbiAgZGlzcGxheSBmbGV4XFxuICBhbGlnbi1pdGVtcyBzdHJldGNoXFxuICBwYWRkaW5nIDAgMTBweFxcbiAgZm9udC1zaXplIDEycHhcXG4gIGJvcmRlci1ib3R0b20gMXB4IHNvbGlkICRib3JkZXItY29sb3JcXG4gIGNvbG9yICM2NjZcXG4gIGhlaWdodCAzNXB4XFxuICBAbWVkaWEgKG1pbi1oZWlnaHQ6ICR0YWxsKVxcbiAgICBoZWlnaHQgNTBweFxcbiAgLmFwcC5kYXJrICZcXG4gICAgYm9yZGVyLWJvdHRvbSAxcHggc29saWQgJGRhcmstYm9yZGVyLWNvbG9yXFxuXFxuLnRpdGxlXFxuICBkaXNwbGF5IGZsZXhcXG4gIGFsaWduLWl0ZW1zIGNlbnRlclxcbiAgZm9udC1zaXplIDE4cHhcXG4gIGNvbG9yICRjb21wb25lbnQtY29sb3JcXG5cXG4uYnV0dG9uXFxuICBjdXJzb3IgcG9pbnRlclxcbiAgZGlzcGxheSBmbGV4XFxuICBhbGlnbi1pdGVtcyBjZW50ZXJcXG4gIGp1c3RpZnktY29udGVudCBjZW50ZXJcXG4gIHBhZGRpbmcgMCAxMHB4XFxuICB0cmFuc2l0aW9uIG9wYWNpdHkgMC4yNXNcXG4gIHdoaXRlLXNwYWNlIG5vd3JhcFxcbiAgb3BhY2l0eSAwLjhcXG4gIG92ZXJmbG93IGhpZGRlblxcblxcbiAgJjpmaXJzdC1vZi10eXBlXFxuICAgIG1hcmdpbi1sZWZ0IGF1dG9cXG5cXG4gICY6bm90KC5kaXNhYmxlZCk6aG92ZXJcXG4gICAgb3BhY2l0eSAxXFxuICAgIGNvbG9yICRhY3RpdmUtY29sb3JcXG5cXG4gICYuZGlzYWJsZWRcXG4gICAgb3BhY2l0eSAwLjQ1XFxuICAgIGN1cnNvciBub3QtYWxsb3dlZFxcblxcbiAgc3BhblxcbiAgICBkaXNwbGF5IG5vbmVcXG4gICAgQG1lZGlhIChtaW4td2lkdGg6ICR3aWRlKVxcbiAgICAgIGRpc3BsYXkgaW5saW5lXFxuXFxuLm1hdGVyaWFsLWljb25zXFxuICBmb250LXNpemUgMThweFxcbiAgbWFyZ2luLXJpZ2h0IDBcXG4gIGNvbG9yIGluaGVyaXRcXG4gIEBtZWRpYSAobWluLXdpZHRoOiAkd2lkZSlcXG4gICAgbWFyZ2luLXJpZ2h0IDVweFxcblxcbi5zZWFyY2hcXG4gIGRpc3BsYXkgZmxleFxcbiAgYWxpZ24taXRlbXMgY2VudGVyXFxuICBmbGV4IDFcXG4gIGlucHV0XFxuICAgIGZsZXggMVxcbiAgICBoZWlnaHQgMTAwJVxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yIHRyYW5zcGFyZW50XFxuICAgIGJvcmRlciAwXFxuICAgIG1hcmdpbi1sZWZ0IDVweFxcbiAgICBmb250LXNpemUgaW5oZXJpdFxcbiAgICBjb2xvciBpbmhlcml0XFxuICAgIG91dGxpbmUgMFxcbiAgICB0cmFuc2l0aW9uIGNvbG9yIDAuMjVzXFxuICAgICY6Zm9jdXNcXG4gICAgICBjb2xvciAkYWN0aXZlLWNvbG9yXFxuXFxuICAgICY6OnBsYWNlaG9sZGVyXFxuICAgICAgb3BhY2l0eSAwLjhcXG5cXG4gICAgJi5pbnZhbGlkXFxuICAgICAgY29sb3IgcmdiYSg3NywgMTAsIDksIDEpXFxuXCIsXCIuYWN0aW9uLWhlYWRlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxuICBwYWRkaW5nOiAwIDEwcHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDtcXG4gIGNvbG9yOiAjNjY2O1xcbiAgaGVpZ2h0OiAzNXB4O1xcbn1cXG5AbWVkaWEgKG1pbi1oZWlnaHQ6IDMwMHB4KSB7XFxuICAuYWN0aW9uLWhlYWRlciB7XFxuICAgIGhlaWdodDogNTBweDtcXG4gIH1cXG59XFxuLmFwcC5kYXJrIC5hY3Rpb24taGVhZGVyIHtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjM2EzYTNhO1xcbn1cXG4udGl0bGUge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBjb2xvcjogIzNiYTc3NjtcXG59XFxuLmJ1dHRvbiB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgcGFkZGluZzogMCAxMHB4O1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI1cztcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICBvcGFjaXR5OiAwLjg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG4uYnV0dG9uOmZpcnN0LW9mLXR5cGUge1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxufVxcbi5idXR0b246bm90KC5kaXNhYmxlZCk6aG92ZXIge1xcbiAgb3BhY2l0eTogMTtcXG4gIGNvbG9yOiAjM2JhNzc2O1xcbn1cXG4uYnV0dG9uLmRpc2FibGVkIHtcXG4gIG9wYWNpdHk6IDAuNDU7XFxuICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbn1cXG4uYnV0dG9uIHNwYW4ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDgyMHB4KSB7XFxuICAuYnV0dG9uIHNwYW4ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmU7XFxuICB9XFxufVxcbi5tYXRlcmlhbC1pY29ucyB7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxuICBjb2xvcjogaW5oZXJpdDtcXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDgyMHB4KSB7XFxuICAubWF0ZXJpYWwtaWNvbnMge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIH1cXG59XFxuLnNlYXJjaCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGZsZXg6IDE7XFxufVxcbi5zZWFyY2ggaW5wdXQge1xcbiAgZmxleDogMTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyOiAwO1xcbiAgbWFyZ2luLWxlZnQ6IDVweDtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgb3V0bGluZTogMDtcXG4gIHRyYW5zaXRpb246IGNvbG9yIDAuMjVzO1xcbn1cXG4uc2VhcmNoIGlucHV0OmZvY3VzIHtcXG4gIGNvbG9yOiAjM2JhNzc2O1xcbn1cXG4uc2VhcmNoIGlucHV0OjpwbGFjZWhvbGRlciB7XFxuICBvcGFjaXR5OiAwLjg7XFxufVxcbi5zZWFyY2ggaW5wdXQuaW52YWxpZCB7XFxuICBjb2xvcjogIzRkMGEwOTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1hODcyMGFmOFwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3N0eWx1cy1sb2FkZXIhLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL21hdGNoRmlsdGVyL2FjdGlvblRhYi52dWVcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5tYXRjaEFycnNbZGF0YS12LWRhZDA2ZjNjXSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuLm1hdGNoQXJycyAuYXJyLWNvbnRlbnRbZGF0YS12LWRhZDA2ZjNjXSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQ6ICNmM2YzZjM7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuLm1hdGNoQXJycyAuYXJyLWNvbnRlbnQgLmFyci1pdGVtc1tkYXRhLXYtZGFkMDZmM2NdIHtcXG4gIGZvbnQ6IDEycHggJ21pY3Jvc29mdCB5YWhlaSc7XFxuICBsaW5lLWhlaWdodDogMjVweDtcXG4gIGhlaWdodDogMjVweDtcXG4gIGNvbG9yOiAjMDAwO1xcbiAgcGFkZGluZzogMCAwIDAgMjBweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLm1hdGNoQXJycyAuYXJyLWNvbnRlbnQgLmFyci1pdGVtc1tkYXRhLXYtZGFkMDZmM2NdOm50aC1jaGlsZChldmVuKSB7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbn1cXG4ubWF0Y2hBcnJzIC5hcnItY29udGVudCAuYXJyLWl0ZW1zW2RhdGEtdi1kYWQwNmYzY106aG92ZXIge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcbi5tYXRjaEFycnMgLmFyci1jb250ZW50IC5hcnItaXRlbXMuYWN0aXZlW2RhdGEtdi1kYWQwNmYzY10ge1xcbiAgYmFja2dyb3VuZDogIzcxNzFmNztcXG4gIGNvbG9yOiAjZmZmO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL2NvbXBvbmVudHMvc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvbWF0Y2guc3R5bFwiLFwiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvbWF0Y2guc3R5bFwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBQUE7RUFDSSxZQUFBO0VBQ0EsYUFBQTtDQ0NIO0FEQUc7RUFDSSxZQUFBO0VBQ0Esb0JBQUE7RUFDQSxpQkFBQTtFQUNBLFVBQUE7RUFDQSxXQUFBO0NDRVA7QURETztFQUNJLDZCQUFBO0VBQ0Esa0JBQUE7RUFDQSxhQUFBO0VBQ0EsWUFBQTtFQUNBLG9CQUFBO0VBQ0EsZ0JBQUE7Q0NHWDtBREZPO0VBQ0ksaUJBQUE7Q0NJWDtBREhPO0VBQ0ksMkJBQUE7Q0NLWDtBREpPO0VBQ0ksb0JBQUE7RUFDQSxZQUFBO0NDTVhcIixcImZpbGVcIjpcIm1hdGNoLnN0eWxcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLm1hdGNoQXJyc1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAuYXJyLWNvbnRlbnRcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgYmFja2dyb3VuZDogI2YzZjNmMztcXG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgLmFyci1pdGVtc1xcbiAgICAgICAgICAgIGZvbnQ6IDEycHggJ21pY3Jvc29mdCB5YWhlaSc7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDI1cHg7XFxuICAgICAgICAgICAgaGVpZ2h0OiAyNXB4O1xcbiAgICAgICAgICAgIGNvbG9yOiAjMDAwO1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDAgMCAwIDIwcHg7XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgLmFyci1pdGVtczpudGgtY2hpbGQoZXZlbilcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgICAgICAgLmFyci1pdGVtczpob3ZlclxcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgICAgICAgLmFyci1pdGVtcy5hY3RpdmVcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAjNzE3MWY3O1xcbiAgICAgICAgICAgIGNvbG9yOiAjZmZmO1xcblwiLFwiLm1hdGNoQXJycyB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuLm1hdGNoQXJycyAuYXJyLWNvbnRlbnQge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBiYWNrZ3JvdW5kOiAjZjNmM2YzO1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcbi5tYXRjaEFycnMgLmFyci1jb250ZW50IC5hcnItaXRlbXMge1xcbiAgZm9udDogMTJweCAnbWljcm9zb2Z0IHlhaGVpJztcXG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xcbiAgaGVpZ2h0OiAyNXB4O1xcbiAgY29sb3I6ICMwMDA7XFxuICBwYWRkaW5nOiAwIDAgMCAyMHB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4ubWF0Y2hBcnJzIC5hcnItY29udGVudCAuYXJyLWl0ZW1zOm50aC1jaGlsZChldmVuKSB7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbn1cXG4ubWF0Y2hBcnJzIC5hcnItY29udGVudCAuYXJyLWl0ZW1zOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG4ubWF0Y2hBcnJzIC5hcnItY29udGVudCAuYXJyLWl0ZW1zLmFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kOiAjNzE3MWY3O1xcbiAgY29sb3I6ICNmZmY7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtZGFkMDZmM2NcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zdHlsdXMtbG9hZGVyIS4uL3NyYy9jb21wb25lbnRzL21hdGNoRmlsdGVyL21hdGNoLnN0eWxcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5kYXRhLXdyYXBwZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtd3JhcDogd3JhcDtcXG4gIHBhZGRpbmctdG9wOiAyMHB4O1xcbn1cXG4uZGF0YS1maWVsZHMge1xcbiAgcGFkZGluZzogMjBweCAyMHB4IDQwcHg7XFxufVxcbi5kYXRhLWVsIHtcXG4gIHBhZGRpbmc6IDBweCAxMHB4O1xcbiAgZmxleDogMSAwIDMzLjMzJTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuLmRhdGEtZWwgLmRhdGEtdHlwZSB7XFxuICBjb2xvcjogIzQ4Njg4NztcXG4gIHBhZGRpbmctbGVmdDogMjBweDtcXG4gIG1hcmdpbi1ib3R0b206IC0xMHB4O1xcbn1cXG4uYXBwLmRhcmsgLmRhdGEtZWwgLmRhdGEtdHlwZSB7XFxuICBjb2xvcjogIzc1OTViNTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkc6L2x1b2JhdGEvbGliL21hdGNoLWRldnRvb2xzL3NyYy9jb21wb25lbnRzL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL21hdGNoT2JqLnZ1ZVwiLFwiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovbWF0Y2hPYmoudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUE0Q0E7RUFDRSxjQUFBO0VBQ0EsZ0JBQUE7RUFDQSxrQkFBQTtDQzNDRDtBRDZDRDtFQUNFLHdCQUFBO0NDM0NEO0FENkNEO0VBQ0Usa0JBQUE7RUFDQSxpQkFBQTtFQUNBLGdCQUFBO0NDM0NEO0FENkNDO0VBQ0UsZUFBQTtFQUNBLG1CQUFBO0VBQ0EscUJBQUE7Q0MzQ0g7QUQ2Q0c7RUFDRSxlQUFBO0NDM0NMXCIsXCJmaWxlXCI6XCJtYXRjaE9iai52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLmRhdGEtd3JhcHBlclxcbiAgZGlzcGxheSBmbGV4XFxuICBmbGV4LXdyYXAgd3JhcFxcbiAgcGFkZGluZy10b3AgMjBweFxcblxcbi5kYXRhLWZpZWxkc1xcbiAgcGFkZGluZyAyMHB4IDIwcHggNDBweFxcblxcbi5kYXRhLWVsXFxuICBwYWRkaW5nIDBweCAxMHB4XFxuICBmbGV4IDEgMCAzMy4zMyVcXG4gIGZvbnQtc2l6ZSAxNHB4XFxuXFxuICAuZGF0YS10eXBlXFxuICAgIGNvbG9yICM0ODY4ODdcXG4gICAgcGFkZGluZy1sZWZ0IDIwcHhcXG4gICAgbWFyZ2luLWJvdHRvbSAtMTBweFxcblxcbiAgICAuYXBwLmRhcmsgJlxcbiAgICAgIGNvbG9yIGxpZ2h0ZW4oIzQ4Njg4NywgMzAlKVxcblwiLFwiLmRhdGEtd3JhcHBlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgcGFkZGluZy10b3A6IDIwcHg7XFxufVxcbi5kYXRhLWZpZWxkcyB7XFxuICBwYWRkaW5nOiAyMHB4IDIwcHggNDBweDtcXG59XFxuLmRhdGEtZWwge1xcbiAgcGFkZGluZzogMHB4IDEwcHg7XFxuICBmbGV4OiAxIDAgMzMuMzMlO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4uZGF0YS1lbCAuZGF0YS10eXBlIHtcXG4gIGNvbG9yOiAjNDg2ODg3O1xcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogLTEwcHg7XFxufVxcbi5hcHAuZGFyayAuZGF0YS1lbCAuZGF0YS10eXBlIHtcXG4gIGNvbG9yOiAjNzU5NWI1O1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LWUxY2NhMjM0XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3N0eWx1cy1sb2FkZXIhLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL21hdGNoT2JqLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmRhdGEtZmllbGRbZGF0YS12LWVjYWFmNWE4XSB7XFxuICB1c2VyLXNlbGVjdDogdGV4dDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGZvbnQtZmFtaWx5OiBNZW5sbywgQ29uc29sYXMsIG1vbm9zcGFjZTtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuLnNlbGZbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICBsaW5lLWhlaWdodDogMjBweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICBwYWRkaW5nLWxlZnQ6IDE0cHg7XFxufVxcbi5zZWxmIHNwYW5bZGF0YS12LWVjYWFmNWE4XSxcXG4uc2VsZiBkaXZbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG4uc2VsZiAuYXJyb3dbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDdweDtcXG4gIGxlZnQ6IDBweDtcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGVhc2U7XFxufVxcbi5zZWxmIC5hcnJvdy5yb3RhdGVkW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbn1cXG4uc2VsZiAua2V5W2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgY29sb3I6ICM4ODEzOTE7XFxufVxcbi5zZWxmIC5jb2xvbltkYXRhLXYtZWNhYWY1YThdIHtcXG4gIG1hcmdpbi1yaWdodDogMC41ZW07XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5zZWxmIC52YWx1ZVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGNvbG9yOiAjNDQ0O1xcbn1cXG4uc2VsZiAudmFsdWUuc3RyaW5nW2RhdGEtdi1lY2FhZjVhOF0sXFxuLnNlbGYgLnZhbHVlLm5hdGl2ZVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGNvbG9yOiAjYzQxYTE2O1xcbn1cXG4uc2VsZiAudmFsdWUubnVsbFtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG4uc2VsZiAudmFsdWUubGl0ZXJhbFtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGNvbG9yOiAjMDNjO1xcbn1cXG4uc2VsZiAudHlwZVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgcGFkZGluZzogM3B4IDZweDtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMHB4O1xcbiAgaGVpZ2h0OiAxNnB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgbWFyZ2luOiAycHggNnB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG59XFxuLnNlbGYgLnR5cGUucHJvcFtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM5NmFmZGQ7XFxufVxcbi5zZWxmIC50eXBlLmNvbXB1dGVkW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2FmOTBkNTtcXG59XFxuLnNlbGYgLnR5cGUudnVleC1nZXR0ZXJbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNWRkNWQ1O1xcbn1cXG4uc2VsZiAudHlwZS5maXJlYmFzZS1iaW5kaW5nW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZjMDtcXG59XFxuLnNlbGYgLnR5cGUub2JzZXJ2YWJsZVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmOTk7XFxufVxcbi5zZWxmIC5tZXRhW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDk5OTtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGNvbG9yOiAjNDQ0O1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogY2FsYygxMDAlICsgNXB4KTtcXG4gIHdpZHRoOiAxNTBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlM2UzZTM7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBwYWRkaW5nOiA4cHggMTJweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBsaW5lLWhlaWdodDogMTZweDtcXG4gIGJveC1zaGFkb3c6IDAgMnB4IDEycHggcmdiYSgwLDAsMCwwLjEpO1xcbn1cXG4uc2VsZiAubWV0YSAua2V5W2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgd2lkdGg6IDY1cHg7XFxufVxcbi5zZWxmIC5tZXRhLWZpZWxkW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5zZWxmW2RhdGEtdi1lY2FhZjVhOF06aG92ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4uc2VsZjpob3ZlciAubWV0YVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uYXBwLmRhcmsgLnNlbGYgLmtleVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGNvbG9yOiAjZTM2ZWVjO1xcbn1cXG4uYXBwLmRhcmsgLnNlbGYgLnZhbHVlW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgY29sb3I6ICNiZGM2Y2Y7XFxufVxcbi5hcHAuZGFyayAuc2VsZiAudmFsdWUuc3RyaW5nW2RhdGEtdi1lY2FhZjVhOF0sXFxuLmFwcC5kYXJrIC5zZWxmIC52YWx1ZS5uYXRpdmVbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBjb2xvcjogI2UzM2UzYTtcXG59XFxuLmFwcC5kYXJrIC5zZWxmIC52YWx1ZS5udWxsW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgY29sb3I6ICM5OTk7XFxufVxcbi5hcHAuZGFyayAuc2VsZiAudmFsdWUubGl0ZXJhbFtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGNvbG9yOiAjOTk3ZmZmO1xcbn1cXG4uYXBwLmRhcmsgLnNlbGYgLnR5cGVbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBjb2xvcjogIzI0MjQyNDtcXG59XFxuLmFwcC5kYXJrIC5zZWxmIC50eXBlIC5tZXRhW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzNhM2EzYTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyNDI0MjQ7XFxufVxcbi5tb3JlW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgcGFkZGluZzogMCA0cHggNHB4O1xcbn1cXG4ubW9yZVtkYXRhLXYtZWNhYWY1YThdOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJHOi9sdW9iYXRhL2xpYi9tYXRjaC1kZXZ0b29scy9zcmMvY29tcG9uZW50cy9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlXCIsXCJHOi9sdW9iYXRhL2xpYi9tYXRjaC1kZXZ0b29scy9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUF5SkE7RUFDRSxrQkFBQTtFQUNBLGdCQUFBO0VBQ0Esd0NBQUE7RUFDQSxnQkFBQTtDQ3hKRDtBRDBKRDtFQUNFLGFBQUE7RUFDQSxrQkFBQTtFQUNBLG1CQUFBO0VBQ0Esb0JBQUE7RUFDQSxtQkFBQTtDQ3hKRDtBRHlKQzs7RUFDRSxzQkFBQTtFQUNBLHVCQUFBO0NDdEpIO0FEdUpDO0VBQ0UsbUJBQUE7RUFDQSxTQUFBO0VBQ0EsVUFBQTtFQUNBLGdDQUFBO0NDckpIO0FEc0pHO0VBQ0UseUJBQUE7Q0NwSkw7QURxSkM7RUFDRSxlQUFBO0NDbkpIO0FEb0pDO0VBQ0Usb0JBQUE7RUFDQSxtQkFBQTtDQ2xKSDtBRG1KQztFQUNFLFlBQUE7Q0NqSkg7QURrSkc7O0VBQ0UsZUFBQTtDQy9JTDtBRGdKRztFQUNFLFlBQUE7Q0M5SUw7QUQrSUc7RUFDRSxZQUFBO0NDN0lMO0FEK0lDO0VBQ0UsWUFBQTtFQUNBLGlCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxrQkFBQTtFQUNBLGFBQUE7RUFDQSxtQkFBQTtFQUNBLGdCQUFBO0VBQ0EsbUJBQUE7RUFDQSx1QkFBQTtDQzdJSDtBRDhJRztFQUNFLDBCQUFBO0NDNUlMO0FENklHO0VBQ0UsMEJBQUE7Q0MzSUw7QUQ0SUc7RUFDRSwwQkFBQTtDQzFJTDtBRDJJRztFQUNFLHVCQUFBO0NDeklMO0FEMElHO0VBQ0UsdUJBQUE7Q0N4SUw7QUQwSUM7RUFDRSxjQUFBO0VBQ0EsbUJBQUE7RUFDQSxhQUFBO0VBQ0EsZ0JBQUE7RUFDQSxZQUFBO0VBQ0EsT0FBQTtFQUNBLHVCQUFBO0VBQ0EsYUFBQTtFQUNBLDBCQUFBO0VBQ0EsbUJBQUE7RUFDQSxrQkFBQTtFQUNBLHVCQUFBO0VBQ0Esa0JBQUE7RUFDQSx1Q0FBQTtDQ3hJSDtBRHlJRztFQUNFLFlBQUE7Q0N2SUw7QUR3SUM7RUFDRSxlQUFBO0NDdElIO0FEdUlDO0VBQ0UsZ0JBQUE7Q0NySUg7QURzSUc7RUFDRSxlQUFBO0NDcElMO0FEdUlHO0VBQ0UsZUFBQTtDQ3JJTDtBRHNJRztFQUNFLGVBQUE7Q0NwSUw7QURxSUs7O0VBQ0UsZUFBQTtDQ2xJUDtBRG1JSztFQUNFLFlBQUE7Q0NqSVA7QURrSUs7RUFDRSxlQUFBO0NDaElQO0FEaUlHO0VBQ0UsZUFBQTtDQy9ITDtBRGdJSztFQUNFLDBCQUFBO0VBQ0EsMEJBQUE7Q0M5SFA7QURpSUQ7RUFDRSxnQkFBQTtFQUNBLHNCQUFBO0VBQ0EsbUJBQUE7RUFDQSxtQkFBQTtDQy9IRDtBRGdJQztFQUNFLHVCQUFBO0NDOUhIXCIsXCJmaWxlXCI6XCJkYXRhRmllbGQudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbkBpbXBvcnQgXFxcIi4uLy4uL3ZhcmlhYmxlc1xcXCJcXG5cXG4uZGF0YS1maWVsZFxcbiAgdXNlci1zZWxlY3QgdGV4dFxcbiAgZm9udC1zaXplIDEycHhcXG4gIGZvbnQtZmFtaWx5IE1lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlXFxuICBjdXJzb3IgZGVmYXVsdFxcblxcbi5zZWxmXFxuICBoZWlnaHQgMjBweFxcbiAgbGluZS1oZWlnaHQgMjBweFxcbiAgcG9zaXRpb24gcmVsYXRpdmVcXG4gIHdoaXRlLXNwYWNlIG5vd3JhcFxcbiAgcGFkZGluZy1sZWZ0IDE0cHhcXG4gIHNwYW4sIGRpdlxcbiAgICBkaXNwbGF5IGlubGluZS1ibG9ja1xcbiAgICB2ZXJ0aWNhbC1hbGlnbiBtaWRkbGVcXG4gIC5hcnJvd1xcbiAgICBwb3NpdGlvbiBhYnNvbHV0ZVxcbiAgICB0b3AgN3B4XFxuICAgIGxlZnQgMHB4XFxuICAgIHRyYW5zaXRpb24gdHJhbnNmb3JtIC4xcyBlYXNlXFxuICAgICYucm90YXRlZFxcbiAgICAgIHRyYW5zZm9ybSByb3RhdGUoOTBkZWcpXFxuICAua2V5XFxuICAgIGNvbG9yICM4ODEzOTFcXG4gIC5jb2xvblxcbiAgICBtYXJnaW4tcmlnaHQgLjVlbVxcbiAgICBwb3NpdGlvbiByZWxhdGl2ZVxcbiAgLnZhbHVlXFxuICAgIGNvbG9yICM0NDRcXG4gICAgJi5zdHJpbmcsICYubmF0aXZlXFxuICAgICAgY29sb3IgI2M0MWExNlxcbiAgICAmLm51bGxcXG4gICAgICBjb2xvciAjOTk5XFxuICAgICYubGl0ZXJhbFxcbiAgICAgIGNvbG9yICMwMDMzY2NcXG5cXG4gIC50eXBlXFxuICAgIGNvbG9yICRiYWNrZ3JvdW5kLWNvbG9yXFxuICAgIHBhZGRpbmcgM3B4IDZweFxcbiAgICBmb250LXNpemUgMTBweFxcbiAgICBsaW5lLWhlaWdodCAxMHB4XFxuICAgIGhlaWdodCAxNnB4XFxuICAgIGJvcmRlci1yYWRpdXMgM3B4XFxuICAgIG1hcmdpbiAycHggNnB4XFxuICAgIHBvc2l0aW9uIHJlbGF0aXZlXFxuICAgIGJhY2tncm91bmQtY29sb3IgI2VlZVxcbiAgICAmLnByb3BcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yICM5NmFmZGRcXG4gICAgJi5jb21wdXRlZFxcbiAgICAgIGJhY2tncm91bmQtY29sb3IgI2FmOTBkNVxcbiAgICAmLnZ1ZXgtZ2V0dGVyXFxuICAgICAgYmFja2dyb3VuZC1jb2xvciAjNWRkNWQ1XFxuICAgICYuZmlyZWJhc2UtYmluZGluZ1xcbiAgICAgIGJhY2tncm91bmQtY29sb3IgI2ZmY2MwMFxcbiAgICAmLm9ic2VydmFibGVcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yICNmZjk5OTlcXG5cXG4gIC5tZXRhXFxuICAgIGRpc3BsYXkgbm9uZVxcbiAgICBwb3NpdGlvbiBhYnNvbHV0ZVxcbiAgICB6LWluZGV4IDk5OVxcbiAgICBmb250LXNpemUgMTFweFxcbiAgICBjb2xvciAjNDQ0XFxuICAgIHRvcCAwXFxuICAgIGxlZnQgY2FsYygxMDAlICsgNXB4KVxcbiAgICB3aWR0aCAxNTBweFxcbiAgICBib3JkZXIgMXB4IHNvbGlkICNlM2UzZTNcXG4gICAgYm9yZGVyLXJhZGl1cyAzcHhcXG4gICAgcGFkZGluZyA4cHggMTJweFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yICRiYWNrZ3JvdW5kLWNvbG9yXFxuICAgIGxpbmUtaGVpZ2h0IDE2cHhcXG4gICAgYm94LXNoYWRvdyAwIDJweCAxMnB4IHJnYmEoMCwwLDAsLjEpXFxuICAgIC5rZXlcXG4gICAgICB3aWR0aCA2NXB4XFxuICAubWV0YS1maWVsZFxcbiAgICBkaXNwbGF5IGJsb2NrXFxuICAmOmhvdmVyXFxuICAgIGN1cnNvciBwb2ludGVyXFxuICAgIC5tZXRhXFxuICAgICAgZGlzcGxheSBibG9ja1xcblxcbiAgLmFwcC5kYXJrICZcXG4gICAgLmtleVxcbiAgICAgIGNvbG9yOiAjZTM2ZWVjXFxuICAgIC52YWx1ZVxcbiAgICAgIGNvbG9yICNiZGM2Y2ZcXG4gICAgICAmLnN0cmluZywgJi5uYXRpdmVcXG4gICAgICAgIGNvbG9yICNlMzNlM2FcXG4gICAgICAmLm51bGxcXG4gICAgICAgIGNvbG9yICM5OTlcXG4gICAgICAmLmxpdGVyYWxcXG4gICAgICAgIGNvbG9yICM5OTdmZmZcXG4gICAgLnR5cGVcXG4gICAgICBjb2xvcjogIzI0MjQyNFxcbiAgICAgIC5tZXRhXFxuICAgICAgICBib3JkZXIgMXB4IHNvbGlkICRkYXJrLWJvcmRlci1jb2xvclxcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvciAkZGFyay1iYWNrZ3JvdW5kLWNvbG9yXFxuXFxuXFxuLm1vcmVcXG4gIGN1cnNvciBwb2ludGVyXFxuICBkaXNwbGF5IGlubGluZS1ibG9ja1xcbiAgYm9yZGVyLXJhZGl1cyA0cHhcXG4gIHBhZGRpbmcgMCA0cHggNHB4XFxuICAmOmhvdmVyXFxuICAgIGJhY2tncm91bmQtY29sb3IgI2VlZVxcblwiLFwiLmRhdGEtZmllbGQge1xcbiAgdXNlci1zZWxlY3Q6IHRleHQ7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBmb250LWZhbWlseTogTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2U7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcbi5zZWxmIHtcXG4gIGhlaWdodDogMjBweDtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHBhZGRpbmctbGVmdDogMTRweDtcXG59XFxuLnNlbGYgc3BhbixcXG4uc2VsZiBkaXYge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuLnNlbGYgLmFycm93IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogN3B4O1xcbiAgbGVmdDogMHB4O1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMXMgZWFzZTtcXG59XFxuLnNlbGYgLmFycm93LnJvdGF0ZWQge1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbn1cXG4uc2VsZiAua2V5IHtcXG4gIGNvbG9yOiAjODgxMzkxO1xcbn1cXG4uc2VsZiAuY29sb24ge1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjVlbTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLnNlbGYgLnZhbHVlIHtcXG4gIGNvbG9yOiAjNDQ0O1xcbn1cXG4uc2VsZiAudmFsdWUuc3RyaW5nLFxcbi5zZWxmIC52YWx1ZS5uYXRpdmUge1xcbiAgY29sb3I6ICNjNDFhMTY7XFxufVxcbi5zZWxmIC52YWx1ZS5udWxsIHtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG4uc2VsZiAudmFsdWUubGl0ZXJhbCB7XFxuICBjb2xvcjogIzAzYztcXG59XFxuLnNlbGYgLnR5cGUge1xcbiAgY29sb3I6ICNmZmY7XFxuICBwYWRkaW5nOiAzcHggNnB4O1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDEwcHg7XFxuICBoZWlnaHQ6IDE2cHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBtYXJnaW46IDJweCA2cHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbn1cXG4uc2VsZiAudHlwZS5wcm9wIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM5NmFmZGQ7XFxufVxcbi5zZWxmIC50eXBlLmNvbXB1dGVkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNhZjkwZDU7XFxufVxcbi5zZWxmIC50eXBlLnZ1ZXgtZ2V0dGVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM1ZGQ1ZDU7XFxufVxcbi5zZWxmIC50eXBlLmZpcmViYXNlLWJpbmRpbmcge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZjMDtcXG59XFxuLnNlbGYgLnR5cGUub2JzZXJ2YWJsZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjk5O1xcbn1cXG4uc2VsZiAubWV0YSB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogOTk5O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgY29sb3I6ICM0NDQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiBjYWxjKDEwMCUgKyA1cHgpO1xcbiAgd2lkdGg6IDE1MHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2UzZTNlMztcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIHBhZGRpbmc6IDhweCAxMnB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGxpbmUtaGVpZ2h0OiAxNnB4O1xcbiAgYm94LXNoYWRvdzogMCAycHggMTJweCByZ2JhKDAsMCwwLDAuMSk7XFxufVxcbi5zZWxmIC5tZXRhIC5rZXkge1xcbiAgd2lkdGg6IDY1cHg7XFxufVxcbi5zZWxmIC5tZXRhLWZpZWxkIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uc2VsZjpob3ZlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5zZWxmOmhvdmVyIC5tZXRhIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uYXBwLmRhcmsgLnNlbGYgLmtleSB7XFxuICBjb2xvcjogI2UzNmVlYztcXG59XFxuLmFwcC5kYXJrIC5zZWxmIC52YWx1ZSB7XFxuICBjb2xvcjogI2JkYzZjZjtcXG59XFxuLmFwcC5kYXJrIC5zZWxmIC52YWx1ZS5zdHJpbmcsXFxuLmFwcC5kYXJrIC5zZWxmIC52YWx1ZS5uYXRpdmUge1xcbiAgY29sb3I6ICNlMzNlM2E7XFxufVxcbi5hcHAuZGFyayAuc2VsZiAudmFsdWUubnVsbCB7XFxuICBjb2xvcjogIzk5OTtcXG59XFxuLmFwcC5kYXJrIC5zZWxmIC52YWx1ZS5saXRlcmFsIHtcXG4gIGNvbG9yOiAjOTk3ZmZmO1xcbn1cXG4uYXBwLmRhcmsgLnNlbGYgLnR5cGUge1xcbiAgY29sb3I6ICMyNDI0MjQ7XFxufVxcbi5hcHAuZGFyayAuc2VsZiAudHlwZSAubWV0YSB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjM2EzYTNhO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzI0MjQyNDtcXG59XFxuLm1vcmUge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgcGFkZGluZzogMCA0cHggNHB4O1xcbn1cXG4ubW9yZTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LWVjYWFmNWE4XCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc3R5bHVzLWxvYWRlciEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovZGF0YUZpZWxkLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmYyO2Jhc2U2NCxkMDlHTWdBQkFBQUFBSkFZQUE0QUFBQUJwK1FBQUkrK0FBRUFnd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR2lRYk5oeUJzem9HWUFDRldoRUlDb1QwY0lQWGVRRTJBaVFEalF3TGpRZ0FCQ0FGZ253SElGdndVVkVqbm5ZZ3Yzb0Q3bHNhdGRYTFVRUWJCd0J2OUY4REZlT1lwY0RHQVF5TzE1RFovMzlPZ2hwRDltQTdRSjI1VlpXSXRDbFVmUXgxMFRXSFNxbkNoR0k2b1RoTlg5VTJsL0xNY0o2WkRpUXV1RVJZRklTRklKeWVhVkZxdTZ4cnJlczI4M0JUWStpbHQ0ZkJ3WlJEVXgrcEUzL2I3VTNkNWQzVExaUXVSL25vQy9ZWEJrdDlBNXBvNUVGL1BWdnhFQS81TklYQ3V3YWl6TjZIUzMrSnNldEJLc01zQ2JuWGt2Ly9HQVBhdWUrdlNqT042NkdKaDBnaU10dlE2UXlSSVZSQ1Z3bVp5blRvL08vY2Z4VlNlQlJzTTcxcDBudVQ5dmNQcVZFSUdsQUNhdlo0L0FnMWZvUmVLZmY0UGV0LzB2V2ZtSFJ5cGp1dm84MjltWG05SUZSd3dmcGNGMUgwOFB5NTNpZUhvQVh0THczbFpXMmRvRG9CWFNleVZoM0FUbTNEZlZ0KzJQOXhMV0xGR25LWUY1ZUpNTzc4Tk02ZmtKWWltTnRDbGo1NDg4MXZCQS9XK2RRWWwrcEs2UEE5eUorbjNQdy9LQzZ3VDhnTUVJR0VnRWp1RFpzUUY4QmtnTEFsS052Y1lWTmgxMHdVTnhCYzZzeFRLOEZhYTl1RWlsMWN1akxwK3FxMXI5aUd0cS85ejBwM2t2WXQwUzZiOEkxdnNiV3IrYjljWnI5eXJNcFJZSmpoZG9QYWlPMUI5SlJVaWJYa1VSSmRydEpWZXJrSkRMdHNFQVNoSVFodFcxSmxYOElPL04vL2NqNitDQnZ3UVRTbG50bldnK2lFb25ZM3FBOHVkeEZMVTcrNFhjUzJvbFBSUld3UURSV2IwMjVWTHVTVUZlQmFaTTRYdW1iRlliOWgyOVlIc3dMKy9hSCs5K3NORzNIQUN0YTFpVVBxbEZaL0JSMU9wV3lnc0FlakhnREg1elIvUnI3TlNQOVVCa1V1UXV3VXdYRUc3T2lUODNhcnk5VzZTbGZERWpSWUFsckhId0Y2NkQ2ZGJPenR4NXpxOXlVNkFROUdKTDBBUzhWYXJZR25XbjdydCt1bTl4Y3FLVncwNGpoaENUczc3QTNwM3hTTXNiOXR0NGFzS1RUS2hCRDl2bnZmQWZ4TlpPODlKNkRwWEdkTTBtWUVma2swdHBQR29TZXkrd1hTUVBmdjFiUksyZEk0N1ZtZDg3dWVaMXdRcmZIWkdaZGU1RUlyZkx6L1VNRERBNjRKUXR3bUJIYU5tcFNxQmJVMHJWWkwxVWR4NW44QTFLTEIxcFZjUUZLY0xibmRJaW10a1ZsbktJN1RlR3E5aVM5SXJNMXNlRWw2MllSM2NYeHBja2w4ODYrcVZVczZQY3VidEx1WFlyY2hGdDNsVkYxNVRZWC9BVUw4QUQra0QvQlRCQ25JQkNsNVJGSHlFS0FvazFRd1JVRWNtZExlbzJESmszU1Rnalo1VWdaSXkwdEs5ZzRwMlJ0U0xCb0hlV09xN25KM1ZiVkZlMDEzUlZGZVVSNjg3eEw5aHQ1MjhUTkExalRSSW0yRGNzN2VGL0txMEZBMUljZjBSSW5JVzIrZm5leHg1Y0hMYnR2MEdzSXd5Q0JXeElxSURTSGZQWGVqaXRyWTBBTlF2Yzk3YzBQVGlJaUlCQkVSRVFraGhDQTF2NTlLeFNUdHZoSnh6THJBTVhHZ29xREovZDI3UWViODc0RzJ0bHNOQ0ZTUUZaYmlHdXhNRXRyN2Q4aG1KU0w4Ym8vcnNaQlNhbmdKRUptSnduL2FrbmxDNWlWZHBsQTYxdTNrcFlBeFdVK1U5Ujh6bVU5M1VOMDdCL29ocSttQnpCRGZnZHdldHpLNjRzREw4Y0IzZDdkdDZrUjBEaVVhV3Z5L29pWjlVRDFxR0VISnQ3amx5cW1FYzB2WTlNaWxOY3ZtNlRUb3ZlVVpCYjlIOWEyOGxmUkVTYkg1ZUoyeGNhQnhxcW0xSmJiRkNBSzZzVTNCVUFRVU1Da3lBbTl4aDludmM2ZHIyNjNla09MZE5kOThvYTBPUTRJdTcvQ2Ria2d4emRUNXNPYk5kUi9zZDhzZVdEVmhNRkZneWg4eGVqaE1pV0J4TWdVRnNva2xzYlFDeWJLMU4xTzVPaTNxYkxpSUdSYm13VWdzd3dPQmdCZUp6V05wUnB1aFpSTDB0bWJtOHJBMjNNY1NBS1hJS0hCeUNlT09XdDgwYTgxdDZLL3VLRWdjQ2RidWZqa0MxZFRLRzZZVlY2b1gxU2F3ZExwck82Zk9Tdm41dGVBY0cvWnp3bzFLMmtoUEQ1MmVCQjJDbWpaSHNVazhRWFlkZGZNWW0wNUxVWUxNNDVBd0paSkdaU05ocWFkYndCNmdHZVBZN1FRbjBKRHBsaWRKYk85SGc2MmdSb2hSOGh4Z0oxR1dabGNQWEhqTHFVQ0VkQXB3YVE5U0VhdWtnZk9tRWkweUlPUjVyR0t3V1gzeEVKRktINHBOS3VlS2ZMTjR5MGlzdHF6NXJNemhCMWhrc3E1NXJWenFnNFJ1elc5cFpMSUE3RHBxTVVXRWg4Vk1RVlNUaFFYUHZJNm9iaHA1UFhEaExjRlRkMXFlM2t6dHRVRlY5YUNtRkZmU2hDZ3dlcHRvQnVJaE1ZTGt0cFZJVDJrcmZKTWtiaXArcklCUlZMRHFyMlNOZTlzc0pEdzRjbWdMc0VhZUpTbU5RVWJ5RlZiVWJhdFVSVTZ3NE1HYkxjUWlFU2pqTVdtWGNnK1daT0Y5bU9aNFpFcTRHYk9tY2RPYjhDVWFNUmtwbmFnbFduS1hHOUxnTHZMc0JSbFJ4UldOTFhrcDR5akpQbGZwUWFodU1lbFdobHRVZ0RHVytseVVKT25WRXpkblN4emRuaFVnK2ZOeUFCSjJmekdoMWEwa1N0aG1ncjYxVHMyVjZ0MWxzeHN5NjNaRmFmT1FMTHI5NWlPTXZ1ZzJ0SE1RVktCcGRENUNMbGU1TUg5TFJNUStuclZtY01xNGpQQm13N0JwdHEvZlhFaU5CZXJMaGoza2JNZ1VMSDc5WWhUTzJjRnNCOVhHUUlhS3FuWW8xS2hxZXNZVnJWQzZHN2N0dDhXMFZmSnlWU0MvNnRvSXF5UW8zeTlubUhKa3Y2dWUrODhSTnd6T1FKQkJVSWhnOGVPY3lDRWEwdFlFa3NaR3NhbWpNcSttRzVsbFBaRTRVUVoxbzRDOTFDMEZudmZ2cFVGN0NnSzVoV3BkbTFkNmtqeVJNbW1ISkhhY3dIUDZkeHFsQ2xPQTU4bDFIc3ZJbk85SWdrUUxpSVMraW93WmVYVXlDYmFXWlJMVUhJZlNPck1EdjVxcUlQRHNzcjlzUTVIQU13UVdicjgxWG4vcGdvb1dMRUZPcWxTZkI1QWVpNXBtUTNmaTFmemVPc2pUMU16OVRzOFNadlFJUnVrYnFZb3dFdVNkTEhDMUFsQnVZWXc1ZTVVZVF0Y1lXZkc3Y0Yyd1pDdTMvc1VTVlNUWlRmbTNUZGU2NG5UcWpMU1VUWjJtbjA5Yng1OVBVNGVmVDEzN24wOVZ1MjlsZFYwdnFJRW5XSHRYNjhEUFVvaDJpZFVzK09sR1FiVWZJVVZQakZmWmozQndwL2hhOW4yVGJlQldKajlnU2krQUZxNTFvS0hvNzZhRUhsVUtjU2RoZXV0MkF5NFBJQlR4YXV4cmFjaHdYQ3Y3cGRFWkJkSGp1WjNpYnZzQ0VrNnFkem54ZVNic2dKUVFuK21FK29Da2RhWHFzZ3EyQmhra3AxTU9Tbm5YWGt1cnRvaE55MjhWbkthU0Q3d1FCb1Q1cDJ3OVRHSTZkZDFna0xwVmJUV1U0Sk5keldJWC9XNHByM3F2U25sajRLQmxMTG5oMEpWdDN3eDMwSkRRY2Rvekdnc3A0N1VLTjdiWTgyRjhZOXVSRXg0NGlMV2RFU2dJVTRlQ3VzNDlXbWhVY2RPRlM3QTJuZ3pKUEYveEpwZGV0Q1NacXNZV05KNFh0WnJWM3VDREZCYzZsanJKT0dWWVp4Sll3aFl4SlV4UU10a21WR2VFamVPa29LL1NwM3dpNTBRTGpsOUozU3RxVExiNURTYzlwakZWL2NiYVU3WGhvRngwNThKSUdGTjRaa0ZMRHFmYVUwanNjVndrZVJxRHFmcFFIU1BBUVdTTW9rekxKSFc2VjY2U3JLcklJZXhISUgwbmo3SkJmVGM1a0dnQkMvYXZnRmk5Q0xjNHBQY1hsR05UZEJweEcvR3lhQXcrSkQvVGNTTnFLaCtEZ3lSb0cybGt5dlFBK1pKQWZsR2ZtZGEzQWtrVlF1STRtVHNxenpIR2RMWUJQTWs4dU1nYmNpeGo2UkFpUEdlNWwwYkRSTUdqTzVEVTRlZzJ5UXNlb0JNUGpiNEhJWmdGMHhQSjRvWExqcUZ0a0pwdHgxY3h3cjRGSjdnUnVBbTFGWTI0aFU5RWRkMGdIaGt1OTNmTEhUelJNZzVkeTNVQnhqU0ZLRkJ3eDJJWFkwV1Q1TFN3eVJ1dW5TanNubWc2c2hGWDQ0VXBSYTdNMlhDYm1oQTNEWW42SlhONnNLcG5CRFVBUlR0bllGMENUV0hiek5oaFpNVXBxRGVHd2hSVVc5eldxd1U3ck8yUElublBKTU5iZFZ2RWVKd0NRckNEeHR5QWpVUlFNVVd3S3paWUVUdm1ZTDlTMXdOTmVSQUhXQU9BVEZsVjQvb0xqd1NnWTlPamZKUVNrT1VlN0RJTXlJZVgwQkFVczc5SVp1Tmd2N0dvN0F2eTI1VVFEM2FPNHFneE1uSWkyQk1DZXlSNnpkNVpDaWxrenNLOWtZSFpUdzFGSXIzdDJrSFZ5TTJ2clJpK0VaMWJCMjJoR0JOTzNPT0RCa3krUGJ6T1I4TnZocmNPR3UrUnpUZHJmcXFCaUFMRzhGNDFuckxxSVFhU29HVmRCdmRDRXFIdWJXbFd1QTM3SjFWR3NxNDhPOU1MUlUzcG9sWTNTTGpONTVvV29VVkFtd1Qyd0hUcjFLcWcrUndiOUtVTzdmajV1Y0N1MjdNSGFCaUkvR0kyMXREZllzZlZSMEZCNVpTTDVxNVZOQVlPV05yaTYrOWpzRm9sTjZ0ckVYZjNwcDM3MEpHYnNpUUo4b2t0QjVlN3h0M3V0eXNJTXB2UC9BSWtGcThZejY1K2tKbTFvbTFBbUV6eE0yUk9wKzhSNHZsZ2x0VWhyWDJUYlZJZDBkU2FEd1BScW9xbmhZa1FOZEt1eWd3cW9ya2N5L2MxbUJpUXR0RTJYcmJ3dmhFOEtmYnpDY0xjMHVvK3BaTHRseDBCck5mVy9DQXlDMWdkRkI2S1NVMFBSVllRYXp1RERscEFGWm10dkp6TTl5VUFpK2xNTCtETEloVVk1SFBhY0NHaEplVWJoL01WWmhSeHR5UEpiZmN0VXhLemV4czFScU5nSTJ1K2Q3MnM2Q082T08zalFRWVZDWlRGZnQ0OUVCZEpCd2t4aTJESjZ3bDJYSytnTVRrcmtDMXZjWVpnVzkwOFVqVTkzQzd3c01RbUc0ZEluOGF5eUl2dmlMaEc5Z1ZBOVdDUnBMWU5Ub3V6RVJyNzlsTXIwakc0UEVKeWQ5ZG8zWUY4ZXhMTGIrZXNWendadndYNWpuWkFLbzllZ3V6T1htY0JPNWlvOHFQMk9tNitiNVpSdkc2WC9OV0NxaGx2ZDEvNFV1WWszMzlldlBibU01N0lPS25SNUQ1dFNsRzQvQkFUaVNaRXdZaXlGTjF5REU4Sjd3OXJVdkJYcjVwTWlBUDczTXFXNHMrYk91Ym0xa3I1NHZTYmttcFgrRjQ2M3hwQmlTMW5vRjQ1SldLV0oySXRJRFZwdldPUWhKbU0rb0djd3J5c2xtQkdud3ZjTE5nZUFGSUFiWDdYWEJBdjNramRVcG8rY1drZW1LNkZXQ3FZRTlpbE1hZGhRdUhDcmh1WEp1dnhFZmxobXE3RkppQXI0YmsrZ1BkMEc3eTlDSUJIZlRlc1dMd2ZiRFM3N1ZuME96R1JFelBwYjk1VTQ2SFVwM2NOeTkxTmd1SjNUdStwWEkvdEY3dHZiUHBzbjIyNjZWSzJ6QmVYbm9WZTlaUlpZbWRkT2VPcExjNTU1WTROam9va1hXNkU2T0FGNFgxTktWWGlPdGZORG5HbmxGK0tXdU1yS1Z4MmtPZjlaeDczcmJpcGRxcTEySHR0TjJ6R3FnVlhHR3krdDFubVgySWxibzlUaktBYm9PbGs3QnRmTVBPM2xBQlJLWGRDaEFHUEFyQzZOWkdlMU92NlN3VCtqeFRmS3Z6S0VOQXhyR0FZRHRTR1ZnTWRHUVhzME54QUliNnVYMWFxUXZOcEROV0ExK1ozR0VBcXE1ZXk3UXhHU3hPOG9iVjhxTWlBcEFHQ1p0bHZNVnEyZ3VTbVlZdEVlR1NxZzBqZXVyUS95YmtVTWFuczN3aEZhaE5BNkVuTS9wQklNL09nWUZUR2hEbDFUdEdnRnRQK2NWb2hxQ2l5TFI4b3BUYU9iNkNJQWVjYjlMOGNjaXlER0U5ZUxJMGRKQzVjOFNLVGtxckdMWDZRRU5SRVdkOHlackRWR1FLZnE5ZmQyRm1ieE5YTW1GUlZjZ2hldU9xeFNpQ1RzRG9YVzFvUjRKbkx3bTZQMHZIMUtzSWhLRUh2M3BDZ0piaTAyRWdrUGFZZEd6OC96cWpGVWNmY3phRXpCSWF5QmZrSyswMFVGdWlmQ3lrRVBiU0pabTVJcEZMOFdnV2dIMXdaZEl1eDErMHFsdjRYTTVYT0k1dWdJL0hRdkJoQlQxa3VZWWU5NGo4UU1WYnJJQ3lUOEpsTlBsbjRLNTdrYldRZmhaVDJTYldyYW02SE1veE96TSs5QktOaklBV2VjMXVHcVpGSDhzTkJ2aktJRW1WWHhPSjY0citFWEVUcWlxYWVMTUxIdENsQlFnQ1VFd2pFT2tqdmxINEFOZDduVzRYbUZxcHV3RnRMdWNnL3JsNm9sWjU3aHRpV2xtcW8yM3RhbWhuUzV5ZUlWZVA2UFBVTlc2M3VRWEZRcU8xdFhFcVJsVzJ6a00vRm1tWjgvR3gxMDMrMnFta3hhNDJ1aDZVVzg4MFB4L3Nka3A1OXJYZVd6WE9MN1pyN3NYVzdBL3BLT1ZsejNHS2JacnNWclQrSU9zOXFKang0VnNFR2VuWjJ2K0NERnUwUFM5cWZ1VmFxaVMyMEZqckNkT1gzczZWdSswRm8vL0pvSFVzcDAxMjV1ZGJiNzd6N1h2cFpDNm5UWlNqYUs5TlNKQzVVTVRTUjJEa0pEVW1Tdlo2aENOb01PK21oTU02UnNHQ0s2L1dVVStBQnltM2xaY2hyNVd1MEFka3VSWWloZFI4VjZab3RlSFliRWVHVzl5b2loeGtkN2ppVGtUUTBjQlVnZjZzaEU4Q2lOR0ZYNjJHY09WaVBIOEJvend1NFVQbEV1RmZCSlVGWTJGaGxObXZvYWFxTlRucnNhMXZJdldGMnZFcncwUVFyQkUzVDk1TWpXSVhZS1cwOWpDTERSZEtHblp2bWZWbFNDaVlCRWZxdFJhelplVHh5dkRPZHh1V0crYUg1MTZMNExBb3kzV1ROUmJsWXMxS3N4ZzlpaTFFWm5hbU5EK2NZcXMxb1NzdVNFdnhVVlVnUFN1a0x6eUNrYnpLM1g4bUY3NFNsNHJJdGNEdFVOaFdWbWxPdmhFUGsrejNxd3huWVhmaXBFWXRvcDh4YXFqc0x3ejBIRndlaGpXME9wclRNWkNNanJYYlc2NFJlTlhOQ0RYdjBXTEVHQlRYTGlpZGc3U1d6U2RZRWt4UHZZMGtReXFXSVNOdjZCTG9maWQ1a1dUYzZFb0RpNitlMGdSVUdMODBYZ1FQRGQ3WVY0bU9OOThtU2NwQ05ocjBybCtuRjd3cnhzZEluS3A0d2lLQnFpeER6akZsTHRtVER3QUVEZ2RJL0VDTDVacFI5dWJoelV4bkxhTEgwazhWNTBXNFE4UzdCNGkxaFNDdXlGZysrWjllN0RBUHBsSzcrZ1I3eFZxNW53T1F1UWpOK1dtMkhJTUVZWnpuZHpYWFEwekRJcnpUaElib2w3V3Foa1ZDa1ZvRjJHRVhoV0hxMFZoU1M2V09KdWlUSk9uOXhBS1ZDTjczNFl1bE1sMHBpOFdIUWlueFNRODhVUlRsVmVUbC9Wc1dsV3RQT1h4TCsyakVMUXRMNVN5Q3Vacy9RVDBwY1JTblFHVW1peUIyc1hiMHJtZTJrOTUxWDdkcXRHNGZybEUyWlVSSmFxNzdEWUwzQkp1S3NweHRKRkZWYk4wVTBVR0tHSlR2MjB4bzJaZVRObEVlT1hqV0g5T3FOUWxoaElmRzFNWU1tcW4yRUpQRW1sM1pXK2RGa2E1bDBiS2kxS0FNL3QvV3JTVldwOXhYWm1YVkNMWGEvSWtHN1FHQWc4dzlJVXJnT0k0d2VlWXlOZ2VRdnFMdFBRSkxmd2hHc0QrTEE2bm1Db3RHYitiN2Y2MlNGcmFlYmE4NmVtczRFc29teUs2QllQeDdlaGkrVlZ5V3YvOXBES1pSbTBkbFNDcWlSSUpVV3BWb3JOV1IzcXdiTEFDY2xiZ1ZJZG5XZWExQXBrcUt1OWplazcrSWk0NXFNUG5HYUlJZTlnNnl6RmtUM3NndDgva3lSaE1WRXJzRENabkJBdkdBYmdsemYzL0JRaktOWE5sZ3paNUI2TWxwRHp5ME4zNzRVa2J5ZlRLTytrK0p5K09QYy91RksxcTIwb1BzeHYyK1VKWnZnSlFYUWp0d2F5elNMRTZ5aXRUQjg3Q3diaXl1TCtXV0h6MFZqOHZWQnpOaDZQWlR1c213TVhVTWRDUnBTK1B0OHJiRjhwRHpRc082L1dOeXEwR3Nja3UvRVo5aTgvSU16S1FpQVVQWnpKWUN3dldzRGFEelllV0YrVmtLYWRGbktlZFdpa05LY2JrN1I3YUpiSlFNcEhITklEZzNQWW41eTdwb3g0eDhMNVZBZmtJdVZYajBLL0o0OExRYUI3Y2l1TkRBWHowK05wQ09tVkcwSVFmbm9WOFZKaytPSll6MGk2dXFBN1Q5cVJpUFhvVTl6UE13eXJZNncyekhGbXAvMkh3Um9wSDBRSUhuaW52ajFPK1VmVGdEdFNMTmNuRGdRYzErQnczWWlPMkQycExIcnlLUzRsQ2xENTEwRXI3a1MxblRnSFRFdDNMUWZmbWJidnEzTk9pRGVsVkc3UGFGV3ZSdndUWkFvVlgvZTVBZ0hKWU5zL2xTSFlVd2xRbnQvWU1yc3F5Q25aWEkzb2ZNODFXNm9iRTdYZklxQjhHNnBNSUVGdmpjYVJHUVpuVTIxM1UxZnM1a3I0VExKdUs5QWYxbTdHSU9kWjVoMVJZditjclB1Nk42RzVsNWt1ZFcyTHIvM0RkVVZvQ1hIRXlLN3BHRjhSTUh2RHh0QnQycFBPcHlrTTVpb3oxQ0NtdEd3R0RWREE4SFNDVTB5TGU1bWhxRzVqOEZ5a01YVHJhVzJ1NlA0aWZlRlRJM3pTSXYySnlNVjVwbzBpNE4xa3FhKzIrNE9VdlQ1M3BYYWlKR2hneEExL2FWalFnb3NXVXM5MmVLNjlFYUhpeEpvWUNxa1pTQlk5QXM4a3BvSGVWNlJCeFRBTGtqckFDMGFQK3pEWEdvZjVpOWtDSW54Y21kLzhBTkZqWlZEMmJkVUxsOW5ZVUE4bEluVDRhc3VTUnFMakxEWjRyQ00wZDVKc05GczE3enMyc2R3enJMTEJDTEZ2UWYzdzlVVzFNdFNjOU9MQzh1QWNQdDBZN1BaUUxuMUxucWJBT25MS2xtZjlhMmRhRlF5Q3ZhY2VSblVzUlVmb1daQmZzczhwNmpFRkVibStoUFFHeENsbmFZc3RSOFpzSEZMN1UrS2dEMjA5QUhFSy9hZEZMWHJSc2xYdDhGYXJqd1l5OExUUzlZY0dSdzlxdnNjTDBrS1BiN1ZIWUNPaVdxcGIvNXNDRHIxbFZLU1J5V0pwcVVjMTNIYzQ4WVYzSkE2NFlwUkE0MGdiSkhWWUFvV0p5OWxhUWt2TUMvR1ppZENXVDQ1bm1Rd3NxWnZRRUFRR1hvVUUwYnptQjhGTmRCRnVqL0dVSU80T3JVajRQd2pNVnpIRnpGaS9raW5RaGhLdjcyelZ0SFcwUDBKbThzU3BWbndzVzRDYVIwM0VnZ0g0aHQwQVBHeFd0aERUT0phSStoY0NvYjVRMUdhblBBZDdKR2NCckhyTFF4V1dkVkM4MnJ6ZEUyakFvZDl1SHJEMTNqOU9kYXh4Nnh0c1dUcDAxQTIxUlJZVnUzVGVxV2RZMFpON0pxZFp6dmg4UUJxWlRQQ2dJUVIyWXROdGVaUC9TelB4bHJsMnBDbTNxUWE3Wm8wcFQ3Q3BxaWhWdnBxMEdIN1AzSVlNVzNKN0Fzdk43TGgxUHVhZ3g5NmNkYm5VYktHWFkyR09KeWV6a3lDM3BoWFp4VXRMakNBSGZ2YldJOW9TYmhzVUV5d0dZY0tGTC9hQjVEbWVJQXNCTnFsWXZGZ0sxVG9OdEp3MVFibW91UFRhS3dFQWtMb3Z2RUtMRE9Dc0dEeW41U0Zsai80T3BZMXBySjBybXhTbWJzTGdpNDRVSU5KZnVHY3dBVElvNzlUZFM0bTY3amlZaXhIeHFZV2JPdzV1WEhLL0tPR28zb2FlMG1lRzlTU0l1REd4bDY1UUZ2UVdZMnlBVDFCNDR3ZUdYVGVtNEk4OWFpRGo5SWdmZWF5eXRyQnZUWFgyUnl4WVJTRlRxMEJ5MVdidC9wd0RpYWZiNGlPWDNVd2Uyd01GQytmYUQ3RFBWVzNJVjB6WXBJclZUK1RNUHBTUXJOYWR1a3NPaTBFNmNzSmxnT3B4clZ1MEJ1QloyTElZRFFXUjBNRHVQQlRnWitsa1VNRFZWcWRPSDcxZ1dJb1A5d2hwZE16TU9PMm83UFFNUWlOWm1LNU9tQzdpaDlKNXZ2LzBsckxHVm1sb0gzaU90VUtERU5aNjV3N0swVS82UENhWDVmalYzS2F3eFplNG5yejEvWXFHZ3ZYOW9KY05qUldYTmxnVFptbFlNL0lBN2F3S3c2cTF1bnJ1V1ZoTVZxdERidnNoUVJ0bU95N0R2QXA5Z3BnVXYwRm1UUVMxWi92VlczREp5NFBWSklTMW1TVEsyY3Z3Nk9NdTZTZ0NybVRPZ2QzeGJaWndtaTRPcHA5bkhNNkZzc045K0NnQXZZeVZ3Yzdsd2VUYjJhK0FDYkRSYk5SSFZ5bGEwaG1lUjU1dW1MeDJhbDVHaG9GNkU0Y084TS9yYmtPOXZpRHV6VXhIVG81R1pSV2xEbnZqVDFCVkNsWlJ0RHBkNFlGV01OZVFNVkRjRm5hTUhoVnUxY096eFNwRGZITHVkeTl6ckNHMTQrRTFUZXhGS3lYNGJ3MHlJcmtpK0ZuczdCWFVsSUxOaWgyZWdkb282Qkl5QktucHpwdkkvMU5WVUVqTTlaNTNWWXRwUjZvSjBwNzAxK2dxTDdwMTQ0Um9XenNOUzZFdkZDZS9KZ2ZFeXRoek82NmtGVmZFZWJiU0xhQy9sYTY3SHREMFRXTzJMOXNrSng3dmJiWmhTNk5VTm1GcjV2cFoxbG9wZDFtTE5zaVFLL25mQUZuUE90bGJZb1crQ1lnaUJramxXeGZxa29KYURlOW9RaVVmN2VIM1dndlV1NTRyOXdrWEdydUlJQmRQNld6Q2RRSTlPSUcxcGRQQkNiQzNpWmVYYXlWVTFUemNwbEJoZVNWdnV2NCtnaXJsbnN6MlB1QW9qQzFnaVJzNHN0emJzUzFobGJ4KzJxaHc4Q0EvbFM1cGJWSk1VdnRPZ2JqdUhYckxIUm5EcVk3akVOME9IRjBjL2tvV2FTeTA3QWFHak1lNWNOMFJOdWhQTGgrVnF1VlhsMFZkdWRmUEtwY2FXMlBqQmxweDZGWm55Y2twTHJvZDhXNlJHL2g0UlF3SXQ0SEZYeHpPQ3NYN29oUXZDbG8vUnY0ZUtzTmJ2R0RaRXp2SU5JUTVOVUJNTlZ2aHFHbWxXY2J1bTVmRDkyYUZ2YVJwYmM3MnpqYjVYeDU0OE1pWGJaZjBrcDdyVFdiZFBwSW5VQS9nLzdORm4vbXdlQ3ZPMjU0SENmYkdYMm1IWmd3NUhaRFNQTkxONTlET1h0M000ajlPSTlyUDBwNktoZ2wvemdGSTFxYXMyUDE3ZVpkYmNhbXR6M2llVzk1dWRkL2I4LzdTdS8xb3JmZGR0aFoxMTMwcWplK3Q4T1h1TVo5THJqaGEyYy84cVh2L2VxN2Yvd1hQdm45TC8vRy8vZXgrUE9FWXBSRDhSUllKaDdKWmg1c0FkZlh1UFc5UFdCQ0kwS0czalV2YXRRMkpnMEhSMW9icjdUWWN5YTN2OUhXUHJSRUo5QjYzbkVNaHYxNXNKZXE2QnZmU1hHb1JJS3hvdy9ISzNTY0NnRzB0NUpQU082UjBNWFljMzFNMjBhRmFDc3RVYlovMmZ1UkdVMHZqRHo5NHZlYnRrNVlXWVF1elpkK1lRWVZ5SGR5WG9aYjJ2RTBGYVlkeDRYZU93clBpVmlwczNoaXpsUUVhYkJsLzNQWFZpVGFPZGZYT0RES2xGc3h5WDdEYWNaSGJIeG1DKzdmQjlUZEVELzc3WHlWNDJFcEEzS2JvOTBZcE1DbHZFVmRPdlVXb3NIZWpFcHJVL1ZFb0E3ZURNYVhjbWZGbVg1U2pYcjZJZmlwOWk5R2EveGZsNTdtR0I5U05RYzI2cG0razB1bWlSR1R4d0V0L0V1ZG1Ja0w2RGVqaFB0bFlkSHl4Qm9MRWRmbUFhOGh6TDR0a211ZGV4SzlldUlrY21zOEk0bllSOTNMUDcwWGV4S1Y0K3FqOW9sVWIxSjc4dEpGMEozbEZqci93VUFFVVZOck1uajcwZ1lsYlpDcXViZzhKdkl1QWgzT2RMVTdmQ3FDS1hZcG54Q2FBTjJOaXZDemJKMVQ5cm5EaE5jalVsQ09mTUNqbi9BZzZWYXJ5d3QwL05RSEFwS2duK29Rc0t3Wlg3Y2ZLU0RITTZ4WWxKWFNsOGVFa0dUUkZqVkJqM3hCV0VBZlArZ2V6c0JLNndmaUpGTCt3bWsybkpXbjJBYkNJeGhwMWkxSlk5MFROK0h1R3BWNUJpdkxsMk8weW8vRnJ6U2xuUFNqdW5JNGJUSlduRTZOY2krOGowV2hMTmk2SFZ1WFRsbU5USGN5bXRtOFZZTG1USDJna2lXZ0svUUF0N1NRVnQzbVVrVFNKckRlQVJnVFdKM3RVZ2ZITzV3bFM1NnJkc2ZoT29SRnRoeThrK0pZWnF6UlVjQmhUU25zb0w0bXFxc284U2Zyb3FTNUlkT2dxd1U2QVd4bWVmY21vZXFudnNSM3RicU5vWFZndU5qZnlkbnc3UkJ5ZVV6TngzQXYyUm9aVjBFRnlGbHFsSS9FU0xuV2J0WWNCdHBoUW8wNS9vU3NaYnFXV2RpWEJIWDR3Mk5aTlo0RjJXdEEzTXZpZXcwVmdTWUoyNFZRVkJpaVBNUVAzc3F4NEZORVoyNXFiYmhSRU13SSsveG1tWFdxcXdEalB6T3czeDRES3VKT2QzOStaTVBDMGNNbFJCdTl1ZCtMVFlUNnFpdjloakhrTy9TeXJYd29OSUp2MTlXK1ZiczFtY0U2YVVZZ1hMRjY5bE1iYStodHVxcmE4ekRhM2h0YldiaDVTRk9vZFRLTWszQ1kxNXMyOXpLRHJhaDh6YnVNeGxDRFJaVCt3UXVFUmJTbnU2QUxQOC9GeTk2d3dlWDRjQjdIQk02SmJISExLZEFNSzVhNGVpbCtUWlN5bUJXZUtnQ01XaFA3alpkN3F4NFY0S0s4dFNHaE5jYU4wQmdjUjQxQ093eThMMTNJKzlhQzh5NmozektIeStOVTU1RWlhNWhhSSt4VW9QYURQTXErODRKNTZoTktRbmhlNS9oYXBzT1RlQm9qclZKYTlETnQ2Sm1PSkt0R1ZhZ1liUDFIbjJUUjNJT2dCMkJlSTh4ZmpjN2RwUjVURmgwZ2NaNzNkSWFiRWZaNFFxRmt3cFNubmtkNWNONGxvV3FPVXhXVE1tbkRXRlZuRXVkdnNKUTBxMDMxRU5FbWtHajlrOStIRTRkNm9wU002dm1GdGlmSDB2Tks0QTA2NkZ6MDg5eHFWMDloU1VIMnVYbDJnNm85TlBGd3JxTFZWK1djOWZMVXlYcHhvakt3V1ordFpCSExqVEdxQ2ZYYnc4cXlXSitFS1hkQkxWNmRuMEdRUW43YVNGL0xuZlk4Qmdvb3BYRFE1ZXZtcmF5bTZlbVhNdi93cGxQWERLMHhUZDE3MGhweHZkQkxPZWVoYXg3dEpoMk43dVk2UlRzVzF6anRycWlsdXdPQVlXaGlmZUoyOUppQzlSc3dndXFDb09xS2k5MHdXUnBNY0dFZFM3MkREOFh4aXIrU3lwS2V3UHo3NjR2aTZTTDM4UmVVQXNQb3FRMGZubytvRHZRTlJobnlyWmFxeDJLRlhUWEM1aG9MQVRtUitGeWl0UlNXcE54b1FQVU1EOHdEOXZxM0RaSzdBSjh2aytiNzB3Tkl6cFNiVS9SMXNHRkFWU3g3VmxJdWlDMm5JUEFraThac2sxczRNQkphUzZGWFd1T1BQNzlrNWxNMXVnNVF5WUlsT3o5V0Y0ZmQzUVkxV1QzUUN6a0d3UVYvQXFDT1lKL2lNQithaVdoVHA2QVVxN0FZa2paOUFWRGJZUFdvM1FndThBTWl6R212cnBuckMrd3g2RjJZUzRFbVlYRHF2aGRPUU5Jb3pYSUlJamJqcDN0ZXZaL3RJVjNtTXZLV3FkazhZMy9oNExnRmlyQ0swMjhTdXJzWGhEL3dmQmJOQVI1TlpYamhOMlZpZXRwdE9ZRXZHZ0pNb3hoNUh1aWU5SDVtb3dQN2taTFZONUpJQU8zK0dYL2FiU2VLYVlNOVZ2NXh3Y2t3ZmQ1eUtJek5FNThrT28xM3JTUk5MNUdPYUlrbVhyTXhLMzY3WkxldGNjOEFqaWJoR00yZXhVMXdhUENzbWc2cWhhTlJJMWpxa0pwY1Z5aUc4RXgwNTZPdGJRYWhGZXNDSm5WaloxYVNlY29kU0RGTEYzRUxSM2VQMm5DeDFpYlBzWUR3WXF4NzdMcFY2OEZlVVMzclFIdTNRY2NJZkhRekd0YzNrUDhLSnV2YkVPQ0wveDd5LzF3Y0IweDE0UGVmcldkMC9FUDRmN2ZZLytHZmVlSzZYek9yTHZlWCs1Sy8wYjhoMzlOZjB0ZCt3QTgwbWo5Q3B5MXNKWDhBTlFoWHZQSERRQVF4bE5LTXcrU3AxRnlycVhaMHFubjFVMlhIZWNkMXh5TkhiVzN6UGwxN29ZN01UR1JxNnQ3WHF5WjBJamUxZlBFNjdyM251bWY5WHIyRTdQNWxzZjNjYSs4VnVGejdCWVQvSUZZRHZ2bGszUEFsaUZCTXhHRm5Hem5LTldkcmJqalNhK2FvV0w4d1Z4ejNIVFcxQVgyNGEzVkVXbTVabGxQZHAyODBFNzRoRzdPbm52UHY0M3BhTDk2L1pQekZmRXNkNEg0SHIrQWovMGo5bHlrWHhQLy9jeFJFaGpRcDRyb25kVS9vSHRjOTV2VjczSXU3Y0NmdXdEd3ZQNXh3d0E0bGJyd2U5UHpYMU8zWjF0Ti9XcVk1L0JNT2g0UGhRTmp2VC9vcDMrTWU2cys2YjI2azZ3RFhJbGVydStJdXUwdnVvcnZnem12K3pKNk82NkVmOG5IdEI2Ly9LdkMwbTcvTzl3Q0dFeVJGTXl5NC92K0NKL0dueFdlMTZYcDdZZ0EzK2pBaHhUUXZSK3R4OXM3dUgzMEdrM0dmQUR6MEMrQ3hYd1BmZndsMC9ld2RVT3JmQWRyODkyaDVib2twWWFXaUVLdWpRckZ0NVVvVlFNd3hrNi93UmxYRitXQlN5VlZReW12T0ladnZUUVNCQ1I5NDAzTVdnRlRFaXdPeThjR0JlNmFIeUg1eVFVTGtpYnhoeXpGRGpmZDRRejhRNGVLQjlRQXdVYUNSb2hLYlJueGdnZGdDWVZHVTRmenNtNllTclUrRC9PSXZtemdWa2lSNjRQQ3RDZklJc3lJdjFJQ2dWb1FwSDRvbG9EOUhvQXVhUTgwMjF3OXI0TDU0alFFYnYxeERmcUF1ckc0UmE1RFd2clArTytNcExJQXdLVTFmVXhCdzhZSDZWU3R0NVliRVI3RVB0RytOTkR5U3NSd2ZHTDJvR1VTSUlXU21VV2xPN1JjbnJtR1FDV1lqTTJEQTZFSUhBVy9iMlZ5UzJ5UEo0Y0hIWmNyRkR4WmxIVlZXUS9NVzZvUThjQlJObytqMVQvU0tzZmhZQ3lxQW5ncGxQeG1ocEFLOEtWK1pFQ2hoNlUvbTZBM2E2TFNVVXJyd3hvMEZHUDFwQzN6MTVYcE1EN0g0emh4RmlPWjN4TUNBWXlvVkl6a1ltTGhmN0RKdTVwcDhFSG41dUw4Q2oyRE5HYWdyK3FSZnJvWjhZTFhJQ3NiTlFueXA1N2ZTUlFiOXh3bSswNndzQXFmRTFyZDlpS29rQWhENENwbEpkTDhmNE4xSThKdEJQeDBnK1RCbDJlMnVPUVB3U0MvZS9GNUxuekU4MWpVOFRuNlRYVDBxRUxYMmdKSFpLQ1JTdWtVUy92NGF0UVBTbGhaUWE4bmtVUXFrUkNQK2dBS2hxaG9wNmdnWmxzTE5NU0JvSGkwcHBabkdoMlU0L3NIL2YxYmIvdU9WUFN3REhNVm96L2RyWlNsOEFPaEJzWmQ0eEJOemRIbUhMUHFwbEZyNndUNUNiMER2dVh0NWZoeDFhaWt5dkFpSnVBYytLcVNsb1cyNmpra1VUZjFhQ1BkTWxPU1U0YXYxQzFFenYvR1VqdWEyQXEzVWY1VVdDcko3WUtYeWxGb05DVFZRekJwM2N6QWdpVlZSQ1JtQXBpYTVCTEc4TzhNd0dtU2VHU2wxRUZtcW9jandOd3FGeGViZHJCTW5vRDQwcFI3WURua0NYaUsxSzFGYlVxNGRIUVNoUTBlYmpWQUQ2TVNlTW5oSnFUTHpROGRpZ0s5UTMrcndlZWlMTDNuNVcxcm1MOXI1eXpJaWtqTkhSZ3BYMGhVbmZad0RqUVhnM013L0tFVkNsSlg2aEFNQjlOUVhScHRNZ3NoUjZTMFg5T1BIRklyYWZJZHovMkxmWlh2WjVYTVlNRHk2c1RFL3ltQlNVV1p3TUFySkIwR0dmK1gyb2lQc1ZoVkx3WWtMTlp3QlZXL240QWZJeWhBb2lOT2VSdnFJMFJyczFENURKNlFXVmFwQllDS0RtUXo1RlpZbUV2aDc5eGI2UlJNU2NaQ3BVWDFxVVV6SEhvdU5DQ2k4ejkvRnNsOERLWHB2SjJVcnVhakFMVWp0TG5oREZmNlNwQ3JtY2pQT2JEMzFTVDdKblNEZTZzS0Q4WDFFOXJRR3BOUnlJcnpBczdoL2Vvekt0SG9tNnBYWVhEUFI2dmFKeGhzcWlGM0tZdldpaUVoVUlwVTdQSGZLSHNzMkhjSlIvUW13eFlpSzFiSWdBMzNzcnc1d3VNaWpwWnhKcVhFZG56cm55a3B6dXFBSUNuNmFhKzBBeWFNb1MvSmJmL2NlcG11NHQ5aGlCQmJua1B0alhQdW1sOUd4eVRtSE5GdWR3M05rVC8yaG1vTktheDcwV0VhN3dHb1h4NVZJSTB5N3RRSEhvaEV6ckRaMi83MzgrWmxXa01QSUdmVUlVNzJJOWJjSUhOSWw3ZHpUbDBCeWxCck1aWjBDcit3SHB3ZUtONkRPVFFaYmZaV09qdGQvSWQzeWEwZG9VNEcyeFp2ZW5WZkpJbk1tUG1oUEhEWWkvK0kybWp0TDAxZG00aXM5NVBGVlJ3cFRjenNBNnREbTIySi9Tcms5TFJCOU13MEpIU1UybFhZMlRSbjFwRGRxd29WbDVhQlRXcTNmM2R1YldWTlNxajZkdXcxS2pLOXc5UTFJSWQ0cXRhZzJrRzVNWXpwTTJwYjdTM0xWY1hwaW5mSlpwS2VPNTJ2aE9mK2d5aHBuV3RmVHhWaFpDM0ZXTHFKSkFLZ3ZuK3FRaWhKYk5Kd1cvRGk4WGx6QU0zRkpqQ284Uzk2VjlTaTFhTk9MTEUydzJ3TkI2aXlGNzJTWU9yUjBLME42RzFhaDF2dkFqNnZwbEVtUTl4ek1nWmlMaW4zdVo0c2dYcllHeC9pbnpaWFpJWFdUUWxRbXJuZUVQZ0hRUnBoZGg5MzlCcDJnWkNJQVpqQWZncU5JOWRoMjFyWHNPWmE4d0ErWGRVM0poQ2ZtREJ4TlVpMUIzOUMyZ3NGa1ZxUWZWa25uNnprODQ3YXZVTmtQM2lGVUFrc3M3Wk1QM2cxMldYSnVQM2dLSnpYTExIWE5xN0p5UnYycSsvN1ExdVFsVWVlYnRwbThsMW4zQXB2MkVJUi9JazM5MDRqZlQ0Mmt2Tlg4QkNQb0EwUTNxWjl1d0FucFEwaDIwWnRKMnZUSEg2RUxHL2thYU1LQ01QTWUvdWFMcTBIZkJsTVJraGZMUWhNR1VLWGdQMnBpcUZtTDB0U0RrYk82SlRYTjJkUWlxY0MxTkl2Rk11WEErTUgxeXB6ZXQyZTY5RnZTZFNuTGtoZHJFWUEvUThDS1NxU1o0V3ZwME5uaGh2cGg0b0lIWHduNHZEZTU1QTBidlAwWUx1MkFNTFNrVE1oeFpOd2doTW1BQklyTy9pYzN0ektuc0xuTDdjTEpyRy85U2NaQUFuZ1NWZksrQXl6b0tCRWZXMFpiMExBRWxmd3FscWtiQTUvbE1PSmg1Q1RmdXI3bE9ZR2R1WWYyZ2RPMWVPNktIVWFLUEdFZ2REWCtQQzlrRERXMWQ4SGM1Y2lLSzBBN3ZJMU5MQU9jS2c4WStrVHJFSlh0WVRFVWhid1c3bVVYNGFsSzBGaW1wRi9RcEVDcUZCUkl3QkNpMGlTMVZLaWg3aEdaazI5OFNWYVdnUTZXTzRTaDAwWCtjL3RBdDVMYWo5YjlsQzd0OU9zVTZiQ0xYWHByZkZONWEvZzVaQjJVSVYzOWVzSGF4dHlieC84eDRCdkljSGtqVldBYXVwc0s1Q25kMk9HQ0t0Z2Y2a2h0L1IzcEJSWTZxR3doSzdBMHE4WXd1d1RFNXdWcVQxM1NyR29qeW83YkFvYlJnbGJabzBlSVNoazRYbzUxaEw0M3RhY25ieVlTbFlhSGsvcE1MVmtjbDdla2M2MEdWZG5RL0dJS2xHeDZZbzRTY0hFeFpRUkhsakNrM0VLRHI4Yy93UjVac1p1aUhQbnBsK1lkRlRGZXc3eTdZdTRhVndrZjlFdktGeCt2bDZjUFA1VkJ3N09JR2h3RlN2TlJjRUFxblpybU8wVkZobHpGM1habndtK29xSTdzY2hCcEFobllJRVpSR1hvQ3Bxb3hiRHB0dTBOQy9Gcys0QWVpNzIvQUdCSVkvdUYyN0xiVHRGYkQrY0o1eUFiV293K1kwMGEzV2UxZnZaNDNVRU55cTRQK1BBSjFxa1lzNW9CQ0pDejB1QU1oNFoyTWhySlRDczQ3bGtrNHRqcUhvRXVRL1RKbmFPL0pDa210U1Q4NEo1RFpwOG1SUVJnSXA5MWVmbHJqS211S1pKNG5VVHhNaU5CQzJCdmk1eVcwYm1LcnY5Z3I2WHZnWXNFaERLZmF5SmFWcFZXeFdBekxkS1Bwb0lNQkhiekVON1VQVTdzb1lORHVBSXpEVkhMdXdnajkyN3FHOXRaemFOdmV0UDNHSk5xc2EyQ0ViSU95bU1iWlluTWEzcm94RkZid0szT1dsMDd4RFI2Slp1bDJDMndodGxhV3JDc2NBY1dBSDYyNkRQQThGeHNsM3paQ2h0K3pYY05LTjlEWDBjcWRuRlp5bkpxUUczSEVRUGp0cjY1aFNFS1dROFRFRHJBTGdnZU1GeXlUWUZjN3BTQlFFV1VpSVFGNlJOL01xQXNqd3N1Z1d4a3BPZUV0WXJiT0NqcHlDN0xnWElxZjlTb25jS2ZoTkhJQXN2QUNZQVJpRnhKdnJlQjVkY3hXR0Z0RXA2azJSeDlCaHk1a2dFNU1RUllpemJmNDAvZk9OMnYvR2RxRmxwcGZZOVJaMEpjRVg5VC9uREpBdEppdEdaYnBZKzF0UVZxa0ErRklVZHpmV2NBek13OUsrdXM3UjNHRDg1bTZOQlZmblUrcG9ZZTlXR0RBOTA1NDNCZjBhaElVdHF1ZUk2MU1iSmsvclk0dDRkNUxXMGs1UUh5dU14Q1NPZVd1Qk5aazdGdFRpd1d4SFYzSnhlcGlZUEM4bzBwOTZ5QXpkRHZaU29GeDlkZEJTZFlUUVY3emF3THhqQWtZNGdnNDBCOGltMlUzc3Fsai9sbGlHY29EL2dmck54NFQyaFJZN0c2S0ljRTEzQjlkK2hENGJUeVFPQkFjRGVkbUplN2ZXeUNPVU9wVytvbUVOL2YrLzM2YktBYTZXdWhERDZjV2N6d09qVkdrTEFRKy9Ba0dGbU5rVXdLQzhzY3kxL2Z5UVFOY25nVno5ZlIwNVYzc0srOFhGN3ZOLzVyUElCbEZyUFhRaFdvRXpyZzZSWUo4elFsMXV0d0dETFZMYXZ1YWdoQWtSZkdPK2dkcjYxNzFhQitReUVGcW04aVNiOTNVVHB6SUt2Nk9adG1IWjUyRk9YTXNabzdZc2QyM1JtdkUwZEpmVk5kbDJjTU5lQ3JvQnJBVnJtT21Rd3RyUHFIVFNHc2Z0NjZEYzRQSmU4anFpalRBZk5CbmVKa1gyMXJOS3AvWHVYTlVlYjV1b2JhbnlBNndDNDI5aUdjM0R0ajk1RnByODlTNjFmdWZwZVZoeWk3L2NOTnF1UjIxN2tyOWNOOUFxR1EreVN1K1BnZEdEU1R3SnVPMEs1M2JPMWROZjNidVpjc2Z1RXZWeEttYU1TU0hqRXFCTXE1cURZb0d4UGRlSHBKQ0pSaDJuUVBFd0NnQWM0d3BEOTE5UU1LaVZHeE1FSlVZR3Z4YkVNR1pLUnp0OGdSUGJ3THZKYjFLZHBETmpUZ3ZEMFVPWlRqcGxpUnlzeEhETVBBSThzcVVaTkhVK2dsT24wazVscnZPTmpDU3BtMmNxazMwZGpYbDIrNmIyMlRKekxOMjBXbTdiVldWVkdIdldZdDdXYlpTc3ZTaHJuVVd4c0tnaDAvUEZYckc0VDk5dVMrUVNwNDBiTXQxbE0yWFIwSnlhb0hjSHhLdFlUZ1dLNkU0WkFsVlJxNEVsQnR4dE5kM0NZT3JCVzVpNEl4b1N4Sm1GUVBaTWlOUE1yYnY1TlZ0WEFoczNMTnVhdEV3ejhSU2xRWFh2Snp6N05QOElDazFSOWFnNzJuREpmWSs5b3gvekRkcFB5c1ZSd3ZFQTUyWXNxVjl5cldkckwvNFlkNnY3bzB1bmZHVUtyUVBTWWdQdWlQc2dHOWtmcGNjQ0lyKzdIaVc3NFp6cFlFZVROMjQxMXkwcGFrcjNxL1QvTTFWeU4xa3dNQk9sQldtNnd3VFdNdEx4QmtaaW5lT1R0SkFJK2VvZ29TaGZ2N2s5ak9ncjdXbmNrcW15WllkZk9iWStnYUovblRrZlJMdkhtZWdOMTN5OXFsVW1NQnRZYWRiWGlTODhoV3lmejIvdFNXblVtQ3VsT3lhSlBDOC9oMVJZYS8zclM1T3lLeGZIeWNVWlBpWDFTSUtiV1ZOQy96WlNrVFVnY2JoVzJuMGdUbm5NR0pNQWhMTVR4cGpHYWpPY2ozdjhaWXFvanJNRXBtNTZjS3BZK2tLUW9aZUJMbDV5bWdtZjFLQWE0NE1lWHZZWFkvUVlXUU53eW9RTVFoU3NGdzVrUVhvQnl0dUxTdFRJdmRpV01QQjBIak5LNjY1c0Z4RnprclgyUDZhZXAycjk3MThFUHNHcVlUNmk4R3IxT01ibVp3U3Q1VmQ1NmNIRXdNOXkzQmlvc0U1WXJhRXZha25GUXV5U24rZzEzeHozbGc3bTZEbS9uQkd1QjBtZ25kQ2d1NEtaazh1bGl3MWxBdUcwSU1NMTNpNFFvbTc0SElwTXJnVENudmtQMFlSaklRcEdxM2lQWGptdFJUbXhEYTBaWWxGUlhxNlROWlU1S0sxMktCUkpsbHNMeHRMSnh2Yy9YNmlDbTFrbFd3cGp3K0N2bVNkeTE2d2grbktmckRIWUNQaEN4bFhBWnFOMEJ3OXd5eXVmMTRRZzg2Qm5mZHRKU09lSDdOajF5SWlvUDVtanpPUUx6NitYZFJEeGhsOG1vRzVmdXdTN2p6b3VNZVZnQXdjUE5OVDh3WFIydUsxamVRQjFqRkE3S3FHUTJDSitlNU15Y1luNVVvRDA4ZS92YU5EQ1FqT3g5ZjgvQTBHZXBNSkVMdUZFZktjT3pMTThsTXRueE9KR0tRdGxjVHFSRHZZYmw1S21uUnllWTJCSHZjOHgzblRlMG5abXlHZFU5WDVCUVBORFk3V3ZwR2F5TkFHSVM2SzA4VktXWnU3YWlIQkZ3SUpRN0FPb21ZY1dRVWRMR2ZiMllJRkRwNlV3VmdFTWUvekNPRXMzV1E3ZGFuZXEvSHFnQXdvRkNxK2M5SjhRUThaY21BZVAyRTZNcjZaNVJzdlhpd3M0djhXZHZqRjV3S0VudkIzU0p6STdXWlRUNnNLalkvbmhvVG1wY1BheEpiWkZuUlUycWJxN1NaTHpGTGR4UGZpN0hucUl0VFV6cXh6bFU0VTB0SU0vbjVqeFFQbGhIVUhLdXhVeUFza1dyMUVySS9oL1U1UkJvRUdYbFZuRTNIQjJFU0tQVWxvSzQrNmhjaDhkZTZxQVdUMXpHbTRaOC9yKzkxWFBUdlRmVkU4TjhIZVZZVzdVblBBeDlYazhXOWIvaWxXMzFsb3JJbTlRV0k3TUNld2hnVDM3TEUrUC9kNGFrbUVHWUt0VldBamw1UWxxTWhBd0ZoOHFNNDRxYnFBckI3OWlFeFc1N0ZnZHUyYWQ3Z296Y3Zpc2JYaE85VUg3aFRpRTlVUGNUZlBEajhCUHE3aVVWZ0Z3UTZFNkQ5VGdlVytpMlczN3g2aXVyNFR4MkJ6RXNMcjdSUGtNSWtVMlpYZFB2OEZ4UENhaW85Z1Fqdk5BMjNoYWhMRkRnVDBBc3RESmpJWUE5MEVZblBCa0crY2tRS28zbTVsYW5LeGZ3cUZWNThPQ3BjNVdEU3phR1FJNXVMa3MvQUkvRXBHYXFOQzZPSHpkdks4bmdFbWFkaTNiMWJ1eG9TOGZsNzNFU0pDaHJEVks5dWtTSFp5cjlwV1psR0FNYnNJWUJzdFljQUFQQVFyZnFuZk56aHlHVU5yTCtmTkV4SzBvRDJIcWlwZXpNazhYelV1eEJFWkRWbWJnOFVMbC92TkUwSWpQQVhGQ3Brb3pOVDVvaFpRY2ZzcDRySnQ0V1ZTRVZiUUp6MkkwYkxuQkdEcWdiSzE3RVVtRjhESjU1dzVTYlpKak9ET05RWUtzdmdSQ1lXR2VicE4rS2paekNhVE1Lc1RaUE1PbkFDRjdUWHpXMkFUcHdiWCt4WnBEODN0QzNIM2dkTWxuNGFRMjlUaTk1WjN4L1B5UXpibGRZeDVZcTNiektVR2VuTmJmc3dKYlRBVU5CKy9tenZiRGR4L1BtbExhcVM4dDFZLzMzc1R3NXhzanF0QUszWXcwSjRRTzNtdDdWWEZUU2ZTQmVUYTl2ZndYKzZPdGUwRTloTVZaa2xpdUNyenUxcGtJSmFNaUlaWnVDNXlNY2xkS05LaWpJUU9CMGNuZHVuTGR1MUZTQWhQcGdacWtPd2gvdjdKcE1nUUJPUHRhRXcvdEZnajRpVmlNZmVJdTk4N0JWSk5tVUlFUDJRQ1pYbWJNVzRZeG81VWxqZ2RLUEdYeU4xc3hpejlVTzArY3I0NndZY0tJSW56SUZXajhjMEd4b3N4OERiZTM0b01uSUVRY040bWs4UkVVenFiNFVSSDduU01MVjIwdXpVbElDeUJ1RFBFTUNRTjZDaVArVWw1MWFpMGpYMDYySldDNTZSTnBFUFJGMk1TbFRDVVp6VmtrbWQ3SUdIMGlZU1UyY2kvYm02U0dOaXB4YjBiRUNzbjJFdTR6bTM5OThFSFo2REkzU0xQRmZJZnQ3ZGhzZVRtTTVuYkdMb3JSMGt5WVlDWU1vcXh0aGlOSURmbzEzYlJvcFdnaE5lYjFvbEJHNjZtRitWdGxnNTUya2V6NjYxVmRhMTlvbEM4dGcvQk5MRzFCOCs4d0Vua3hzT0I1UUgyWm8rRUpYbEVGM1Z0ekROcHB3YjV0UkFTVVBaSTFyZmlQTVV1RW40YXVUcEkwcGhWM2tiVkNOd2l2YjFWdjdNMCtzV3hsVEkzOUp0aUV3WVc1WHBiMitRdy9NL1BXOHl3QWJhUndzU0pzMi9XVnJ0RlBuTSt3VnhUWXFtWnpqUXFzQVNWZzZHV3J2c0F0akxyYjU1WGV6Y042Rmx4QXlYMWcxUklpQmgrQlRPVUVpb3JHakRrSWVsdUlPNjkxN2kzTUVGUElxT2JsWUVXd0tVUEU4TlhJYURtYVYxakFkeUFWSG5EQTVhUnJsZU8zQnhvZFlnTU5nWXNxdGkrTWpJalpxYUpCSGNqd1EwQmNqWmlNZk5KWU80QjV2cXpNdWV1TzZ2NmdsaVFxQnkvZUNEeHpEVzFBdUw4ajNGTVFOaCtwOUxValgwcjRwaUg5ZTFKQ281b005YzE4eGlUb01YT1hXOWl1NVJFNzJra2N6Y1VCd0pybFZSdU1JMWN5YVlFTDZ1NHZmaWg3cXcrV1JCWWhTMTdTdkZ1MW1sbFh0ZUJ5SUdNUDRZSmc3cEgveXlIeUNzQUUxUmFsV2FsUGRJaFVUeUR6bEpidyt6a1ZxLzRwYXZMU05DKzdiZzkrNjJWcmlTNE9ybXhGcmU1Z09GcVpXOTIyYnZUSGV6NDBZY2tjZmw5N0l0S2g4UVMrY0l3M2lDOXhjM2FoYm5DTUtPN0JhTHdEWGRDZ2F1eU52ZHNFOWhlOUp2OUJaM3JXR2FMM3JzdGxUZm5LdDVFcnlJcjdpdkxHSkZYZFp3OE03VGc5ZVIzOE5TTFloUGppOU95VmdkM1RpODlSbkszYU1aTTJrNkNjaE5YZ3h4aEF2ZXpEdTFBSjdlb2tOSHZHbXY0cUdHaTdXWEhqYVFaUjBZbFhwSGpkM01NbkxXcEFQMi92RTdlY1lmemEzTXpFVlVsalFxVHptQWdvY2RkRE5EeWtTM09lemptZ3RpUnJaSFhvbGdOYkEzWVpNbFJHcjRUTHFVazhwVHpVK2FCZlFUc2NGbFduQjJpVmpZSksyUEJIZkwyM00rSWdJdkJRSFF1VE9sblp4QjlDSGRCQjIzM3ltcHRZYmVMWlRvSzNmNUdZQ3VSamVGQjZHRWZibVcwalQxQnRpV3ZSTGhIMTFIKzdlWlNEdUpGY2dlWkM4WTRzTWluVFJzcExtcXlJWDVQVVBZSDU0bzd3VHdNMi9GNVJBdDAwTHRRV1I0Z2dhSkRoT3hwZk12Rnh3NmN5bEovdHBmK3Z6R1dpQjNrZmJhajNNWktIZjF6SnZiNXozbFozSGdudEtYTVI3Vk5GTytEejB1dnZtdTlNN25Pc0w5WklZbGp4WEtmZE1DeXEwUFg2a2RTYjhjVVZwd3VldVA4ZEl4OXJidllHMjZLakUzNWlINkxYV041dTJCS0I1Q3Q3UWZ2MlJsTy9sWk9UN01mU0F4d09uUnlidkhGenF6TEpsYlQwYUh6YjI5eGxDMVk3aUF6Z1B5Mi9ZakNsYWFjVHN3U25uZGxJT3dCZzdOempvaWVlYXJQWEIyTzJNRGJQSUhZUE1Iay9Ea2tpV29hQ0Ircm1zN1lMUFExMlJ5Ky85TG9RdkRTTXRNMm9iMkxVeFdCQjVnaXpkOHRNRzlMR0F1MGxTcVUwTFBtVWdVcGZOdGZoallJZXlnNWNnUzdacXJBeXY2TjQ5c1o3bWdJM21iSmI4S2JLc25jQVVQTUFqT2xWSWREL0FqM2I4VksyYW1QUm9aZUwyQ3ZYK1NlbmNMVG1Va29td3NyK2QwYXhheGhWR3owcGVXbXlDemZyNnFxcnlVOTZldENvYkVuSDJWNDFWYWFPN1VtNFVQby9Ic0dxbXcvb2dhRmRTR3FHbnFOUE5Ndmg4M1l4QTZ4ZWtyV0owcEtkVkhVNUVQQmlPQmRCNkVzdHJXSk1kaXozbDJybWlXNXRSbzQxa2JYZ2VHQVQ2Si9DeUVsaWJFTmdIYlZOcDJ3cURsMWdnRFZRNUNRWVcyVTVOQ2lzUWJOWVRxek5QMlpXTnhMNWs1WndmaXdzcHQ3VUJsNTc1eEJGZWJjMFg3ZVdXWFRieFNROERiM2RXQ0VqNU9KeGI3TzR2QUExc2dmTDlaYXREVmo5a3Baek82WkN3VGM0M0JrK3Rtc2NGWWNKYWd3VDIyVnEyVkcwcldKSGZJbkIzYUtCcTBRQy8rWnladzExZE1FNG5EeFZadmRIRUx4WDdBWlE3S0hrQWtkemw5eGRTMDBkcjNUR3NaSDQ4MjNwdUNidmJGUSsrS1N2M0NTSER1M3k5bDlqdlR3VVBXOU0vN3NNWHp5NHVESWNQM2QwNWErUFkwK282L09LbDlmSGFKc21vK25kVVh5SG5wK2V5d0d5TjZ2Yjc4TENxRjhON0Rud3VKTEdKc1o3bUUvZHlhU0QwYTBqOEZrVC9pQ0lZTXRMU3l5WnF0YWxNeWpNVkJaekpZMUlDUnQxNjl1dldDN1Z1a0MranphWXhZV3BPSXVReGJEQ3ZjaW9lVVJYdEFYSXlRYVNZT3AwV2ltaGltWmQwUkg5eFFZQTc4Uzc2ZUxBSHlaK3dRQ05uT0NObFpnWWlVVkFzVGdXTG9HVlVqeUJ3M09vdEVaTk5qSEFZb0VEY25XT2RDdWlFMEg3VFliR1dseit6TjVIcUsyb0NXRFFRcHJPRzJSV3UvVk9qdHNFNFJaTG94eHdxYVVIVmt6TWdkR0tLTTdWeXdONFd2bzBJbnFqeUduMmp0QUFrNGd3c1piNmlqUFI2TmkyWkdwUFJkeExjTk41dllZbkVuTG5BVDJ2UC90czRLS0FGdnFNZFNSa2ZwaGhHVnpDWmxOdjVqMUpoVS9JaEN5TnZaNFd6Z1Zra1U0SGttTmtoTXhUV3QwaU5BZjYyV3dHR2FZK2hCcDhFTWNwV0d6dC9pQlNEV3J0amZIenFyK3VvYm1KdGE2ZlF0aUk4bzcrZ2pyRXRidVptOHFoOWZac0tjUklsdUJzN0JNTUhxemt5TkZTNmVJMUZqWkJKaEduR3cvTFB2KzdUSGhlUzRHY1ZPeXkzSTFlRjhpVlJFd2pFbjg1V1JrQ0ZuamJvczF3QUNXdnNzcVB3VXRLbzJuYW9RR0FZcEoyS09UOUlaRUQ1aStzWXZUSmFibENHQkttbWdNRkE0WTBNWG81NFg0SEp0OTJ6RWRBK3NSdi9qRTNvNlJKREx0a3NZOTE5dlhBOU9aMlNoVG1jb2JtRFdVSFhhcGNOcjQwMEZqU1VMTVhUWWR6YkJyTUNkUmEvS3V6V2dHcm8zQmwxNWtNcmUxQ2JMM2NWQll6OXJxNVdmbkZqM3Jzc3pScmpnbllzKzVWK1lPUFdhZC9qanpTZnZNUHRoVDl6WGNZL0RvdzFoRnM1VkQ4clBvODY3STR5S29YNWlPTCs0MGtqaFM3VHZ6UHB0bmNRSCtRQ0c4N0ZzRXgvQ3VxcWVPNWhkRm01cy9XZmQreEQ1ZjN5R3gzTEViYlN6bVVQOU4zVkRGaXMveWN3NjI4NGJuRjdQWDNCNkFMMjEvYi9XNUUyeXJCeDhkTVo3cEo0Y0c2V2E5OXNZa293TksvVmxOOE5YTXlxdExwM0FzeXFZc3JaZW80RjJXY0s5eEJaV3FCQ0dNcm8zL1R0dUV2cXJNcmJBcGlkNG5KcHVLUXZDUjhQWVUyUnQ5Y1V5dlI0NEdlOGN5YUdFMllBN2l3d2duZjRvRjEvbzRCY042N3hNYmZhMVRPUG95TnhnR0xQdVk1dzIzZ2FIb2I3aHl1S1dWSkdvSE53RTdhaFhvdnlUSkhkRWZBQXhqd1VrUCs3RGhkeGhaMFAydjZXMlVkcEhOaENUZWhGZzVlT2djRVQ1VXBGeUVleG5ZdVlSbng1WlBKOURYd0dya3RCVTErU1JzbkpEci92SHBzZmQ0RUZ2WUk5R3k4dk5pNHlNWXowbmNibzU3MWI5UnJ4Zk1YZERxWTFyNUVyczVpU3R0MWd5RUxxVHYranJ0ZWg0NUtRUEVNNGFwakVFUGFpNndXY0VJZkZmUy9ubjc3dkhrc2Nhbm1idFBRQjlPSDUxUUFyN1FaU0EzYTJXWm9xU1Fkc1lvSWE4eEZZUUwrQTk4TUFyZ3JzcWRUKys4c24xK1VqenZKVjRWaTJJRnU5blU5TUJDSm5SR2xUWHNFNzNQNnF4cnJtb2gwREJqdVo3QWRsRkI3aTZDTERuZ2VUY0E0SUkveE9RYUE4MEpKSjJIQXdCNU0rNE5NNURnVVRnUjlqOTIzUkF6cHJCSjIyS2x5bjRsZ1N4OThoV05BQXFFY0FXMlhMd0xCSHNwV0ZDNEZnTzdkWFlWRGhlbjlDd2pBbjJURFpaQmxQYVdZV3Eyb2dIb2FpY2xkMHJQbG1xcit5Yzh5WjlPSWVSOFlWSFJ0T1dpVzcxeXhJa1N0WTBMOWhoTnVnZnc1Tml4Z1E5dnlNd3pTNEttOGpIWkJKbjhBQVI4WEVzeGthcWhmRU9BajdyeFdpYkdNQnQ5QXRNRDIwR0dWZGkrbTc3WDNORVRJK0plUStPNjQ3Tm44NE5FYXgxY2NZOGRxRlJVRGE0UkE1ZXY5MUNxR3MyNWdDczc1Zk9aOW1aWEl3dHZxcHkxSjVmdGZHM0JxNHRHejRHR3BvcG9ma3prMitldVg4dVV4ZnVnOTloYlVHbjd2a3VveG9jM3NYdDRCdVpXM3R1Qy9lU0VvdDRIaUxndFJabFRVcytHTFl0TmlublhON05UZnJ2WW5mNWFZQkZYenhhakxxY050bTdaay8yc1dUUFdaMDNLbGxDRHd1TWFYYVpKZlJBTU5qOUNmRzdGWklRNG9rNlJKVmdsTkxIU2VZbFZ3MFJPMUdQNDNwOWpHb3c1eDNYY2RRY0lyK0ZBQVRQdmw1OWRPUDhwWWlVbFl4MmpFUGJWTEtDL1BVd0tqM1htZHBDOTFOZVhnYXRKYjRRTFVla1B2V3FjbHBYZFhOQVFDNGxNaWE1YjJvRTM2cElCbFk1NDRoSDJSSzBLRkRuY09ObGxmd3lOM1JRSndoZ0l4UFlRQ1RBL3dPcEtyTmlGYktaUlA1S3J4cC9pcTRmQTlSVG9QcHl1VWx0RSs1RjlKazlvNU1pUzJ5SStUOHV3bnFWY01zakg5dVRkcTI5YlhlZVBGR3ZRT1pHSzdtTHFPdFVJU3R5S29STTNyeTFUVTVFYWxlVVM3RGd2Y3loM2tGN1J3OFZmc3grVXVFUW9tcVkzNURpNVNLNGY3ZzRRdGZ5NCtNUWZGZ2NXRk91b3FNdDNqTVI1ejFWN3E2MDJqOUg1MlJEeno5bzl5T3NXUUJ6NFpJZjAxQnZnbi9XQmwrc3BiMlhWclErbzdkaDFsU05GRG4wWkkrQWZiUjlMM1B3MDkrd1BEL3JDNjRJTUhJYlhqYXJxYW10b2tOYytiUUkxT2ExNmZwUElUTjJBOThIMC9ta21aM2dDOFdkTjVCR09Pc3dHcndyZUUwWHllVFA5eFJsSWl6VDdWR29FQXIzTVU1RG1vRXNtcnc1MTV3SlBBN2Rvb1dWcm00R2VxRUdNS0d6a3cwR1hBVmgrTm42eS9qdUFEWnNscUI5WWZHZHZ0SkdlV29vRUVYK2pxVjJvZmhNRXJ4bmZucUVYaVZRWExtcU52VGI5TGhvbWUyakZXRVpXaXBaOXdPRTVpenZ0OHJlaDVucjlQbk5NVVd4Y3psa1FhOHA0bWk4SzVUOU84ZnVFRm14Mk5VN1k1MVlCSUtLZXhiM05FZ0NubXRsWTJaL3huMEVLSnpzODJOQmNjY3BvV2prSmpwaERkczB4OTJMY2U3NVBzTnZrcGhCSUt6a0xucGg5QjhTVWQ5dk4rNXZ1d0lPRlBRWUJzelN5TDNCUjFyVzJLTWI0aXhKVWNON0o1ZVorRkprTjIxaVpzN0FITTRBdCszamFMUlo3ajE2MjBtMHVLK2tzcDkzQW9PYk5hQjRRUFZlRzJZL1pLY3JjNlN5SHZGOWl1RGZOMXZUNGZiNEZ4QjJxd0p1enBrRnovczlBemxqcG5ybU12THpZdWtlWUdGUWNhNFd5amFuM29WcGhMRG1IRWZuZzVvNE9YRlliM1BBbzVJY2VzOGFsNlJSQjdrd3VkaFVJeTNYZHlRVWpjdm9HV2hNNzZHZXptYmNpN1B6MDUyaGpFYVJyZTdxRXBySUcxN2EwRExuOGM1SWJzWkdnN0ZVWU12aXppUnFZajZMREgyb2x2d3F2Wm5mU0lHMU9kWHZFOExzNU1rd2FCQnRsUzdHRzFDMm9NUEZ3TkkrYnJPM3dTaWY1Sm0xY0VWQ1F1QnhaTEU5UUpRZ2JnVG5qTWVqMEVwT1k0aWhERDNPcTE1K2p0NE9NdFplWmY4MFAydi90Zk55aWlzeFBNMEFNMS92ZnZ2blpjeSsvL2VtejlNTEJlUVpFT0cvTjliVVgrYXNUWW5pckRtTzhMbEN6SVhONGEvdlVLNmM3RDgwK0d3Z09WZ3hqQ1dNWHhNQlYwUmNqZThkRVJiL2MySWpySFVOVG8rcXRQdTFBV2lHYjRsenJ0STNmVVNWLzlCUEd1djlOOGluNVovcTY2UDhqTXM2OU5pUDFaeHlLUHlWUzNRR2VzM2ZmNmFuN0lsNk4zQ1FvRHk5MHhxV0tCdXF2aXRxWjZxZExJYWgyUFlPMEtMRnNVck9pV1lSNS84ZDZaTkI0bkpBYXlXU3ZTcjluZlFDTitQREZmM0h2TDc3dkxDNmxidTJlelo5V0YzY2RXdFF0WG50U2FpeDZIMG1DS0RzWjc5ZHRFaFdqNWZaMUV2VjZMVlpKNDZ6ZmlTN2VQUVlqQi81MVE1MS9DUkRsZk9qOERNWGgxN3hoY0I2WVlxTGhHUm12ZlVyR3hWM1BraU9sdGhLU3QzbE5EYlI0ZzRUTmFlR2FNNno3RFlBcnk2RFoyNGU3WHg2bm81ekFNNllodW4xbTZMV0RmNTBFNmREd0xUbE5QTmFNQ2taVzNBTHJOcFhqM0c4dWFzTUltNmNvc1BKNlM3dGFjNmF1bmFJMDd5V3ZIOC9Ba0c0RjdBUHVLbktIdlliNGVxYms5U0V5Q1k4dFBxdnZzWHczRk1ta1BjejlQakE1NnpwRTJSQ1AvTElpVENwSEVVNzZGVHlWQWFIV0QrRWtybi9EL3dBblgrRUhib2FQMDdqZWVSWmQ0RHVBbGowaUt5ZkpFczZ2YkhwRWVKOVliZVJVQ1pyY3poeno5TkdsdExSdkh3UDBtQXFFbUtxRFdLaGJJSDdzTlZuYndqUHVqTlJZSVlvR094MjdRc2VXb0c0Vzljd1R6OUJQd1piKzB3d1pWV09PS29tTm52QmZDV1pLc2ZUUXdxdHY0eWladDlyVVV5aUxHekp4YzFjVmRXV0xETk8xditGR3NFbCtXSFp6bDdQa1JtcGE1dnhXVG9ab3FZZDhZRmlOY0VKWkJ5M2dDYmN1QzQ0MVhveG5SK2J3ZC9zZ2RXd0xUWUlTaGdpNTRpNWRJV2JnU3NTRzhDRUx0anBGaHF0TW0xRng1WlpLRFRJT21zVXRWL3NWeStYdTl5NDc4T0gxaUhDV21LQkRCT3NoUHpmazU3MDhsMjhIRUZMbnl6aU9vWjNLTEh5R1orLy8yN2dzcXp6T09ZK1RXRFdpRFJwZkRNTUhYTXhTcGE1a3NGT3EwcnpWZkJNY25OOTZCczYvZExaVjNCN3lVamY0RGhxN20wMUNzV2Jwc3JjZStrTE83QnJQOHlsL1dleFFNV25JQ0xQSVlORXFNT2JLR2tpVU01VWNNSHpPeHFGRTZYZG40WlNmS204UFhoRHl0NkxQWENyVHFHVm5hazBHbjY4bllMN2pzMHJ3Um1UU1RTLzJtcytCbWVxcGx5UHIwNm9NSkRLNWFINmduTjROYytwS09iT3dlU243c3lueVBJemoyQ1RRSGJBZHR3WDl5S2RmT0Y4cGhEdzVyWmF5MG5PdzNxZ3ZoYTZJdlRlT2hGSGordkxjRzBuYXE0V3lVNHpvaXIyVDE3YnpZODVpWEhJU2M5VmQ3Sm1oWkhvcGxHbEhjcFR5ZnB4TDBnZFo3VmhsUVRYakNRV1N6em9ZYWliK1pGTDdwUXFNWVNDMGNmZm9LOFJpL2d5NHlTdzBiaVRzYnQxa3EyN05HOGxDeGxCeVFsK3JRVDVHU1hsNlIxTlRnVjkwcFZrNkt5bi8zQVZENGdQU3RxNFFjbmZQZGdVWG9iWm8ydXFhYkN5TXRxYXZQVHlpeDVPNWRoaW1IZjZnZWNPNXp6WjI3UlFkUWQvdC8yeDlDMEVIeTc1dkZ5OE5qKzdTUERnOVdWZkNCNTNENTlmUWcvMk5IbnpnTGJ5bURwL2RieTJKWXRETUY3TG1yVFFyRG5aVDVCQ2crRDIyTnFyYUZEMkhXL3NrNnVxb2tFZFUyZXJhbTlnN1JEZmd6amFKcjAveUljMnZ4em1ab1JDTHZCMElSekZPMDZaNnNNVVZxbHVTVVBqWlhVQ1dXbW13Uys1OURubExiU3F2am8xT3REcTM3elh2SUd0a0svczNqRm5JbEFxZ2hzODNBVkd1dVNocERXK2dEdll3a2pQVmg3RmsyM1gwUFpMc1NLanpHY1lsSS84a1kvR1F1U09CbWdBZkpCQ3NuMzl6MFJaUStFdjFXOEdwY3NxS1dUSlBROGZwQTJHVTB2RlhyWW1PbDRhTU9RSDdLZkhPQjE3b1dJZmJ1YnJhY0NNSXl6Zm1nM1lmM20vUmJ5Ym9rTGJZMEQ2clYzM2hKRDZzSFIzNVpCU2UxNTgvb1hIZk9NUFA0Q0c3RnptaXZuemp1ZU5GK2VKVVc5SWkxVHFhSm9BR3dJelczaFUzMWFOU0hxS2Jaa1dMZEc1aVVTQkNKVnBGdGY4YzFLakNRUEhaNi95bk83VVQ3SUlnQmRnalVGVC9oTGhuMEloM1NjSVViSDNvUFlWR3ViVk5XR0R5TW1TTVlXNjkzS1hsQmovVklFZ05Cd0tqakhTRjJ4MmEzWU1kdGJSQ2Q1R2J5VVZ6RWNrU3g0bXlWL1FHV2x4MUR2U3hmR3J2VEk1L05wTlNJZmJXLysvcGpqWkpGWXZSeFZBd2FRZDIrTHhKZkhGN3lHLzRvRGVDWG9hSUM1bk15QUQ5eFN4NS9oVXNzWTQxbGsybDBKb0Y5T0laNkFKNk5ha3pFcHRoRUVUbW5ETkVsZTFURlNyazFpTnpGczBMZmo1YytIWnEyWkU3UmpBTGxVajI3REo1WjE0NzY4bkdndkpxUDFLUHhOTSt3NkYzUGFTN2I5dVZSdlNPZTZrTklET0dMRTM2RVdGS2ZXMVJFK1dVNU81NGhXbDQ4L2QrT1Nkank4NFZxbnJ1cFdwcWVNWmhQTVZYdkNoeWhmZ0lhNm5UYnliZGVGbzQ1ZUZVU1dkMnk5ZEc5K0U5NU9YQWxodjdRRFlWcjIvS1ordXJSenk5TTNCektxcm43QXZnVzBlMlZBK2w4VUNZREtRVEFVNlZjTXdUcGdOaDFCTnJuaVZXMjc5UVk3NDg0NHZIZmFLMWZES1VwM3g1SXBTVXptUHU3VExzZDVwdkhhd3h4bWxJTWdIM1l0Ly9QeGQyeC9RK2trTmUvMUVwWmdyaVpqQ0JoUlJ5Vmc4aWpYY1Z1MGxwc2lLQ0s1am9iZWFXZ3VNcTZGamwrK1FaL1lYcElMRnIyRlI0ZmRYUmRGa1p1cjc2TXdLbjMrM0pjWDBqWVlUYlB0cjlNeUNETVIwOEhHUHVab1RMWStTcTdLVTJTUjMxdkR3T0N0Uk00V1dWa2FtbC8rdDIxejBHVDRUSEg3TzdDYkxHK1Nqc1pETEk2cEhzUlRVbko5TUw1L1JTR2I5Z3N0emJVMGwzT3pXQlpadEFjZTUvS3BidjYyNE9USXZaZGF0QURPL05hSFZWNjNSaUI4a3lxbmQyYW14NlVJMUgxck5QZlVHVHd3VERsS09rUkUvVlZQUGQ3Mm00dk1sTGk4MkplUnJtNWR4WHYxaDZ1R3hsSTdJRE5pNU5xbjVBUGZBSlFCUjk0YXpPNFQ5RTRUeHpJSFQ0V2c2c3JzNURLWDNYWGJOOHR2aVIxSEhxWFFFTlNZT3daN1BuWlRoZXFFWllod2p5TUhwcWVoQnBqZVd1Mm54NVBaYlVYRFppcVN6TlVWTHltejdLSmgzK0tBV2FUUkJPVllLTzAxaks3Q0RwcDNFRm1SVGFscXZWMXdFaUo1NzlwRkNrMkhIdmZ6SmVMKzdLbDZ2Sis3OEZjdXppM0NGK3pJakJWQm01bFdyK24wMGpUd3F2Z2hMYnpaOHM3b282aVUvMGRCUG15cGt5cGQ3cVFCR2Z3Um0zeE9QZWxjQjI0K1RENHk1WFlTbUh2ejlPbnF1OVB3RzdkTHk1ZDFwWU1TbHR1NjdNaHhFVTdKRjNzWm1yeThvZ3QvdnVVVnhXaUlGbDJ6Q1h1YXlkdURUbDVPMTA5UUtXSFk0VG5xTnBhZmpLYkNtZXpLaWloa3VOeGMxbHltZVd1Z2xRZTlGVUVpSnRXVUUveWpUODBsSk9ZMWxISDhZYjJENWdFMkhXOVpySkd1NTVmSElnVGJpeWx2YkszVWxiclVxTjEwbU00TVZiWE9Ycm1XL1FHRThBVThkTW5HczArRWdrdUZBT0RIc3VWUmttMHAwdnhnc2NoQWxmbUlmdUFieGhNaFQvWkhXTnorTWdMamM4OHVpTjExOS82SlNoaVNFZU9nSU9sZUh6ZXhZUWZueEY5WW5iVTZ0Y25aQnpzRGVjamFqb3dkN0dpQno2OXhZVURQQnluVDZFcFlmR1dLQ2VmNHFCR3BJcVlqWVNkclZiOFBJSUZXKzI2M2hEOExhbHYyM25MZnpmV0JjeUtqZE50Q3R2WjNhcitqUWlLTnc5WWZwdDRnTGJVUkJzeVd4ZExwT0lxN3BBMXYrZElkMmN4SnhSeEZaM3EwK2swZjlCT3J3bzRpQzdZL3Z5K3dCbTZtenFJQ0ZKUnpEQ3BhWVg5KzlYWHdsZWhXTTlQVlVOcWxDRFI0RWtoTzk1b0R5UGVCM254cnltV2FmU0FiN0ZMSXZDNmkzZFZUY2RMOFZQNzg4MzFZWEhST2NuNVVmSGhKLzE4eS9OY05Tb2RoUitWNHJKeXk4ck50Y05WUy82dldLQ3Y0ZWpLd3I5bjRlVjZaRHB1bTNienFnTjZ6cHFWb1djbU9uZnRYT3h3Y2p6Kzh2RnVLcTZzVW1IcmlrdUtVMG1GWUNLQ1p1azJMQXJGSThRNjA1bE5CR1l4UkdEakIvelNiNG93K1Y1MURnRlNFV0tVYlBCU2dXQTRlZDQyRi9nUnJ3M0JHT3c1Sk13d1FRUlBDRmlGVjkwVUhqaDNqTUZVdUZYMFlTM3ZSdkJJRE1vRFFiYjI0UEJBWkphcVI5UXFvM3dhNjcramlGd3o5MXhhZWpNa045c2Zpc2YxRzlQVUtNVVRxUFNsTjhkWm5yZnViZGdNekx4NUFBaEpwejFmcXMvU3hQOWo5aTd6cjVqM3dWNXhmU3QvcldzZFQyeEdqdkZoazNPalpCMEJtelFMRCtXN2VYWnpzUUVXVTVmRjJFcmVub3FsajhUbUUwMVdDd0Z5Q2NhWWgxaGtrcGZZYW1yckVBVmxUdHRSWHBPYWZINlRPQmpDNGhLVWhIZFF2elhkL1RGdytFQkp2d0dBNGV5N3lqdm1LYUpINzJ2NittUm01czNoTDV0bnAyNFY3dGpvWXFvWWtVeCtNQ29BNkdZVFRseHFlYlVvWGhBSnBnYXBYamtoUmlqSTJ4K0FTSENJcXlQQTFLWUVKQVFQSlFEUjRRMjU2MmxDSWN4d2lIT0dNZ2lMeEpsTE9HWldxMFh6K0tGQUoxQ1Rvbkk0RDhVVEhDWWJvdlpMZGhTRk04YXA2QlF1SEJkVGV5eXNxb1VZc3RLYTZqYlZZVkZDOWNHL0dWdlJzT3diSFZ4TWFWanhXOXZ6aHZLelp1K2FrcGsrRFJOQkJGMzhoQVlsckdNTHRYeHVpUkJSU3pqYmpJcmlmUFpHQjJZcnQ5L0Evd1dzWDJsK29IWlhEQnhjVXBzQjgwQTBEWkJlTXpySm83REVCZXRURlEyV1JRd096V0E0TzNveFovcWx5STM0c1FpMGxrSVR5RHVSS2hzSm5mbm1KQ29yWisrVVBHclBLeUFDc1BQSDA0VTFJbGljMFdtSkxFNEdVenN6bmN5cGk5Q0xhdUxnSFpmVWswNkJHdnBNTUpnaVVjU3NPMTFPTmJuN0FSUVRrTTB6Qk0wa1pNY2hESzd1eXNxZTdxUGhWUmkxaGNGb0JwNEFlWkNrMDlMU3lkMzc1NWNoUG51Rm82SThQZk1BNlgrL240L2RNZDRFVklJYWRHSWlIZGJrVk5ZeXFocFdZdWxaVFhORnM5K3Ztay9YMHJmYi81alphL3Rqd1hxVGs3cm1jNkdGOTVUZDlhL0lCMFFBYnBWZXV6RFhnN3pHRmxJdXRLZ3pPNllCeW5JYU8zNGZaUEhSNm5qVklBVXJERGZ0YUNDZWhFcWZNZ2ZacHVXbGthV05Bc3NWNjRlcmxnT3g4MUd0UFpvL3lISzE3dlR5LzJlUFhKWldlUENpTHpZY2FmNW0wRGdjSXpSQ3RZUVFhQlJUYUxldTd2MVdTREQyd1RWQ01KTnA0ZEtGbm4rWk0yby9raG5hK3NKakhkTjZ1M3A0WjdJTDF4N1E4OUdOVzQyNXpiL3V6SXZiSDUrVGpYbzF3SitSMmQyVW4ramNHMWZjblpCdzNEMXM3TjA3aldCY1lxZlVncGtqc3hxdGdSMWoxMExCeTN0RXMvUmw0Z2lCNVNDYXpRQXU5REhwdXVlZzlwWGx0ejF5bDNhbDVaMC82bFIxeCtWMXY2L3dQeXQrY3RlMVhaVHkrMjlGRGpYUjBsRUlCbnB3RVVRVkUxT0VYNDBTeDI0L0xsaFlkTEhwbENlWjJOSDl2bG9McFEzUDNERzczVkFCUlZqUmp6elVCd0xBcWY2enU3ZnpxdUl1SDdYK0dQMTNYUWhjTWNYTXRxMXkyU3ZvVEp6Yms3WGVEb0hMY29VWEMydy9TL0I3cXhjS3JTbDM2Q1EvdU1aNW1Rck1QN2U3ajZmZVgyZVZxUFNBeWlEM2tsVSs4aldoNGw5VXUzNW9aQ3FocUp3MnM4UlZWR1MrYzM3Y1BwcERNbmV6NHlWTWpaVXRzQUo0TC8veENIRGt3VWZDZjdQRlRDays1OVIzWDJzYStKVFRNbUN6MzRWRE1QV3o0emxuTWNxMmNHZnFHQk85V2tFdlBHSk5zNU92OS9YNzcxTmwxcCtPV3ZaVDVCN3dLeWtQUDdjc05GaXg2WUs3ajlSSC8xMGYzaFp0dkUzZFJMK1VQRDM4dlRyL2VnbWtCNS9XM1F5L21KK1lYVFkrWWhER0pFSnI5c1JNSWdnRk9TS2lOeFkwWXlaTWtKQkVDb1NVajVGdTNMUWkyWEpDMFhWYzlhdnp3bU1ueS9LREp1a3JHaHc3UGJNbU5ORzVzdkZEaEJUY0xVMDV2ei9DWFlGTVlQdzVtNXRmRzdEa1R1NytWSTFPUEo2MGIyM2Z6eFJjaHJZQXUxUXR6cEVVVUJMR3hJWFZWWDZXenV3emZvOUhxZXpDN3ZkdUd2M2J1QWlzb0ErVFF2QU0weWFkQjZkNittQjVDVkpncHQyQlFRTWNSYXhHOXN0cXAxcldCeHpuT1Qwa0pXS09Wa0xCd2t5aHhzU2sySUFyOFJ4K0F2QnV4TlBPY0NTSnFFcTJaeU1CTTJCZjJSTzN1MzI4cnhrMkkxNURHZ1puS0tFWXlDN2JVTnV3UEYyMGJKcmpOTXRMSXN4SFZ3ZXhvUFhvekZEa0oyeFF5YXMxalN4MTdJZFR3enM2MzNlNU50U0VmZ1RFOGVsOFF4cHdJQmxnVFd4YkpNOUt5R3h3cHQxcjQxZ2dHaUhjQ1pMWnpsdXpoaUQ2U2tBMnZjU1k4anBCSitxTVJia2VjRmZzRzU0bUZEQ3hsUGpuMjdxN2IwZkYxaXQvNi9hSkk5L1cxeEpYVjE0c0VLV0VZTDh1L09UMGhRVmlqUkUxZUtkbWo1MU5EVUNhWThtM0k4Um51Q29reFNteGlrU0ROb1ZvODQ3NDFEQVg3SHU5ckl5dWJMaWRzS3BVL3lLZkhNR3E2NVhSeGlDNzhaTEx5M3FpLzlQV3RucnJKSG5qYmxwNXBxMTBRbE1BTDZOQ2NVTThtSlpwajlLblZLTHk1Lzk4dDhwS3hwSDJFNEhHY0tXL1ovN3gxQVFsNUV1TEwvemdZRmRrOE1YRnZ2ZXI5U2JRNTN6ZnZuUEoybU1HbDBJWHpLdDArVTlQZkxwTXlHNTFEZzFuL3FUTXUra2VRcWxaUml2UnEzSXpsclhaNDVZMVZWb2VmWFNUQ2d1QzZTc2FkNi92M25ObDNjeWRCVTlQYm4vME00UFM2UFN3bksxelNwcCt4MVF3VHcvb0I5SSsyWHg5cTg1UGZmMWk2ZCs2Yy9SeVUzcGRSbE1wc2VEUWhLOTNydUhZZGs4WDFqeFVIVjE3RldyZGV1SWdJVFBXcTBXdjlYSy9iNGNPLzd5dnUzVnpjdlZGUXk0SmZmK21YQS8vU0VTOTE2MmRKWFdlcWJNWnYvUVkwUCtSeVlQVE40SXRBYkVaVmNmT3VDbEhKUkVuYVI4Q2xSa3NHSFA4Ujd3am9xam9KeUVOWkU1d3JyU3FBb3F6VFdKZ3BTTEhVVVhXL0YvNDJBVmhpTFM3V2pQeUxtUGRVYTNVVGErWnJ5T2paTkd1bXpNZnJDcnJDd3hjeDZUTjZGVDExeVdoMS9vZUFIbndXSy9hSEpHdGVlSy9Ed21IdG53VGtrMkV2WjZES2diZ1FJMVRrbkk2ODFuTWZieVhvelpMNWtiUHcwaHM5TEJtVHM0YzVzY3BKVW1Na2VWRTZscEN3OUdXTU5qSWdiRC8yM3VrRHZoT3FZMjI4UThmNkdnS2FDQjkvRmVWeS93dmZHdGlTWUxDcGFYSjhTWGxBemFCOGdIdFZlYVFwYlNIV0I0bDhlMSt4WjA1Vk5tS3ZTMSt5VVdjd2llbHdhTlczeitPV1V1QzQzYnptd1AvODBGOHZuT3d2RENCWlpYNTZ1eCtVYXFBN3hvRGpaQmhKOWw5WkplSkFxSEFpRXNtYURTZmtsQzZxdUFEWWpuYmNVWk9XcG0zRXEzWEQ5cFZGMVhZSjhmRCtNb3d3REpuSUVCQytheEJkMzNjRXg0L3JId21JZFAzZnl3aGdBZHM5Ymc5NGR4MEYrakRWcHJOaUNTSVZiNXljNW5TWDJpQklHRFZVYnh6WnR2OThzRy9QMmpEY2RsbWdFcitMWHhRQWJQNHV0ckY2UTZ3bTdtQk1FUTE1aXg4eHhMTzEyeTJyTFdHKzYrb0QyWmZoTFJ4TytzV3NPeEN4ZlJyTk5KOVN1bnMxQnhlRDlJVWQ5NTFnVUNIckUrRnZHUGlzODdpQmlSTytJUlJtYmpscTdiK3R0dDRkVXhmYlcxZlVSQktNWEVhM056RjBZNWRTRGhoYTB2OUtFZG51L2w4a1BleEtLcDdYcUhpZ0FEQW0yY0VwYWNNNWpIOEJnT2U4ZjJETHVRWGJvQUw4TXZTTjR0dzMxVG84OWJQdnVSSTA0ZSt6bjE0U0ZaSFplbFRybjR5dU4xbFl2RHZyUS8vbHNNT3BKcU1CUXNNUHRUazNZdlNTMnF0QzFhVU5NN0U1NVVXQlg2UWI5elNKMGU4N2owNnpPUXZhWXRnT1pJT3dWaWVkWW1lTEdYUDYzekVqYjhCZ0RPKzIzcXJ6WmYxZk02ZmtuZmlyNGx2TTRtSWhtRjVMamRmTFQxZmN3eWFHOUZiV3ZOMU5UYW10dldWYzNzZkRWZE5rQ3F5Y1QxSTBPRy9DZjdrSUlSMjdHVitwQVB2TmtVdlYyaVdtdTJQTmJrVk94QS9WRkVFMi9pb3VHSjN4RFd4a0NWY3ZlUVhmMDhDbnhNZWMxeWFLemJiVnV2NzVVSHFySlF3dE5oV01oL3dRMVJRd1lUaW5ZQUNZSk41cyt6Qk5HU29QcU5LQlRCcUNvWDFaRW5RR0VJcElMcEJTZVVVU09INUhOekNJWTMweVNHSVhhSnY2Y0JaYURFV3liVXJWOXExUGZNYWlxdU4xNXVvVkN6bUsxNkYySEsxUE9iMlZYRzIvbVVkTERXZkFjOXAyVnRvVFBiU0pZNDNLK1dtTHBRN01BdFpaQlZ3RHR3cXEzM25tbzdsL2RMK3lLcHRPdERycXcvNVpiRzVXbmwvRjdpRG01NVdQY2FxYVN6cTA0OWRaWHpXNkdyMFFPeHJ0dmJWLzNhcTB6S3BZY0xESXp2NlNMVVY1dzVlOFQrRDJhZWtXdHI1YjE3YWwvUVdKVFZTczNwd1lrQ2RLQldVTWtDS2xNKzlkUzZLSzFLR3dXZm0rK2Njc0VnUm5SQ0dJeWVPQ2dMb0x3ZDJZVnBseTRVQ1pHWmtUR1JqeUJVNmJyNUloNUJBTzQwM2cyTzIzVXQ3Z1IxNW9qRUl6KysxOHlxSDBwTmxDSkpvWExrNThkclk2bm9EbDJtcmxPSG5kOTB4M0Q5NHZyaE5XMXd6SjVoK2x4bjUrcjJDNTJkNStnSFVjdnlxYXkyeEU1aDV0VDZvT1lPRFovMXIxenBoMzU5WDg5NDdKaG5jZmtwTzcxbm1HWDlDcWhZd2U5YTNPcVY3aS8zem5ka04xY1RBbXVySlo2RVIxaG45cUFVNks2YkhUdktLOG81TXpDcWUzcmMyTnV2SnF4Rmd4dndGS05mZlU1NEFMTWFBZTFMY1YxSUk4RkNWQ0p3TlJEYzJwY2x2NnVZYmRYRjdTWitpMmpXcUxGL3VHNFIyMVRkdU1ySTh3MmJlMEgvY0dNdXMvMWgxVE5sS01OUVJQYnFKRUhJVk5kWnhuRi9hZGtyR2dQd0JtbG5mTndMRlZiYzJnQlBZMlJNOElSTlVsN3FFaVZSMDZiYkZZcEdjejRXczNnTzc3Q0VnZVJvcHVpNERjZ0Z6U0tsQjVJUjZqY0JwTnBSTzVheC9kR0RCdTlZTmdjZmJvME5lcVJmV05yZVhyclFZaVlqMjRXbEFmcVBlVlF0YnlZejlGMzUwVWMvTEpmTDQ4di9FeU0vekZueTExNUNuYTlwNkg0ZHJ2aTlnVDBKM3Z3cGN2Q21PV1Y1NjdrMTBwakhIQWZ4U0FPUGVYRkNSckxvZFl4dWEzbGlBbzVYZ1ZReGpJWlNldzV6ZDhJOWNvdlo0MGgyZ3MxdFN4UTJjeFBiY3FsUnlvVjQyUkdSNnhrQnd0Z1lHck8xTWRGMWpTS1hhSURRQk5tdjB0NVBjMUEwclh2R3hJSFdHREVZZW4zWW5VTWIzUHE2b2FGMWhycEIxbDdyd3BlYUtXRENBOXBBN09nemZHWmtNNVFqZlVUQitFNXVvMzNJeHdVbDZYaythYnFTS0R1dW9NNlQwN3JRbTQ2b2pvZ3hwM0N4NHcvSTVBam1pVGFPOEwxRDRiY21pK28rNm5sZ1pGR1hwdFhjc2UyZWswdkdSNDZNcXNhRHdZVXpmR1JrOU92Wjh2MVhob2YrODJuUWNNQVBXK3Bkd2MxdEsydi9TREV5RWd3Ty9kSEhJQUtlRVdaMjJVdnZVNUhKZ01PRGFVUmxVZmdSQUdUSUFoSGNHSW5VSjBwZ3lXd3VLbFZFbFRoL1I2Z2xPOGxaR01JRW1vMWdXQVZaUzBnRTRjV3pPamR5SCtqZVUrOWxXU3hOU0VpRUVWdjZ0OG1uOWwyNmRHUmtvSGZiSzYrQTFMdHRab2tQUTRmMEtzdUdueXhjNDk4MjNITW4xdmJYN0wvYUN1OU1hZkczUnU1aWZXelc5R2lOWmlOdzBmQ0wzeWZKNG1uU2poQnhkVTI4UDdzMkg2eld0eWRWaVpYVmNrVkZROTl0Yy9qYm02ZGJkNTM0MXo4djYwVUFoVERpVEx6TWN5NTcvMms1cFBQOE5ZR3hoS2NsYjNlMjVOR2tPSGVtT3k3cDBSTDJuNGI2UjVjb1g4dDRUWmwwVE0vSzJFU1lobVVXMGVDNUVZQ3ZJREo0eUk0UWNaR0dMbzN1YUEwMnZWKy94dElWNUxaeG1yU3p5bG9IZTl5TCsvZTFGSzdxaXVENnN0ZGxQNWJ6SDlkQVJVN1cyb1BxeEJhdU9RMU5tVS9tbmNpNG95ekhPd2RPaEd0UFBuS0lEMExOajZjcWc5bWNGNTZtUGFXSlg1U1VjMFZ6SmV5S1BCbDJHN2lwRHpLUkgzRDRwd3E1Y2t2UXFvL1EyV3oyd2dreHA3aEkvVlJNZXJDYktVaysrVk1vbTdNSVIrWWtGYWkrVlNUVGsvVXFUTHhxb1ZMdERxaFJyQ01aZDFkdElCUWs0VXBIS1IzYVpWZ29CVzZIUkJDRkhMUGJsV1JMUUR2QkRoOU0vZDJRUTZxaWZrRmtSYXNPeGFrMmh4QVdFdm04ZTdJWmdGWWZtaW5QMEx4NHdHWldCaGtFV1ZYc2Z0QlhmYjY0ZUpibDczRjIxdnR3T2NSUlE2VEJjcjFzMGFSV2hOUm41aU91YXFGbXJZeXJLUkdhZ2RFOTRZU3MxelhabC83NkN0VWtjb3JtbVdRVzdybUVpcXltSlFJcVRjWkt0bUpUdzZwQTJOdy9nbEU2eUdpeHVYZkp1aG9rMHE3SnRQb3kyMWlyQ2lnR2RCSU5YS3FPeFk5OUgyWnhLckFLUEtBNGcxcUo0MWhqTFdWa3g0S1ZkRHFPMVF3dkpHbm8zWVBjZzJhWllReHhiUDNlWFMrMGxScHJlQ056aHlNWXloN0FRbGJwbnJLTUdXcTJhMHRKTHo0aFJ5WGVMTW9jV3krVlJnL0VyNHZlVlB2UTVwc3lLV1hVdUJ5NnVoeFI5dHlySWk1MFJNd3EzQTYrdGlua2IyQVpxcXB1eWphblVGSUR4Y1NlbWZDSG9UTE1na3BkY3o0NXFXaUZTaEZ0WmFkWTlzSHk0VnJaT2xPZy9VRDdFRDZTSGxJRlNKamRuMXA3NWV2OHlRZTUvQUo1ZUZpemxzM2YrK0NEVi9rSG1XTFB1MVBqMmxFcXN2eGhsZjc5dnQ1N2FzZFZKd2NHeHFNaXh3Y01uRlNOYjkycXZRRVRuMW01VWg2cHpmbjZjQnEwRnlvcTBHTXgrbGN1cnJaY2U3SmlMNXlVa2N1UFZLRUJsTHZ0aUpnN1lJSkVGTDBPeUl2b3RmQlVjanZ6ZUQwY0p4TWFlM0dJTEFjdDhNNzRESFlzWWZEc1pvc3I1Ungyb1lCdkV3bWk1cWdESFNVdUdhcXJMZFdHeG9neHZJTVVoRThoRWtmNjd0eUVtRmxlTUNFNlRwV2FsQXFvWXFzSlc1aStDSzVJaHhHMkVZWlYycGRwNzBwYkRFc3ppTmQ1R0pabkdSUk9NM1E0aU15NjNWT1lWd0NTYzNjSVRUK2lFZFFGTWFHMm1RQ1JqckFGWDVUTUlYTVlFVEJ5Q3Z3dTJqTEpOQ3RBZmpRMk1oNUxtUE1pVnNoWUZXeEIvVGZBSWNlbGRKVFA1S0VkY3lNODEwMW9EZ09UVjArQzB6eWROMElUQVRjZjRoaGQ1cHJGZmpjRzlXdkcxOVJ1QzI1bDJHVVQya3U0V0lnWGlpeE4xWS8xR3o3a3cyTzJRY1R3TUNzU3RoamJmbHBRWnZmZ2dGUHRGa1VvMzArZnFPQ0F1d3N0ejB6OVkrclJqZ1lUVnBqTGVmR1Q5dDRsSWp1TFpxK0xHTlBJcHh3YVl5elRIcnZMZzJ4SVR4Vlh0Nk4yY2RyT0ZPeUxCWUtGbldjS2dnVU1UY3g2cDRzZUlyazI1MFVZQVJvczhSSytnTCswSkw1KzVaRUVSbTdmMVhCNFpLbjIvYTcrdkF2ZWRRMHFvdGlXNFlkNGRoejFrM1IzNXJwUTFmVWxPMk1majcyamJFWWt4R1Y4NTNiZGhIUzliZUJ3N2hFNWtXakNRVnM2YnNmblVPOGN2YjV0QllEbE1SK1ViWVFqckJkNUFSU1ArT0NFVFVXczlYeWJUZ1Z3a1Y1QVJNV3FxeUVENDJCUXlhMzVaaXhCUkVSOEVWWUlrL2V1V0NuZjFDd3N0YjEvYVY2ODlGTkxkVU5DVVZYVnk1bzRiOENuckxoMzNSNkFMWmlIYkVWZklHMVZLdTFDZmRJdHlKelJuQW1ibHErRVhhZ1pCRzh5dmpXdmFHQmo3c0ZIa0Q2Z3ArLzdUZkpLcW01bFdIT3lDcHVxWUJBMzVDWkVwQ25TVXY1cTEzUjRqNW5IOExCVFBCMDc1dS9mT3VtbnF1UHZGQnRZd2hOV0VCNlpDSTN1MUV0ekVma29KcVlqSWsvOE9qSVVWRmFucHFMSUxpcy9ESVJrcUloS0U3RXZwanoxbGp1ZGM3NkRoTzF2MWllUmVlMkptUGlMU3NxZTZIQkhNcnhCTE0vdmNPYlNpQWdqM2F4ektwS21EWFFPY0VRaWs4Y0d6N0tiR3FXOENMRDdoVjdlUzRKZVRTVVppSmk0cHdxZWltTjZaZTE0ODR6aE9LYVdDTTJWN2h3ZDdjUjEyN2ZWWW1NVGI4VGJOQTZyaUlxVitaZkd1TEFMU1N4cW1pVjZsL0xvUmM3RUZ5c0t2bUhqeHZhdjA0Z3JHeGtnaHllRlJCemlpZlVEWXdvNDc1TjhZckQxT3Q1MW1wYnAweTd1bWZHT0lSbGhic0NSR0NFWklUd3hpaUlTRWIxMzl0bEZnYkJFTk5sNWUxQ0hNQkpuS2trd0tVWTRJcndzUkFqQWVXWHZSSVlJQTFFMkhzUnh5b2Rsekl4RkRnZU1rVnc3dGlPYW0yQitNa2JFemJyb1dHMlExL2Q2SmV5aVNUQWhQVVduQVc0M3NuVUV5NWgyT1NyOUVwTGxNbEVPeXRlMWhLTW9iT3FOVUVEaU5BcnQ5cW9BcDNBZGVHbTcxd3MydmFRN2hiSXg0cXlkT1VTbzNDbE9ReUgvWWN2bmlHeTZqaEUrRFhDN0lldTQvR0NubzlLdklVQ2RlZDVZMnFvbW1XczJ3QnpURTRFUmdUNys1Y3I5eWtFNU1FbVl3RHhyS3F6aEU3TjRaUkIydmhsZUU4M1QwTWdjWldYNDNTTElzMTNKcy93c1RjaGRNTkhlV1dDb0FLU0lkSFlWNlR6TGx0Q3JBWkZxQkY2NktFaldsMkdaUXhhNUxrZjk4TTNFV0FuZnptc0lUeXFxb2cwOC9kL3o3U1ZqTUJIeEYvaFViZzJpckNJcUh2REdGQURFVTdpQks4a01nODh5TnhsQnhXNjFETmdnR2lDc0lEU1lQVWEyeVMydjd1bmZmaHRiV1ZlSE1DVlRlK0VjWXg3dStHNUpvbXdHZzlpcUJpUEFTRkVLeDRpN2VhR3hkUy9CSlBkdWFGVlhZNGFiOStzaUQwWGtIb0tUell6VE5SMjI0M1J5WEhqazNIZFJnOUViUmVJdDM0TUVENUZhdGo1UUh3ZXp0dGNpZVp5ZWMvV2JGNVc2TGpsTDlvSjFCSlBtdmtFa2lDRE9rZkJ5Q0RkL0R5bE5rS2ptVlVUM3hBcjlUL3FTcUptSU85d2NtSmtGUmpHcUhWVlVSZFV0dXBzQ0dzMEJpWGl4VnpGS2tkTVg5RUg5elVMSDVjTUtxa0pSb2Ezb3UwR0FhVDZpb0ViU3M4dGkrMkx6WTN0alg0NGw2bFErRmdoQlI0QkhneHZsdUNITnNONlNGZVNkVTlnaHozZ2xDUXlCaWhuNkFGRU5GejVqQXN3WXdIaFVDMFRDemVhT2NuUHUzTDgvd1Z3Ty9GWUpqckIzVlppSHQ4eTVsdlVFbTYvY0k2ZVR6WHVHdFhMQk1ySGJTN2dXL0NYSEdFSTRjNGFJQnM2a3hRd3pnT09DZ09EaFpMRk5kR0VYWXg0MTFRLzNjdHBubTFpeCs3NXJXZ2FZQjVxTWFxZUpudStqaVpXZ0w3bTRlU3laQzhtdlc1ckp2cHVSU1gwTGRRUHpyZUdLWWtONFJQaDhGUkc5bGpVcEptMFFnTUJjSkZJZ091QUx5b2s5ZWtreHJmaHRJbGs4YWJYSlZBek9lQXlFclk2Q3JrUWxFWjBMTkIxSGc5cTBjU1d5cWdqeG1UQzFxU1krZ29rSVo4Skl3dXlDQVFsTDZGYUtpcHVPeFJCYXY2YTVqMHV2Z0V6TElpemhueHJTWURxTjZIZzgwZlgyc0Fqa0ZhZXFoWmVZZkJYYm1vM29ydXRNdUFtOHVFeVY2aEFZNVlkRWRtWkdOWTh1bEp1MnZsWmJGeElhTnJuYUpDdzBkbEtsam96U1JrWCs1K3loVjdndTAyUlkzUlAvbzFPaG05VnBnejJWTHBuYzl0QlhIdHRSNVJxZnZ2TGphR1RSbW9mTTZJbVp3YkFGVWR1cFJTMXVYN01HdFR2a3ZXc2ZxYkhHbnk1NmM2d00vbjhXTktRNjdUMm5RMnM4V3lGVkhaQ0tqMjBYUGNlTWFLWkRFVGRrRXd5M0hSZlIrYUg4ZU0wUmd2YUhnMHY5ZVkyMm9LSHg4QzFPdVlucmdkNVRWMVI4aTZXMkZQNkcxUElQSkNQaU4zQysyWjNUclAyOEpLNWgrM0V4ZTk3bjFJSC9JNnZjMGNmemprZTdUNzlMYlNnbmpXTVFzNE9kaitYWXNTQkhISFQ2alVHT21GamZYSGgxSTFHUU45NlFBOVFQYXVvM0JVU1ZScVVWaE1jOHBWTEJ1WWRYckIwcFhYdmtoUnI2RmVlSDY0NThWRnFodnRQdHRUUExFeHFmWEthTjJkLzdRdXNwcFdmMGZ3VVUxT0JodUVDRjhWb0lrbVBNUk5lVVdmdnVxcUhaSUpEL2dwTksrcUx4TlhVc0dGUUVKR0RXU2ZmSm5BcEk1UU1Pemc2aFJyVU83VW50Nkg0UlduYkpVR1BaWUl5UlIzc1J3anJldmdIR1JDbXpNbldTY2xNT0tvbkMwQWhRMHpSRjA5VDRvM3NpSnRRNFJUREhMYTRtQk04Z041MGhQNkZIbkdRUm12Rk1WWFJSNytvSnVINHgrU0JvUkkvV2kvSElKZzRTWTR6cjNsRHhod05mRFViSm8yU2ZudklLaytvM2VaK0w4N25hN2QyVitodjZwZEdLcUlqL1JmSlV0S0JER3J4ZzNXNUhHcTM3My92M3BhVU92LytOMTN0N1gzL2o4RHR1aDRtQ0FEWFdOeEdtYkNJdFlHS1NiS0xOaE5yRGduYzVHREhtbDZDNXpLRFNPbkZwelZsVm5kbTdLcnYzSnJVcnUvTTNMOG9ycDBTQW1HZDgvZ3hYRWpTNFNuZDNMcjhGckZlQU5nUkxkZEgzSTNveGxjQ08zQUdIZk1pbm8zZnNRekk1SHZ2NU1pa0FHdUFrc3lqSGtpMTQ5bUN3Wit2NUhQZjhHVTd5QmxoYTAyWE8vU3VuWjNhMTlZRW5TelBtR2pLWXUxS3h6K0NJU2QwTmU4aXJ1aTZVOFhVS1FUcVNZVGtPemZDR3JFU1NoK0FQTGhrRFR3aHRRaEx5bU1oUDBWa1RuaVlSUmdnZjJVTDA5WTkrM1drTFRTTEJnMmlWOVljbGY0SzNSaGQyR2NMN2lrdkU5RmMxelIzVU8vYllLT1Y0VW5aZWR2cVFBeGh4ak9zdDhnYWY4dXV3NVRuK1E5NTM0N25zajRsOS9oRWw3WmNUSnEvaC80Wm1GTXFWZmU5UXdpKzcwcTQ1UU4rWGVjYmc2bWE2WFlZem1hdFhIZStPb00rODlMM2RRd3NIbWt1aWJFbjZrS0lEMTJaK0RQcnhkdlZlRXppOE1sOTdZR3NpTEpudEpHNk1pRmQ1Snhsc3dCSlJoSHd6TVVGRU1hTEFpcE1VUmpKSldNMlJPQ0FLc0NHaytCTHBtaWh0MUR5RVJpR09Ld2RUc0xKVlJkaytLY2J0MXU2NVFzdjlVUHRsUkNUMGVqdllpMmEyNVlvaGtvUjRqS21UQ2lUbTRxMHBoVEJDSE9WUVNJb1JpbzhUVlp5azZCS1dkMzJxY29pVENaSVFNY1JxcEc1RnR1aVhLY2NCUXBxMXpjUEg2M1hXZkl2bTRZeTRCSkowM0ZYS29jaGdFZFMrRmNmcmMwWWltVEQyWGN1VlpNZ3drZWxHVEZ5cStTeG1hWm82cWFDWDBPaWROYVZ4LzhnaWwrU1U3ODBwVHRrNTRZSXZUUzMzUk13OFg0VFBSUE1ZQzQxSEM4eDYvR3A5NG9BQUZ5T09kMVJibk5HSkNhRkd0eDd6ZTBCNFRyM3lRS01uNkJQbGRqR2hxTzVLTzIrWTFkZHYvUlovdXpuOTI2SWJtZC91RUM2c3h4c085cHpaazNiZTRqYStmUFhneHBxN3ptL0VHdyt1M2JIeHZOOGgzUWUvMytyWDRBYVhYLzlWN21uTTBKdXRDUityVW05OUhUTXdlV0VhbXBwQ2FRdVRkeCs2OWRWYjlYRnNkNE5HMDlBZEc1WUxncEtROUlqa04za3lTNk9IL20vdFJBNzE2MGc2UUxndXF5UGpSQ3N3UlVzSVJ2WmZuckMyMnV6UnpacG5kZnVEZ3IyY2h6aURVeXhZdmZqODdtd2ZtZmpBdWE1V2JtcXVPVGpGMXRvRUlPK1dlVmR3THhtZXA1QTRRV1BTWjBRZk9tWWFOVTZkcUNCQlk1Yk94OUpMSU0wd2hLUXJDR3E5THJ5OElSdzBYUlpZUjMrSllNeEY1NUZIUk5SOUliQTBlSS81US9YK0lxMWpJWXliSEZLTmI4QXNjSUpGRzc5TkdmVkYyOENoQlFCMTRESExwSVhYaVhxWWlMdzk2cDZPanRIazg1akxGMlRaUWprb2k4eWwrRVVoWjUrRG5GS2JWVHcvaHVWQWdFL0dhc3ZXQmUyek1DdGNXRjY2czh1d2ZQZlpzMVhWUVpzZ1RON2lnWUdmNXBMQnpIczhSeGRzWDB4akdpMTF0ODNxYkViSForZzFLQUZVTVl0WVhmc0VzZUJxaS9Tcm91bExRMHhoa1NOV3BRNEtlTUU0R3JUNEErTnJPTjBpdFVLenZtYmJEMjNaNTdlY28rZlVZeFdHZHA2TzF0U3NUZDVUOTVlcXVoSTRzQ0liYThLMHRhOXAvVGJyeWVjNG9pQnQ2MGxZT0dua2JKNzFSRUdlTXhwSkhGbmY5dFRSeUhuYW1Ha1oyNzgySXhSRXdrUXNiNTJFeUw0Y2pmS3RXYkpyN0xwcXBOT0YzZEpnUExlOTFTcTltWGU3ckExbmk0UndwSUU1TENyb3ZScENvbWUzNUJhazRDMUQyNncvSmVJY1Ywa0pKYWVnU0lmYWxCQm95ZkdvVU5iL0xxZVJGaTMvNGNZVFpzeXZMREdYck9SeHVTVndmRG5Tbm10cVNwRXBGQWxQKzA3UVJKT2pVVGdvSHZNN0FneFkzSWVqcWVnc0ljOWhTd0dJdzJaOEt3OWlMZWRjUVMzdWZLNWdiMVBUdHYwQU53ZjB5QWlHZkpoSFBKWUlMNUtBak1aZ1NTSjRKbE1uaS8vaktWRHZXQUFCZzJCWnNVZ0V3OUxvbndobzh2RVl1NTBiQ1NwYzFoQ012b0s4Wk5weWw2S1VidXFLemJYTHlzM2ZScmF3djByV3Z3UnJNek9TaGdwM0o0M3FZb1lyUk11OUJiaHI0aUZiUVpXM1NxMDlVanZGbFVkOGFhbVlxZHcwdWczVW5rWUp1VjJKYTY1b1dHbHNhdHJQTnhsWFd4dGh2RXBTcUJTQU5NZlp5ZTdHcEpwQTg4dzZ0K1JwMWcxOUhXZzNCQUZNUFk3QjVCcHNWOURVcnpkRktGaFFvK1lOUzUwRlovaVlJNk1Mb3lQbjViVnIzODNTdkhrT3QxZld4bTlvYm9qL29UNitaWkVPVDhJUDhRMHZObVpsMWJjMGh3cHhrTEU0YmZ1N2JZYkRDWTd4cWZVeDJnYXE1SWg2R3JUbkRQVVVOMVhIU05RUGZYOGdVWWJsZS9sclJndmR4NW5xZmFZYjd0cDJ0MVBIV2NTcVpXblh6cjFMbDYxakxNM09Ea0Exd0U0TFF6UFhhQTByYVpER1RaaGFOa29SYlpBTTBRcGhCVk5JSW9QZm1uU1U5c0t6SXNRV1dqR0R0MXhqcHdSZ0RWWlQ1cVdNUzZDb1VkT0ZNVTFmY3VVeHNXbEpKY3p5bVMzQ3hzbERwNGMyMWVjOWZhZksyemdwNzNkUEdzdGIvSEt0NWZYTTYyczdpa2R6ajQ2QzJ2czkzMzR3TC9FOS9xeTRZdU5uNmJQR2pvMGRIWGZ0Q0hUTTRCK2o3NjI1L1dUM0JuWmpZaUZlL3c2TWVuSGhXcnpoL0E1NnBpTlE5T09jSTNqdHdodTcrWXFPalkzSk1NNW1NYVU3RTdNSkFzY0FPSlpMOG1JOUpJdGR4MzNTT3ZQNmpsUy9wS2JHVTMvRjhMUlUrdVMyajM1YW1yUXpMR25DRnN4Y3ZPVFVvK3pCNWo1aFdQdFRkYS84L1ZOZ1VwWnAzd3BweGNKVzhKelp3emJKQmdyaVJkV1c2bGcxUjVoZ0syVmVBcVBNMU9tMEQ4d3Z2eEl1bWQxUlB5ZUVOTEFrajYveGV0TGFYenZDYjl6UTEzZERmZkFYTDdOYU4xZGJCZExTSWtIRkwxZWtuK2lQRDkrNXRjQ1FrQkFhMUl0dGVYc3J0amJxbHJXdDF2VTNOUFl2S1VqNWIyOSsrU2tVZWJGZElZZG0vbW5wenM4SExOVVJTOTk0V2JGNm9UVmNsNUtSR3Ird3VjR2JXYi96b2o0KzQ5R1hxZFJIa3hFZDkrZFhWdmVrTHdSODZrY3cvUTUxL1B6NTg3U3h5K2MxaEJ3cVAwdnYvTHluTlg1SDNLcEVac3hHNnVsVnUwcit0eWQrU2NKL1lHWDZuODhrbjBaTGQzUmJ2dFZpNWRPWEtkU1FyVXBOMUJ4UlJtUmtxQjVjR29heS9vdUtHUTlXTVh3UG9QUE8waW9GOEdVNzFKVUlWMysvZnQ0dElVU2FNYjBkV0ZadzVVcWV6c2czL1luczNTc1Q5YXE2eXNlbE1DaWZhVTVCMWVncVJLSFg2ci9xTEMwTUJpWWZXZDZZR1hlbm9YRlpOZXowdE5ySmJETzltQzR5eHY5Vlc2Y1lwNXErejhTSTZTOXVXNk0wWHF0ZTIzQTVMcGsvaUJ0VUFVdHZKZ2xMNGd3aGY4dDZmTEVKc2dvZG1hQWpZeVI4VGNZNHpvdGdPWWFBM1UyY1FSTENidVNlMFhuRmZSS1NTQktNa1JlOGNJcnd1NGx4MXNZVDN1UFJrT0FJS3dXK282azNDQVRPWlFKRExzblZTaUdyVnBrRmNKMHp5enk0akVrNlo1RXJFSHVXcXYrRVEwYUNwVDQvcjdLNzUxaGVzN0loSnpieGlQcUk5a0hVUlNXc2pWOUxTVC9MeEhuL0luN2xaUmF6d3FFcEhmdGUyNFkwM2RRbWFkYURXZXk5azRoTWYydmcvVHgwbktvVHFjQlpYVzNEUkNKMU1sSTRsRUVxMlVMOEpJeTRQazMwTGJwMzJFLzh3T0x1NXE0MW5CY2xGNmxZTnJhSHZ5ZktzUWdJMGpzd2FvT3gzckxXQXZQVzlsN3NqUlVpSEVNZkVyWCtXTG1RZ0tRUUhSOGJpSzVnWkFGTjl1cnNvanhocEFFNVJpNUpaS2s2R0N2M3NKOXhIRnRzSjlTTEVzUW56V1FrVGZCVXlWNU82VWJjWGVud0NoN3Z0Z2lCdXAxd2kvTTBEOFlrcmhKL1dkck91NVlzOUpmNWgvY2dFNUkyMnNuaFZrc1dyMThHcnA0OUh2L1pzMWFyWCtlTlBxU2tzNTdkUlNTTFZzWU82M1MxSXhhREhVbDVRWWpsSDQrKzlzVGpJUXFpcVRDOVF3KzJEOTZrMFcxTUdtMzF0LzZyZGJyVnZPR0x3MGd3RjExa0ZKT1QrNWk0T1VkUWowM1RjS3FrVVk3eVVwUEc1TkhXOXhQL2FtMzdXd2RrblZFdG9MTEQySE5pdllJK3B6RFR6bm56bTFLZnltaStONmt4UXloVVpXUkdSL1RIZWhtTllCVlN0OC8rNjNJUlIzMEtNNW41SmhiZHdRSURLRlN4bk4yS3lDWE9KZ0lpRVhVMElsaTU3Tjd1aW1lNnFYR0taYVVBSTliOVRFWDN3MUJJWG5WMVIzUElJd2hobEhXWXc1RERXVCttN0gzQ2VtSGZsaktXaWhYQ2JYSHNvMlM5L2pQL2l2bzFkVEFDSWhxTWRhN2tBMm9CN0FSWHl5dGRYUENGcVVuN1ZLcnl2NEFwYzRydjg5a1dSZnFzRFBrMUNaOTU3OE9aU21SOHUvNGJldjVacEQrN0IxZHRiSy9pZloxTDN4QWoyVFJ0MmhUZWR6OW1kTW85VmlSVzA3a2dQUDdFOXZVZXA4enI3OXYyMkNONzBVOFNRZXR3WENSRnJiUFZmeklQY1V1aC8wMllEYzJHbGhibmZVODg5L1RUMTU1U0JnN2VLQzB0cnRIWGV0RVZ3d29BbURlbXVXZ0dJOEt3ak9CMkRISTZRY2QxREYrK3VpVlUwMGpkMXRDSzFReHZ6WlhMdGFNMGRpK1BTQnJ6S1hzRENyYllxUWxtY0VLZXdCS2Vva1NDSkhEWWh1aWRKVWlJNnNJcWhoU1lUVk9rU1VjaDRRVWJyaWY4WGhPVStpZ3ptZmtXRnVXN0FERkFvNkd5bFNZclltL0NMRWkzVjNsaHYrL1pjMHNUMVh5NitHVlZrOEl2RFRpeDB4ZzNoc1dZUXl6TElGb0h6clFaRTh2SXZKMWtobVVSTElQRlJKTjNhOHYxQXFLSysrWHo1OFJLckJMTEpIUllQUkRyaXgxUVErVkNJakpEVzYrWHB3WUNxVXlRaWJtT01qZjFONW5RNjRLRDlVamQwVkovQzJWUENvZitUV3J5eExxeUNRSlByYmRPZ3htYUdGVkhpQkFrWVdsaElQNEs3S2hkYzhaSENoRGlvcDlJUjFpRU00V2RHaFBKQkpqMDVPbGU2SU5hV2tnUzlWZXNMdDcvSmd2U3JhTVhFazlyNXkxWWNCdkQyN1R3NnIvV25NWDlDSzl3R0QxUHlOemVOb3YzdG5iNVZhWGg4VTZUdzRtaldHL0l6aFVkS1FBd3FPdVZGUTBOT3lxcENxZ09zWE5OMjJzdDIyZTMxVmtwMkRhN0hTNkU1aHZ0V1hCVWRhdy9QTFlZbEZSY1lrbUFFWjJiNnpoZUg5QndUQytka08yQjRDTmN3RDVkbGdhamJORmozRFV3bVQ3cGNta0pqMmRTSVU1eEZzVWtWRmZVcUhhVUt1ZE5jdVYyY2xZaUVvQWZlbXBJOWlBa3dyTEpBdVVoalVraGl2aFNzZTVReG5GU2lXZHZlZU5KcmZxN0dzNHpLdnNOWTduL1lqWTZBb2xzRDgyYW9ETlIxT3ZYVlljUkVUOHh3WWRnYkZvcU1Qc0Ivd1BUbjNqOEgzNTRNY2J4M3JyWVQ5WUVITUduWFZ0YUhCVU9sN005UXlkUEsvNnlUYzhhRE8xTlJ4MGpsbWtUWnorTG9xUVRQUGQxd2pGZkdheGp3QkkySkFKeVhOOTFZOXhEWCtkU3ViR3o0N1Z1R2hqZ2UycnNINlAwZjN3TmpJZ29YYnhqS0ZQVTc4Q2E1VFVsNkpRdS92VGRnUk9tUGhRQUM4aG1XNkgySktWd29PL1dRZGcwY092cjB6VVYrNlQ5ekhtd0FXZVBCK1VPd3dNUERPMG11L3UySFhydmZhN25LR2l4U1VTcTFmWGNTMnJFK3F0NmU0bUtWMTNYM2NBdENSS0ptRGhhd2hLUmZCS05sUUtmTlpReTVqRml5Znk5U1IrbEZDTjhMejBKaDg5VGFNY3B4YWcyNFZDNlk5ek0rMVJLOGNVRU5xWG9ZbUxZRlVvR0JZa1hpMUxZaEl2RkdsQXg0eVV3NGMwVDRQeFFaOUxlemNyVVovdXJVVTkvZHVuM05kSGZsTHhsd3BVekgxNCtnNlhMVmU5aE4zbWtvK0RWT25SRUVDM0o1eWNnZjI4d0gxaWgwTjFEZm5ucTl4OEdJTzBUaEZOekw0N0k4eWE0ZXlOZUVEd3hRd21oQ1c0SjlsaU53TGRQcTM3Q2xHU0h1ZDFmZnVrUHlzRGRmdnlJaFI3ZlZDRHNLajhNYWNkUjU2WkpFQkRMbXJ3c01oV1B5M0dBWjhFZXN4N1AwZW1VaWV2cUFSbTlCQmlVc0hReUNZa0NsckNrcGk1NUg5SzM1ZzFDaHFWNlBMK283TkZtemFMR3hzeG1VakFvUWRZNytzL2FLb3Y2NmlRcVlValI5cUt5YWUrVEszL0dnTXd0Sy9QYnBiY3REZW9iZENuZEZXRnUrMWwrMnNvZ3hqbzlIUXZTS2dodjlYU0NpSkhITDVXdlo2ZjBualFGcXB2c25uRDVTMTlpUW5aRWtIMTk4VE5YMXdZQ3QvcklpNG94eWh5bG9aMW9xK3NQSEt0NEVlNWh4aGNBVjBpSys4Q0JzcksrNlUyYm9KS3Zvcjc4L1BrdS9ra0c3ZEVZQ3RxZ1cxQTZzUTlEWFZUeVphdWJGMm5yVSt2WEV5aGRIY2RiOWQ1UHVIS0QxajhNN0g1YzhTQ2h5NHYzVU9KM3RhK1pTcHJSZ3ZmWEd6SXlNZzhVeCtMQldwU0dpQk1nQWNDbHFHbUFmRHNXdEdjT1pTNHNUV1labCt2TmVSMFNiZExtdlJpVUg3ZXRmN3UyREFmYzdnQjBqMDAvOFUrSDE4ZkM3UnpZY1RDaWFoSkFyREZrajRWNDdaVW9MUWt2RmF6ajhCaVNVaDRUM3RxZlRRd1hLWHVkSU9rSy90b2c5MlNqQlVkek5aS2tzYmEzaTZMWjZlbzgzaGtYcGdmVGxPUEQyZXZtSXE2WVVrRkFBb21BWlphYjZUOEhDU1lwcFFraWlldzhRZS95U0dwc3dLelZsdWVPMzNublVVQUMwa0l5a1cwU2RkZWdmdWRodDlzdFNvSC9RWHRUNmwwM2ozTVFnb1FrMmFPZ0tvb3EyKzdTcjg4dVFRYnpuWElialJHZUVaU01jZ1VGRUVRR3dONGRuNGhjbk1SKzYwSjI0SktGd2twb24zUjAzcU9qZXJiWlRvZWpDOVZ1MzE1TDA1REdLcnhyNG40V29KZzFuT2VpcVdnVzRDbWoxaTNrd3o2bGpDWHN0RndGSkdFSjBMdTVNbk1QMnhzcUYxODdvS3JQUjR2bVRGK3ZpU2toSFgvc1ZSWkd0K3pmM3d3NldwcnoxR0VycUhFS28wM0tHREhuMW1ScDlTTnZtS096WHdxUEtiOHVLN1hjWDFEeDNEUndlWkpMNWdQRGdXMHlrdkMyTkp1d0lWcWFTbFBBOFVkKzFMWFBVODd4aWI3dm5mZC8xcEdxbFR0eTVuOVBiTlFQWHloWmNxMitmaS9KNThOamRmVjM0NnRuN09NWDFxVlZPVjBxb25KTGtuWEowNVhPdmVkSDd1bGhQMGZTTVRSTUlVaGgxR0hUb2pwY0ViTHQxQ2psMG9rdm5rQUVnNzBOb3dRVHh3VVlXN0l6WWpwWUpTZEYvZVRybkNtUjJkREg3VzBQMXBrZWlOZFhKTjJWdGkwdHBHRU8zWXJKdm4xRHczZHhlQ3p6ejd6dUk2Uzd2TUtZWUZTODNGQ1U4ZmQvZEJVQjl3eFlMRnZTK1I3dWk1dU9DNGtMZmpSdnhEWEhlS0RXOG9aeS9maWJNaTRHcWdOeVNOZXVLZGRQTjk5TDFwdEZwUVh4OGhRTG1iQzJ0UTV3MGZZL0xXUTRvYnpGMnZuTCtmbS9UdjMveDFHaWFxMnZvOE4wTWR1Q1ZBN0lZcEZyZnlmek4yWmpUOFVPV2l5c3dFNDB1R3dTUWhEaENZTEptTzVJSDVuUnp4Tk14L05iV1lrMW5IMHVaVjdLYzl1RkRSZlBhQWFwY1lvRjc5aWc1Z3pZOEs4WHBrOU5IcGlVeDJ2R2c3T3puUjF4SFIxeTdib3YwaGpRcUlncWxYSm9KLzMreWJUSjk2ZXVkVkNwN3ZYc0dPRWFKMGxoaXJ0RXNQL2Zva3NmbjBMNitzeEdjNS9sZFdxY2loQ01SaUdDR3BYeTFnaENVa25Ncm5pRFpOQS8ydkdYVlI5UGR3WTJ4TzhhV24zTkhTb3ZPTHowOGp1LzcwSmRrellaUTd4MlZFcjVnWGpNWXUySnlvRDhKOE1QNnMzb1lMaktGZzNRdUxQRnpqbWNISnVIaFVpK2xwSUorMWZvbVFuSksyRUpCWVBZZHVXYWovd1hrN3E1UHJKTTIybDVNTGZJK285bzdNbW0wZitJdCtidXVlWGpvQWdGUVBjd01LLytubGs2aWpyYkZnWkVNalIrY3V6SjBxL1ZYcjU4dXc0bXVDZDlmRGx6SU82SWduSlE1OThiektpQk01U3Z5THZSWUFydHEzS1U1MTM4K0p0UkllaUhNdXdaeFVWVit2SlBGRzRCeStKV1g3TFRoTkIyZ21oaWw1eUt6VFJodjBSWklZUU9VRUhvUmh4ZWxKeTFabEZSY1Azd2ZLLzl1THROaEpKeVhTaDAwalFFbVJMUkpvbUx3ZmFYTEZmdGEyZFU0UlZMMGxWdHowYXBORC8rcWppR3ExQTdiczlRRi9vSzFYdHpuTE5nQVZ6Mld3YXlNekNQTTk1djRlNW42SVZTN3Vzb0Q3T1hXdWdySWJCSmNXQ3QxSFVWeTdPcTYxVWZxNGlhTlpVdU5CTk5aSHhvZkdUL0Z4bmpHU2YvdlNYSW05L08wT2lyMXZhUUlXNVh4Qk1SeHlieml6NHNNeFNTLzFMU1NRcmh4MzRFWVFtTjlnMmlVMFlhZGRRNFJmZjJsaWxLYUF5NTRsNkxidXowYk40eDB1eXNwNU4zMW0wT3VGZFZrS2d5THplcnd1ZVBOZElrZHJlekVqVXVQbkdCek56M05pSFAxWlFZbnZoUWt4citzbGpHK3IvOFVCWjF5WkswdS9USS8zS2NYRHZnWExhWTZ4ZW52cDZxT2FaVjdqS0NKNC9uS3VJWmUycWtHQmxGM0tFOFlJZk10VWpkdGVSSm4xRWdHWnhCbmhsVHEzWHQ2amtaV1hRTVptMWxWNC9XQlhLZ01GZlpXckZtdzZJME1sTzYybnVvRnNaL2J6OE04bEpoVGlBalpqRnY1bWFYL2pJVXlJcVJtN1IvNE1paUxvM0YzRjQxYk1SL08vMi94dVFvOThXbDM4OVEyYzJHYkN1ek9NTk0wdkxrM0liWGtzS3IyOHJtRWhNK2kxOFNjWU5OV3FHT1pXS1RsNnNTNDVPb3dPL2F0SCtzakl5di9GejJSS0V6RW8wbEpPR3VkZWdqRzE2M25WL0RSUUc3c0k1angxaWRqWFd4czBHTGlDNHRCRzJiNGljdnFKQzlzb1Z1OU1ORFNlZ3BtMWNlQlNRYUJ1MmpubDNQOU85T0dMNjFjRFk0Tk9KY3RqbWlhZW02cHZUSThWZEs5VU85Ujk5bTdmdTR2NDFReGVyQ3FyUWE1NWhsWkt1NTNva2RwSjVLdENHZFRPeVFWNHQvbDRsVVZnbE41UjVPcVJhL21uSWorK1Ayano5T05OVHJhaGI4T01ScVRZZzN5NEgrU3N4b1ljVjNNUFhXenVtWHNxS2Jkell0R1k1NVVPLzNvMEcvTEdiRTNjanpjUHVUemJZK1VTd3JJOUZuTjdWazAxMzVNeGhpYUlZSDc4elI0dklTZUNKdmN1aVBqc0ZIdlZJZURlNzJiMkpQcXJSUkx2NEUzVFBheGZFSzJ6RDNwaGN1SXFoRTZ3cTFJbU9FQ1pzRXFxUzZUUWxKbmxxNUJSa2srWnpJSXJ1QVBTWnRSU3o3eUZDc2tlbWNSRDdrSXFGMEYrcUEyNGtSa1h3RHYybG9VM0JtM1NreUgxZXlZbThNK2p2UnhvbHVlaC9ZYW5VWkV5YTRPRGhDK3FmZUdZRmRITXlRQ0VhQUhibVY3SnFKZEFWNWttWC9zWHY2L0k1LzhXZjZQck84N1dKaU9jSng3Rk04NWNiMk11TzZxYk1CN3puM29sMEdNbThIUy9FUEU2Y0pnYncvdGtYYVJ3dlpRcXhQVkF2K3p5czY4TWc3Z2JLU0Y5UFlpQzRKNitMaXlITVo1eUtMY1ZieUlyZG44U2NGRmYrd1hldS84VlhLVnpmODJ1MC93T2UyZTk1dXlHVGVmTk5ZRitzUGxtc3liR2dMdHJYVk4wVUYvYkYxWHdNS3krMEExMkY3MGRIQTgzWks5VXE2Z1FYaDJ5UzNEQjE1RUZ0c0gxUE11V1Z5bHA2aVBhY1IwMWNmTkF3ejE4WTBZMGVCbDdaMkNFYnFiK3JxN0VLRHZmaWVaRDl6alFERFB0LzJqTVJMeENKd0crUzRKVGRjM08rVnRpckpzdWtNeEJoaEN5ZHc3NW5BSEU4RzE1L2ZhTHFHWlR6QmFUWWlKOWJQaUM0MlJSRXg5ZDV4U09wRUlSN0FzcEptY3dSS2F1cHpZVDQwQlo1ZFgzNkZ3ZFBmaHl3SHhxbWh2eVg1UmxBRzdiN1IzSHprN1NNai9zeTkvMzlSSlFmOFZZTEpCOUJCZUw0OWN0TUg2SU5OZm1HYURnK2RyWHYrK2JwUnRZdzcwb24zV09YMHJDbWtGSFBIY0VlcjRTa0hWYTlKd0Z2M0pXanFsejhUa2h1aThKbzJIeHNlNEt2S3I2ZUNzYVVuOTV0YU5MWHJ0QXNpSzZwTUV0WkFQMExCR2QwV2JiWUMwbkN1OW8vWU1qNDVyN1JzZWVINjlZWExYKzNuTGN0dmZOKzhCa3IwKy9WUnM3V01aa0tUNkI3TUhIUW5XZ1hNMnJaLy9pcTFyNFZ4U3VZTHkvNG9uSnMxcjNuL3ozaFpiTXRJQk9yT0ZpTzVmNjJwcjEraTF0OW81cWlBWHYzU2hvMVBSNTh6T0R6RE96RDBqYjVOZ1UxOSszT05rNU9TUkFKWnkrNGJ3UG5ISDE5MmVvOE1ObGF2V3VQbGt4T0RncG9wcUlOSWlVcTBJRnhrNE9WYkd4eUN2NDhMWXM0S0RZc3owbFZZam5sZjE0U1QwZ0srWTFnVXZlNmJDVllZNmxUeEtoQmwvUXBSWEF2TW5xWGNFMFJpbGhhaG43MDJvamN2MU4rWjZRRTlONlV4U3R6VWMwSHpsbmNNeTlGTlJ2TExTVFQrNjFRRjVVbnRPWUc4MGxKYnJlaHd4RHgveDc1NVF4RFF0RnIwdnpSZHNYcm1zZTNienRSclB6WjBkWEtOc1luZjN3clBHMWxDRkEwTmJCMTRFTnpzaklkTldMY2c4U0F4anJQSzFvbWhTMHhXZVVhRXBCV1FGamNBNkozUkZvQ0h1TkJ3cmdkekhKS2ZGRi94R1FxTmlXOEkzN0NzakpyclMwajZjeGNoZUMybVZReVVlTjZDUFNzRVpuM0l4M0tjNktGT0tuRDNPNVBIdktTWGVGNXNGV1FBc1hvaU1SUllyYy8rTE4xYk04MjdseG9laHBtTDFzKzBONW5aTFVtZlpRRElLdWkyWjMyUk43emI2KytyMmxMYXF0TDFtVWZmdnAzNFVFSjl1ajY5QjdTVmQrRFZLdzFYVm5rZnluLzdkdVdQVTZhSGFuVlZDb0NVNVZmZjVDSHNjZXl6djZDUjQxd3VYUFBSUi80a2FtdzZseXdCL2tFQkhBRTBZTGprdnBDV2lweFVvZklkMVB1SDRJTkxJa0dCdDJJSGRCQlNTeG9hbENlTGNDMXh5UG90NFEvV1BId1FMMWxUbm5YdGlhOEc5UUVtUGhEOElSRFBtSGU4dGZYWkNLcG9GYU9VRXE0QUNFdHVFb3FrUXJzcURJbHQyZEs2N3hxaU9jSktTR0t2MzM0QllMcFh2Y2c3NGY4K1ptNUhOcWtkeXdyVE9NdlNKdDNQUi9PWWVIZUlVd2FZWWNSY3YvOEhWV2NiVEc1TGRmemd2OXVmWkZTNFNhR1F0L1VxSzZJRHVXTkZTdTlDOVdXT1pmM2Ztb29jTEV1NkIrZWMydjlsalIyU0IySVdKQUVRaDlaZUR0ZUwwQS9CY2dIWmQ3NC9wRU1iWjA3UE82WDlyamgwSVZvWVdyekxkYXBFYVk3VGRvUXNDbDBZMGhueWNuRWxweTQyRkhVVzVYME9YREZ0NTd4RmZJdXNteWpkc0tGMGNmTHR5a3I0L1p4QWZFajAvcGxNbVRxemFlU3dwYjAyOUpwUWNFcEU1RHhQbWdnaUxDSHBkWWRnRUhmY0pRVmxDNjZicFlnREpRSUJIcXRvSnM1T1Vpb2RRNjNCMWNIQ3daYTZjQjRueVJJUXQ4LzhKUGRjMmZWMEZGbXFzTzg1R2dqSFo5eFQxM3hxL2kyVkEyYm9sZmFxbWt0cXp0VHZPUTRGTzZmQjdxLzdOemRNWjlnbWU5MVNJQzRjQWhsWVRoRjdhZXVWVEJPL2QrODRUZWFWclJLeElSN3RFdHVtdXlKTlFwS3ZPang3QlVKRHpFR2hES2NXUGY5OEVVcnZPSXZXL0M1V2VTcUVPUktpNTNnMDZIYi9lMXBEMTFiYWJNRnNreUoxQllWMXRRTjFkUU8xZFlVRkN3amNUaGtuWisvYzliQzMybGVoNmhVSHpldStIVXBZekM5T0dGb1dhVDY0QWxWWDliejFmK05rUGVTZlc1ajRtenIwZHBuaDAvVDZkWmZQOC9TQzRvVUxtbjRhWDFCaStNUlFkaHQ5dHZQL0FFTWhIU29XTlRqcy90NXJYT2t5Lzk0Y0kvRWZIQjAvNTBOczNhd1J5cVhwNmFHNlJYVkRhOXBhYVpWNzl1d2Q2alVGcGVONVVCZ1lvUHZndnNDeUlUakRzY1JDR0FVeHJBOG43WGNhZ2tFTE9HNDFlOVhyTUtkdzE2d3pmUDIyY1A5aFpCUFJJWXhrVFU0ODdDR0VCdzNDNXZCV3p3NjRNMDY0TTNoL1JsV1ZQeWhQVnJUaWR6L2EzRUQ2emxmM0M0RndRaGFOTFNNSjBXSkdLMjU5alBBRVM1WXhrUUVneXh1V0hnUnVFeFMyRVYxQ1dZOUJER2FJc2pJeVFyWkRuSkdnOTUraTZaUXltVm1FR0FSeTJSZG95U1N5TWpzMWlXWUgyTkdnbVVPU1NNWFNVS3VlK0t3UE1kbFllQ0I4Yy9yQW1VaTYvS2xLUWNVUkZicDBNSTZWb3VhTXM4b25uK1JFM2xLQUxCYnh3cE44MDNFbGRIdHhGb28vZWhHZy9NVm8ySm5zL0dZRW1yLzUxUHp2VkJIYWo2cWEwVGQ0a2RkN05ZeEl1MUt6LzdmWjFsc3NIZG8vNlErMEJnclBjQVlKUXR2R0MxNUpnT1dJVTYrdzFBK0JzNjlleThsRkYxaDE2T3hnT0xJY20vcFpISjRXVG5OS0FmUDRsRVFYSlVsYXdvb2hxNjBoQllqcnp3Mlk3SmhnMlQ2cmNDaHdrRG9yWUFVUm9KdkVPUkpoUEZhTUtPWWdjK3UwclR3aG1UYjBiK2dMdTBJOUZIaWk5TGlHMFJ3M3ZCTVM2bnlZOTYyL3B6bWhtZUhNQU5pTlpaUG1FUUoyZVpMNEJWRDZsemRhUHBubHYvaWVmWXQvN2JxeFY1dnhJSGZ0dm1FeGE0c3lNMkNqanZGOXRlYk5pelBiTXpzMkwzb3p0MXUxR0pwUzBLVld1VjRNUUR6aTNTTWtqZDVicjR4OENGeGczc0hadVM1RGZIZEp6SmpHVXF0VzVjN21xbUxieTNObHNMREJ6NkNCTTc5em9uakZ4U2pIZ1hPcm9ldmVYME14d2pSbklKaGNDdlQwZStZU2ZYVm5IS2Y0bDdBa3ZLbExTTUl6RlptVVNiK0JVMmlLQldlOWJ1SkZJbGRVMkZyRHEveDNwOFo3WWZiRkNyUVhLMlZucUJ0RGpvY0NhR0c1VE45enJNOFJ0VWpaT2JJUGJ6RWtSTGQ0R2VzYVQ0YWdsNVdub253MHZMK0JnaWlxMXRHS3FIdDRSNWZOTURLVzlmakNiV0dUMUpMNThibmJEeWxyT2JQeWlXQmVZcUt2MFMxSmRXMXVUOEtrN1Y1MmtPT3JxQXNtbDhzdVdhKy9xN0p0TjNtNjZ1RTVic2FxMWRjcXdYR3dlclcvcGZuMVlEUDk0dERPS0l2aGlXM2xIVXc5Nm1ldndUbENLMHBKUmR6R0ZaVVU5S0J5N2ZybTlpQVdlMFc4VzZ1eFI1U1VDRGIvRm1IZkFLNTg0NU9OTi9FWWNrdGoySlJZYTRISWhqQnFGTWM5K3FoZkZEWDU3cnNoR1hrQlRqTENFS0Frd1UrQll6UmlmcjBMT0c3VEp2UlVGMGJOUmd3T3dxUUJPNFFKdGlOUXFEQmpZcnVuSThoSVQ5RktKVXV6T0M5TkF5S1pJNDV6MWF5UEJTQTdiWWNpTkExZ1F6N0J1a1NVaUU5TUpxblBvSXU5Mjd5OGtVd2dIaEhPMmlJNGdrUjBNUUVKc2ZGUVlBWENFektqOWRoNHcyejlFbUJPbEU0Tnp3RkJzSUc5aWM5SmMrS1BZRjh6TURoWXdXVlJSWC9uaDFrQkhPd3pNT3ZYUGVma2xETDBnbkw3MTh4WEVWWG9ZOGFMOFlWQU5INGYvTTVrY21IODJKajh0M1ltYzVuLzdQSmFPUGQ3N1pQdWoxY29sL243czJzUE9QOTMyUnZtNzZ2VUI1cUNNdXVPaXlBY3lHR2xZa2d4QnhrV09CMkNFQjNOcmNJMVlWYjBJY0IrM1QvQmhDVXNvSlFWRmd2Y00rTnhZZENJZWV3TGsvaXE0end3V0crejNSU0VXRkpYa0RIdnpqSmxTNnQxU3hOWHp4bFcxOWV2THF5cks4eG5DQWhObTBrU2tJR1ZYM2xxWEpiSFQxWFVIaytJSmxvTFFkS2FlMEhxWnJpQjk1RExrcCtkVUh6dUFVTTBWUm0rSVJSS2kvNFpqN0RSWnhoaE1DUWhpY2NTRnFVY2M4UE5IaGFOTVQxZjBYcWh6dnBRa2JIVDlpZ0NZMHJIYUV3L0ljNE1RRDdHR21sQXJlblF6R25IbUZITmhRczBJMEJIOEdKbllaT05OYkdadEErOFNaWjRpV1Y5TE9nVDljdytkV0wvOTNtMkpTOGVMZlJzVDM3N1hYMXgyMXViU3Nmd0dGeG8zdkxPMi9zMDlmUlRnMFI3YnVQM3AyMUxtazRlZmNDeDR4L3l5SmVCZmVpeHJFM2ZYMHNtYnVtSHJFT01tb0Z5V0JwcmNpZDBrQ2ZHUjFoWXBOSGcvcDhBb01HOGlmQkhKcmJCR2NxQzJML3JkWC84dUgvN2RvZmYrekQyWVFVaTgzOE9UQWtDSDk2aHhVdnUvNlk5cHZoSGtwa0hBQUM0c2JRY0dlc1g3cjhIb29iL0IrYWhBQ1g5LzZCeVFQdHZlZWVBLzFQYVpRajhyeEpRM1dmRzliRXdwbG5Nc3VUTk4xU1IzZDZHSmFHeE5QbnVMYk9qblN3aFVxOG90U083NjZFVHMxb2FnTXVEWXhhQURMSDJHa2FJckd5L3NCMkw4aCttQXdDMDBmWTN3aHVtNFdTOElJSVBZMGkrMzA3V2lQRlRPd1JkZkNqRHk1MHU3cVlQeDVSZld5RUFkSXZGaXhHQlh5dUVuZWJlaWVuRnFHN1VCN2c4Z1paaHpmalE3VklBU0RlU2RPWXcwWWJzbjBraVJmM3E3SkJVUmU5V0V3YjE0T3JiaGNZMExRS3NJN1lrMHVaOXVDd0J0dHV2NkEwZldFUE5SQUdpU1ZGbll2bUpRZ2Jtb2tJRnNROU0wQUpZTjBNL3JRWDZCTVdLUy84ekJtaFd4Q3d3aWZWNXZNQ1BuUVFBcDJESE5LSUVlQm1lQ1M4a3NSTjZjSktkUmVKVmdFZUtKc256NllRSUhBN1F3aTUxWXAwRnJaRW4xNEEyRTdETGw2S3A0UGhzSVpxQ1NiVVFTMHo5d2xpS3doM2FjbUVkRVNNNnViUkk3TGhhRkhVTE1JUytuWGkzeDFMSkFFMk5JdWpERUg5UWhOZUVDSlZmaVRTMFlTQzNLSG5GaDlDS0cyWmc0Q0Z3TUNaTmtRamNqM0dJSG93dDhkTTgzYzh1ZFFJZTVXaVlLT2pQcXlOc2RSZzJZMkl0R1NBa1hENkdCcUFwaWdvKzZ4TlFndTBoWGc1QVJ5Z0tJa0V2emdLMUpBMmxFdHU5SEpGV0FEVHF1TUI5UmZiQ0pNeEk3Tk5aM0crUGpEWURGaTVLYXNKd1pGam1DV0sxUGh6TS8rUkY1NTlZRlBMNDdXeDIyeUpONTJ2WlhRQTY0R3NONG00b3o0ZnhoajhmWVR0YVJQdlB4N2hlL2VSeCtwL2piZHYzN0xSdDJqeWdXWjZiWjNocWxkdnk1cHUyOU9vMTFmM2QyZFJLdGxEWE5JelFycXEzZDFmdnp0MXplay8yMnM2QmpXMURnTnVydTdmMWg3aHYzelM0cFZOVTBhQ0IxZDY1cUplRm5lMnRtc0xjS05DMWwyY3R5M0NRUGZGUWU1Y0ZaSnNvRDh2T1ZlcXMzSmRsY1pML2wvZWxnbU9NVndBQVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2Fzc2V0cy9NYXRlcmlhbEljb25zLVJlZ3VsYXIud29mZjJcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjI7YmFzZTY0LGQwOUdNZ0FCQUFBQUFQeDRBQklBQUFBQ28xUUFBUHdUQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHb1JpRzRHN1RCeXJFQVpnQUtSR0NGUUpnendSREFxSDNDU0crM01MbEI0QUVvb1lBVFlDSkFPb09BUWdCWWdtQnlBTWdrbGJ5MmVTNW5RTW1GcGZZSzJzcGRzUXFIZWZNMVZUZUJ6UG9ES0dDWlhCMEh0MWp0VTllSlJjYURFbmNHZHZ4SERiQUtobWJVNkpMdnYvLy8vLy81Y2xreGpUUzRCTDhnK0FnaUlpYW0xdGE1M2RCaW8wR2h6aFNOa0NkWU0yZFVyZlJOYk1WSEtqYkR2WHNoeVVjZHhSMjFlU1U2bTVBbGx2eHQxaFJrYXUzbEZka0U1WVpWVHZySkxwa2hKcUpIM1VXWUdUMm04dis0Wndqb0lodkx3amkrNHYybVNHbW1LNVlscDZMQ2toS1c4R1U4d1FZaGtqY0lQdmJtbHB0Qkh2YWpScSs2RnRKMVB2VVRTN2FZWlAxZHQ1VXVwVjZ5d0xGMmJvWk9mZUt3YlRpQy9SQkIyTFNmSzJPYWt6MG1ESTZmc3hqQ0lDTVVzVGhra1l3b1VkaWNiWkV5bk1pSnJvM0xTZmpaR2tJQWtLa3BLQ2tpS29Ha2pLNTUrTFkwZFo3K1g5QnkrNGRGZ0JxOGgzRWpPSTF6S2d4ME40Z2MvaUxQK0plSXEyeUxZNlQvV3lIc1RLSy9ibGgwN1ZzQ2tTQlZiZGxZT2d1T0YzbmFrM3hWcjFjRTBpVWJ3cTU4ZmJOc2ZieFFLTldJOEJKN2EzRDBlQWY5UGQ1ZURaSDNSMms2MU1kYmREODhoTEpKdzl6bkxXamFYczVFRFZTbHFuK3NPRTQydU1iNUdFdTkrdjA3OGFWL3dIZTJvdXFmaUFsL0tXa09TdnR4b3hxNnhjZ3cxcWpWcWFEWlJtNnJCdnkzNE5pSEJzRGtBVmtWUk4xdzNURWxzY2NXMVBtNS9xRi9ybitibWNjKy83UDVoVkRLMllVSGRZRTVhNnM2MW54UzFiRjRQay9Udy90ei9udnZ2ZWtnRmp3aGdEUnZXb0VaVjI0ZThpMDI1SzBBYUxOaHI5Z2ttYW1BVUQvRHIvdlF1ZEc3TnFzVElXV0ZqcGI3YlA5QmlqcCtORW5idkRIY2ZwZUUvZGNlcFU5Q0lIYUpzZFltN3FWTXllbVZoZ0lhaUEwUmlVZ1FVMjJsZ1ltSWdkY3hOemduUHE1blJ6KzgxbHV2aEZ1K2dCY0Z2aGJEQ09DQWx4Y1ppbWpVVU9NSElTSXBFaW9hRmkwcjd6cUZ5M3B2UEc5TzV6SHM1N3BhWEJEVDBpWklzNGNNeUdLWmdNWlNpdUs2aWVQOWk4Mnc5aVlaQUUvdjhmc04zdHZ4T21JVVdXQlVFRklhSENuSEluZ3FaTkRpUzBQRlV3YVZYUEpvQTd0T09GMFQ4NHArbU82REFuQ2d3QTJ3TzdGWWVsQVJseFoxZzUxak82RFJEZ2hCVWlYTE5RQ1REVmZZWUlOVVpzaE5hblF5ZG1RaThqSUFNR0NINTROKzBsc0hTcG1ETXFMb2dIbXJRRXF3bFF0UUExVms4blNyYVR3b24rN2V2dTc3NSs3c3VzQ1FJR0FONDcxL2ZlR2JINjJ4UHFqRUZWcDQ4Y2U5WThCd3E3SDduTndrKzdYVXE3NlNTWnBwa0R2TFNsQWdOUkJjUXlBSjRCWlZxRGZ2eVZIT0l5ckh2U0JZQ0tLbjI0ektYTy8zL3RTcFlsR2FJNE1pbUs0NU1jb0xuN2lEc3VYMTBSZnNSVUg3Z0Q5RTZmRUlBUzVteUZiUWVZWFg1SWlpUUtUOG9SRzdHUnVSRnF4bTh1bUkxRWFReTRzM3o4UGQ4SGFXeGdKTS8venh2dSsxVklITU1JeWxqVDd5VjVrclVXSmJxcUtzQk01SHRkNVAraDQybDNadDRHQlYrUHNNQWg5VDJ3RFFiSnVyK3AzS3huRXFDYUtqYXAyOU5DeFFJVnM1d3B2bFVOVkQ0dlZPWmYwUy9QTTAxMS8zNXVCM1hIL3cveHVubkNwMERMbExvUTBaSzNJZGV0L3cyelJES2x3aVpiVndNdGZGRE9jb01WbmRuWENta0IrTWJNRGFjVXhvbDVESlc3NHo5cFVsSnFXaklnMFNzOUhnZ05nSXF3cElDVmZ5N2tjTThqSkJmNnZwclJZbExNckpSSTJkTnY3bDYzL1JwdENFSlloTkNRRUFLMy83Zk1xaC9HWjdpTU5MYXlzcktjU21xVnBvM2IzZE9jcyt2WU9mVjVxTVhuQWJPUDY4empjNEFWZ0FLd0Y3QWV3QnIrLzkrNS96K0FBUXdaRWJtS0tkMFhFMWF2dGYyLzZsOWJyRDNIR2Q1L092dStTZ21vMGtWV2UxS0lQOGNiTUxpTkkyQnIvUHhmMjkxSXFvMWtkbUJ2Znd4bkgzS1FVSWVaYktLei93b0dMRm5CeHBpNGJNZ3ZkLythN3N5Y2FzbHJKbDFEeHd2eEUyQmpWQTV5TmZkdndNRjNVQWZvcW5FODRlNXRrbGNnb1lCVnA3cE9WWmZWQTk3alVwajRkeFBUZGdFUWJhM2Y1SVF5L01zTERTc0xBNVNIci90WFRkci8ybDA2V01BNjNnMHR2ZzNRQXVaanFVc3E5akRZS1Znamh2MC9WYXZTS2dLY0J0Mk9LTzIrbFhiM0RHOVA1MHlRVGM4Wlo1T3c4S3NLaGFvQ2FBQlFhb0tpRENsSHRSV2xNVkt2SVVEMU8xTGR0MC9TZXArZGNXRkxyZlUrUHVPRDFJWStpL1BqQVpwN3RjbUFoRUdoMFB2ZmQxUWdjQnRMb0Z4L1Ntb2tGYnFxMlFsanh2UC9mKy83K3ZhWWx0Q3lxd0U4SXk2dG5MUitLZGFhUlNqb3BYMzZmdDljMnZsN1Y1Z0NxWHRWRjllc1NyeExwcmluQ2tEcnlpUk1wY3k1SWtsQWUxVnNqQ25QLy8veVMrbmJrbXovZ2dOWVh6YWZxUUJ6aEx6K254NVBuU21sY3U1cHA5QVBTcmtjUWtJMlk2NWwxSExzWlFDTmpRUUE4VExuNWdsYTQxZm5vVHQ0cU5lK2FHK0k3ZWN1TEJJNlJCcTlFa21SK2RlWnJ2cW5FTkxiRllhM2R4bmxmNzVLc3V5YzdDTU1XMkdXZmVTelEwU2I3VU53Z05oSmlYQUVXb0czcmt1WTEwNXI5NkZUZWUzL21XcVYvdDlOY0VTQU9MSkxzelk2YTRPc0dqTDJuSWxDNktPYkgreHFnQklBamdIRU1aUzR6bWptakZmOTZxYlkxYVNXQUxWR25OMTNXcDJ6UGdrdkNYYXp5eThNYm5ub216YWQrZGZYbWhUcnJsR0d2bzRJeDhPWW5Hb0tLVUY1SWdQb2YwNjAvK0FYN3BWRVNOUFdsTVdFVFl0ZHFsb3Rsb3Vkc3dSclJoQ2QyQjA5ejQrcHZ1K3VaRmY2SU94QUZyQk90QzVRNytlSEVGcExuK2pQNVkycm40c0ZmTC9sdjlLNXMyNGRvdWZWcGc0aytlT3pSeTZ0c0FDV0lFdmEvV1dVT2twOVJxRU9ZSUVCR0JuK1BZbksreUdCcmJzYVZXUDE1bUpVZlNkVzd6NjdUWHBNeWl4TEdKWmdCcEVhSTR3d3dnaGpRZ2p1L0tNM2lOdTRSN0NZalFaTGtIRU14a0Z0R21YVzlqdUxMVVNDQkRuZXVwVE1wU2hUZkZGR3hIbHgxaG9ueGxoTGxWN3kwRk1lS08yeG4vSjZjS3dZSGpHQVpxQ3lUdDlhYmIrN2pNMUhsb1gyYjcyTTJnQXZkWHB5aUp3QzJ5d2c2MTlRR0R1c09hdGRock4vNjU1OGt4T2ZRMHVMQnBJUTZIYU16Zi9uNnYySVdEaDFMU1p4d0FYNG5qMzkvNU11bHJQbzRxbnZxbkZGVlZWRlJSd3g5ekxYOS9DYWU2Vzd2OVR0Z0tBZ0FaS1FOc2xNaWw2aXk4WW0rZExTT0pJT2wwRTNHR3pjbW9TNlZmZno3d3FDSUFFQWJFc0lrMWtKaEVTWUFmbmQ3NUJNbVpCczJaQThlWkJDaFpCaUt5Q3JySWRzc3cyeVN4MkdSbzJRSnMyUUUwNUFXclJBMnJSQnVuUkJ6am9MT2U4QzVKTExrRzdka0J2dVFQcjFRNFlOUSs1N0NIbnNFL0ZGbmhpVEFNVWdBeWcrQ2dDbFB3VW81WlNnVkRNSFpUa3JHTm5QQVpUN1BFQnBwZ0hsTjM5UUlmTUVGVFVmVUhIekI1V3lBRkRwQ3djMWZUR2c1b3dBYXQ1SW9CWXRFVlRHVWtCOXN6UlEzNDBLcWlrK1JzMXRJTHFTSHVwUkJxaFgvVUY2MDEra3p4WElnQWpRR01JQUdvL3dBRTFBUklDbXF5NW8rc3BCVTZnQXpWWmIwQngwQU0xSko5RFV1b00yVXlKb2YvZ0UyakRaamxtUnA2eXNsNjJLMTYvR1Q2eVp6Nnk1cjY3MWI2NmRINndqbnR1SHovWVhzSU1FNzFDWWpkVzNCK3p2UXovM2I3QXVUd21QMVFJRUlRQmxBTnRDSk95eXkyNjdWYXRXbzBhdDJ0T2QxYXhuQThMeXUyM3ExQjBmQXBUZ0poNDk1SnU5QTRydm9La0N4YStwMUlIaUw3UjFvRUFCaUJFQ1FKREJmeTBUU003NmFlcEFCaEFBQ0lUQW1RNElJUGdnUWxnc1JVTStLa0tJekRqNkRNZ1pVakNpWk15S05SdTI3Tmh6NE1pSk14ZHFydHk0OCtCSnc0czNINzc4K0FzUWFMNkZNbVhMVWFKY3BhVWE3ZFhJeTFXb1ZLVmFEUWhzd0tsRVN1anBHeGc2STJWeUk0V3hpYW1aT2FWVVdYQ05yZ2pkdng1ZVNGKy84SWoydXk1TjFPVnFzOXNESUFRaktJWVRKRVV6TE1jTG9pUXJxcVlieC9QMS9ueFREQ2RJaW1aWWpoZEV5ZkY4VGUvUDkvZWZsM1U3VE10R21RQ2lHUTZYMnlPU2tKS1JVMkFnRlZWMVRXMWRMeGdjZ1VTaHNUZzhnVWdpVTZnME9vUEpZbk0wV3AzZVlEU1pIUnlkbkYxYzNkdzlQTDI4a1NnMmx5K1VLVlRCcy9MbHFJTHF5U3ZDQ29BQUdNSzl2MEIvS1FENjgvdmwzWFJydGRaa1dRUC9HL1YyUVYzaG5wcEhSUWRGKzJVS1BQS3htaW81VWpMREZTNjJQZkJBemVXZkJvN3hxTTlIRUNyNVY4Wml6MXkvWVdHeFhWOUsrcmJPbzhQSW80TlNNTGI4Nzh6ckY4djhDbE9WcGJwUmkxQk9yYVhXUTZoQ1ZUdXZRK2xTdTFYZCttN0xvSDdRTXJnd1JBd2pNSUNCOFVrcWFzZE5ZK3pCbkpwL3NYVm41K2x6TUpDc1hNSFd3bXY4K3VlbUQ0bmJORGhiZTI4NzlobU1Qd1AwWnEwYmVidFFMejhOQmp6TDdtOFVLRnc1NzZTb1kydlhzZ2VCL2JJUHFMaXg4aGkxYXJOMXRidGcrakEzRnVPemlic0pXSjFlYVc5YTJtT29XOUVYTkdMdTF6RGMvNUl5Q25jd3NZelpjYi9HQXdOWFJEMW81OEJTVHQzLzFzNFMyUVVIVlNGYnFYNldpZzVROEtKZUZFQ0pSVUxQcXFFSVdUaGxhZ2ZFOWdybFZCT1F1d244SEJidFBlZEduSEJkRzFZSFRpNngrTjlDb1RRd0VGbWFtaFBDclZObmJWbTNCMDRHRkdrcGg3d1hzVVV5Z0hzQ1dVbHpZbWZ0QXNOQkc3QVVVUjNPZHgyY0NNUitWMEJ1ckpEQzZFTUY5UjJjb0hOTjNmS09kNFRpOGMzQlBkTkhpdW1Od2pVMEZGRFVQc3dOZ3NEczVsbHJ5RjFDYlFmbWdNSGprM0l3cU5WOEhHdWpnWkRCc3FXeVFkZngrRW9xZk9TaXp0amNYakxyOVJ1TCtyM0tnbFFEd2phMDJ3aVF0b2dJTVFTOWx4UXI5bGdDekpmb1NrTUxiL3pmT0w2QzZJc1FTU2xHTEJQeGIxRkphczJrU0dkdVFxeE5hbTFNTVoydG1YRlVGQ2NyNG16OTBOMnZpMFlIcUIxeWhLZG16YndkYzV5UGsxcjRhZE1oUUpjTGdsMXhSYlNyN29qUjU1bDBML3htaUxmK05kUW5QVHFOSG5CbVlHVGg2dzZnRUw1TEFyWGcreFNuNEllMFo4N1BtVTNOTHdVeStUMTc4RmVPK0R1bksveVR4eno1dDJCRDVvVWk2OEkvazMyNHhaQnpLdVhmUjQzQ3UzVXpKWGVuYWFWM3Z5Zks3MUd6S3U1MVpsWDNyd2c3U2FMRGlsa1lWczhhYStaMXdkb2g5R0ZkUlEwMnpMY29ZdE5LWk51OHpnMDR0S0dOT3JHcHpXZ2JmeWVjM2lOeFpZL3BYZzlYSnoxM2JmSU5LS05GWDZZWTNGT0c5cHpodmVEZUZyaS9SUjdNeU1PWmViVGxiajIwTHUvSE9lRkhBaDl6OEtrSzhMa3FmS2tHb3pWZVljeWJzeG93VzVoUnh1NEh4ekl1ZVk5andrSk1xb1F3a3l1OTRDazJ2NlFwOVhYcFUrKzM4cVpWM3RXbFhkbjFadEFtazBQYjVOZ09RYXZlNTFScEplZjNYTmZ4Z3JWeXF5RmF1ODJTMmpwRktaMjd2bEs3WXJPMHJxUHozYnl6bU4yK21USjZlUE5sOS96MFhlN1ZHYnZTaC91MVlYMjY3anI3ZTdFTHFRT0lRb0ZPMkZFY29Dc2VvUzNoRTlzeUNSMzVlKzU1K1Y3UXJjQUhINExaY2E2V0M1ZG9QSGpXOVB6TjZQeHkxaUpRYWhQODkydUhrMXdISW1JOVVxWFZLMTE2L2JMa05DQlBYc01LRkRXaVJFbmp5cFExb1FMY3BEcDFMV2pVMktJbXJTMXAxOTQ2aHM0MjlPcHR5NENCdG8wWmE4ZTA2WGF0V1d2UGhvMzJ2ZW5BY2VHSTZpYXpCeVJTSCsxTVl5eU9pRHdJb0lDUm1IdVBSS2NDR1Q1NFVjRWloRGpld1c4VkRyWHJvWU05ak1tekY5K29WbGZEd2Q2bzhVejJyU0g0czRYWUxlUXJWRm85d1NlOVhSNHNGM1pic2hCVUIremNMVWpFNFUrYXlPQVI1WkRVSkI1a0ZIU00vVFFLSmsyR0N0YXBTalZWNHhxYVRoSDhkQlBoVEVsRjNiWEJHMU90cVhXYndadURpZ2RSQi8xWE1jeTQxM0RpUXJTY3NFa3V2VlNucjlQM2ZyZ3c2bW9lRGx1ZmlhNVVHWVp5RlNxclMzNDFhdFdwOXp0dU5haXZVWk5tTFhqdXVPdWUrL1dBdmc2ZEhoWmZkWUx0bjZJN0xyKy93ZE5sSmNKOVJDSW1JYU9nb3FZeFlNaXdVZU5kOS9uZURXeTFWeThiQkFCL1VNREtpOTRlM256NENSZ0hxblpjZDFnbmhBa1hJUkxWV2NsVktscEQ3MU92OFZ1YTNWdFZheXZ0NGRFN1A0ZitmSTgzZ2orSmZOTElrektxWGRSQm15bmx4U1o3Yi9vWWUwekVHdXhabi8zSXB2eHF6aldYNUFvRUFscHdWUWpJK0RIN2IrMGZhYXpRcGdWRHgxNTZnaDBXd3RCK3hnNHlkWmk1b3l3ZForMEUyMThSNm5BaENrRzBXUEdJS0tpUzBkQXhwR1BLeEhJQmU3dEVkOFUxYjhuRmNaT0F5bE5Wb0dqL3ZlQ3JFdFVsci9aTHVLU1p0RGs4UmZTS1pCT1pTcTJidGhudUJMWklLWGd6b2lBRUdkbytqL0V5dmMzRU9VUXVqRUZrSGd3N1Y3MFBnNnlEQXRiUmNKZzdlNm5qUVJ6cmhERGhJa1NpT2l1NXZwR3RXdDFZTE4wdzNLanhUTEkxbU0wbTZ4YnlGZmIzcEpVU2tYdVBXVktONVRCMWtLQnRobHZ4S3hLQVp5QTRRbHZQSGdONk0rSU9FdSs3S2tlRHJJTUNWaGhIMitzYjFlb2lua3hlR0pqWjFtNGhYMkYvRDFRYUVmbW1oMGtxcTd6QnJnNno0SHEvK3MzLzNJNnVnME5BUXZIbG44NTIwZVdJYjBITkUyakF2NE9CRnhzc2tvckVnNHlDOFl2ZDdpcVpWZWltcE1wYWRlTVBJMDRPdHR5dE9PZ3BVYVk4RmFkdWcrb2FOV25XUWtoRVRFSkdRVVZOWThDUVlhTVo3K3BKS2FtMzZhQnZ4ck12K3R5K2hqWE81c0lWaEo4SU9GRUlvc1dLUjhTVWlZV3RWbHQ0dDRpSkJFbEVSc0ZRcVVvM0pWWFdxaHQvR0hGeXNKUGJhOUNvU2JNV1FpSmlFaklLS21vYUE0WU1HODE0VjA5S1NVM1B4QnBuYytFS3drOEVuQ2dFMFdMRkkyTEt4TUpXcXkyOEd5Q2pRNUU5bmp2dXV1ZStEVnQ1MVRWcmo3eUJRRkZRSmFPaFkwaDNJZHdiZUFKMUMxZ3Q5Ylh2ODhPNzBFTUlJWVFRUWdnaGhCQytRdEFqK2pkc0dWcFloRDhkV0pSL3M1aTNCR1hLVTNIaStOb1RkSUZhcVdoTmJkUDhaanlieHY3WlRvTkRRTXBUb0lna3NsdEUwNlU0aVNTbndGVFhZZDhlRnNDVjNvY0tFWWFESnljRFBaeEFvU0xBdkFXTGxpd3pzN0p6MnJIbndCSGFlUzY3ZUpQV1dOaDl6WS8yQ0lLcFdLbHlCSkVxTmVvMGFOS2l6WGIwdDZqaU5DUTVCYWE2RHZ2UFFWK0dRUzdMKzBDRkNNUEJrNU9CSGs2Z1VCRmczb0pGUzVhWldkazU3ZGh6NEFqdFBKZGR2RWxyTE95KzVrZDdCTUZVckZRNWdraVZHblVhTkduUlpqdDZGTGNpeHpCMEI0YUNWWEY0NjVDeWNvaXdtdXJrTVRmenNoT3preVFwR1RrRlphZVUweEk5elhnMHZqSXNvRXhsVmxTbGRtenp0RnZubEZPZS9DSi9lMmhkbkxOdUhXSVBjY01uR0NKRWlSRW5RWklVYVoxVWVwcWVBek4xYitBRG14REYyTEU0TnhPUFNMeE1ZR3NTcldZemQycGkrMGxJeWNncEtHbnBZK3lBV1ZvZWRNNGJHeGNmSmtLVUdIRVNKRW1SRm9xM3Z6TStoaUg4cUgvb1pYRG8waFdKSlBFZ294Uk5TMnFuRTV3ampIdkxsSkZoREV0VlNWS1ZHdElkRWJKOXhDS2lFRzl2NzFFanNVQ0drQ3RSSHFyZWE0cDZ2OS9uQUkyRWZtZVlpSVZZazkySzFheVJkV2RUdHRyclFVQjNjMG85MkNJSlVjYjY5MkJVQjdTR08rbFU0bTUwRE9teTVJUk55eDJ1UWFNbXpWckc3ZHJqRVhmSFhmZmNyd2V5NjlEcFlmR05UMUJDOGtURUpHUVVWTlEwQmd3Wk5tcThiTnBiNGJCV0c4UnR0VmRIODVKdEQyOCsvQVRjQkJxdi90dGgzSFdOcW1aaXJXa3I3ZUVSNllzczhoNkZveVNxZDlSS241WWhjaHRQbVZsRlAxbUlrWmdxVm1Lbk9kZGNrbXR0ZDdidDdDQ25DS0pBM2VIR0lRUVozemwrVXlJSUxrUWhpQllySHJFb1JGVEphT2dZMG90SmxvbVZDNFR0ZmtuV0Zibm1MYms0YmxhZWNRV0s2bU50dDFPN0x5NVJjOW9xUEVVd0xYOXRuamFlTk9MalBPTVFZSkVRaWNnb0dHTW1Sd1lKSzVWU2xacTd1aEhDL1I2SXREZVEweWhQVlBSZWE2amZOMzFLMXJUcWxtTVVxVDhTSTA0T3R0d3FOclJFbWZKV2NYUU42Qm8xYWRaU0Q3anIwT2xoOGNrVFJDZ2k0a2dnbzZDaXBqRmd5TERSTm40MEwyNTdlUFBoSjZBSGtxdC9hVXhycFEyOFNPOG9NeXFpam1pZEtmcTA0V2JTcytoaFpJcVYyT25PLzcvbUFsZVFncE1oSU1zUEZRRW5Da0cwV1BHSW1ES3hzT3NTMXhYWHZDVVh4ODNLSXl0UWxOcWQ1clE1UEVWeXp6SkduTXd6UGdPNG4yUUJVME9HZFZnbk5VVjQzY051MjdmS0liMldxS2VEcUpkWjdKa2xvVXg1cXppNkI1cnIwT25oQmQvNkNZN21wZGtlM256NENVamdyREd0MWhZZVVWVzBhYXFtUGR1TVp6SDIyYzRRSEFLeUxtbTY0cHEzNU9LNFdYbldLMUNVWmtpYWJFTnNKQ1dKSUtOZ3FGU2wreHpmS0tXTUttdExOL0dIRVNjSE83bTlCbzJhTkdzaEpDSW1JYU9nb3FZeFlNaXcwWXgzOWFTVTFQUk1ySEUyRjY0Zy9FVEFpVUlRTFZZOElxWk1MR3kxMnNJVGh4a1BlbW5NTEE0dnhFTTVFSmZmNDA5eG9UY2dqL0lFQkJDUStGRkpBU2hwNlRRTU5pTWdyT0JJb0VCNE1RbURuQkJDaDk1QVVqaDdrYlNvZ0hLNFRqb1FFQkRRbERVY1dHTzNUd1RSSkhZYStvUlI1MjRVYTZxWTZTdEJ0TXJGZWhDREhtelgwY0VDR3h6cTVoaDcyTTBQbHMzT28rOU91dXVlKzhVUGFJS2ZnSWhPMUFaOVc0OWYyYXNob0Znc0ZvdkZFNFZqRmk4QjBXbWtmaWF3VTE4NWkrU2tnQ1lWUFJuSWxJV0Y0NGFiVllCWHFNaTc0L2VEK0JlQi9jdXpKRytiNmJVRzlIYWZoVGx5S0VzVjBOVzBtY3FhRHVRem5wMEYrblBHZ0JMOXgvYUFJbDBncHc0U3FEczhZRUFrNUk4czE2SHNRNVZrTkhRTTZkOGozcm5Rc1h0ZXdGQWdSYWtsM09taGpLOUpJTnRYaXh0Z0dnd2N0RlZQQTRkWmhsakpTdmJWSUdGRDE1dUJFekQzKzRHc2xleXdOSFo0N2duR2hKWTlMRmlJL1hxYlk4aTlxVmJBbjNnKy9nUFA4enpQOHp6L2FnK21EQUZoZWNuV3ppVmNubEg2N2h2T3Vpa0k5OEtDaFN6NzFWTll3cTNST2xQSjJPeVBIdWx3SVFTUThoUW9JaUhiVTJuNU5zKzRBL0Q4dVVnbjRDV2NGRlNrMHh5VGluUGJESW9zRHBZakpPSTcybTNHbENuMm56TE1HcU9YWURwWjJzWGlXSVBkaXRYdXNNMDYyY1JXZXowSTRISDdEdWRjYjRrb1NyU3BCKzRGK3hKWHp2QWE0NXlJdCtiSm5JckV6eEpDbkRySldMSkNKd3lreXdyckxYdi9vc1JMMk10SzM5bHVPYll0dG1PSmxDbHZGUThVYXR2dStQalVDWWl0c2dKSFd6c2F4SGt5S0Znd2NSMUlLVmErNFZLdG5nN2g3dEk2ZHdFek1lbVpJcnVqZ0tyM2N1dXJEQ25hZmxhd1RMbFAyOWxNZXBiWk9RdDBnMlJHem5vV3U1ZlY1WDdLNWNhUWU5L3VQRzVuYm5jendhbThnTEFIY3ZIK2tpN0hhbFo1VlBrcGtFSkYvVDBuZmZEMnNkTGNKb0wwVjBSejc1RWsyVVFhVGZZTmhCVHBLeGxCNENhaTdSbkx0OWZieG1Ia0RxY1J4WWt1UGU3elZielJLYTdQV0N6Z3JSekY4YmtUeE5FZ3pxK0RnaTJCWDY2SmlJdUtObE13TnZzUUhBSlNuZ0pGOVo2dmlTSmhsbkVyMFVWUzRKV2M1Q0c0WjJuUTNobFRwaGcvWlpsVm9jL1MvSTBPUjNvcnhlWjNyeEZIaVhkZ2ZKZUEyRWtxeVJuV0xUc1h0LzB5NHp2elBzZlJWU2tIY2FwQkF5eVlucjM0Um5XdjRWZEhGN0FUdjVZZUpsdzFtNFFodGx4V0dYR3Z5UzN1N3J2WnZHVFAyRnZWTFdYNUN2dDdWQi9jU2t0RXhjeDF6bTUyNldDQ09JRjA1QlJLUnRSdUFDYnE2UkJyeHg0N0lJSzQ1UVhOWHJzczBqWkk5YW5YdVhDUC9UOTYyd3ZPZlJnaWhsWVFHcEt3eE1GTDlpMG51TTdwVENHS0ZDdnJSSENFZVZXbjYrV3d5MmxQcndIaFVJMTRISjFKSFYxY25FQ2hvaElIVjBKS1JrNUJXVURjdkFXTGxpeVBLVGh0Y1BXTU1kK3h3czVweDU0RFIyam43ZkpvRE1peCtCUWZoaVYrNmlCNGs4NVVaTGFzVVdVem8rMHNzUlBIRjZmeDNQbFUrVXAraEYvbytUeVA5Z2hHQ09ZNXNUMFlZMC9oQ2g4bVFwUVljUklrU1pGV3hhSlM1UWdpVldyVWFkQ2taV2tMRXdBc3BNQzl0emhGcDRKdHY2UFBLWENpdWY4R2hkSWVaQXZWZjFkY1RVaS84cnl4ckgxdy85YkxUazQ2R1BTQTQ4a3VlY0Y5VFhqWjNEczhkbVY2eUZDMDBaMmp6REhnR2t0OGltOE9NMFYxeWRoSlp4TWJ4K3ZNMXB5U1QvYXIvWDNBeHRsWGEvNEpMZExzcWVmOWxSVUl0dE8zbDNMcmRkUXdZV3EwTm9TbWlIV1hBME40WnR0bDRWWWh0dkhxWFJSSFRwRzduL3c1RitvUjV1UGlMN3p0aFVWNGZaQm1hb2dxN2ZwNGlDaFAzRUtjckxpWE1vbTVDOE0yazQ1M3V2SXpQU0hLVE4rTWRqSjhZcEdRa3BGVFVJNHA3YlRoMHpmajk2UFNCQ3hnTXBWWlU1VTZ0TTJ1aVpyMjV1QjBHay8zS2Ivd056VDc1K0Z1ZWFGOG8vSlA2RGFJRnl4aXorR0NEeE1oU293NENaS2tTRnZJclRUaCtTWFZubmh2eVhZaTFJdU5zN2x2SlpPc29uTU1CaWxlWmw2VzNuUlN0am5lNlR6YzN0Nm1jck5WOHdLT2lIRFNuQjcxSWVhbzlrbjNVV3dNV01lQ1QvZzlHTXVVUDJWOFV0Zm9jN3ppWkRrOTJKVjNLOHRYeng4YUVrODlyMWRxWUxiNUc2Q1RLZnIwbEZIQ25yYWM2US9EMjdtazFxSlhhcDdnaUFnbnpVdlA5TTNPNWZvQjZpbjV2S2lla3A2blkrOXJONjlvTnUyU1NEWXdKTVR6ak1Ic2hyOTAxSDBZWXgwTFB1SDNZSmlpc2huSDVIVDVsVE1wcFNHM0F5VWtNbzBqVmM3MUxJVFlNWEVXMHl4MUZ0YllaY1ZxSEhQV1pkUFcvSnBWUVBEWTduQUcwUm9QcUo5QWhndmV5WnhTRW01MERPbXlaRGZPZXUyd1dlRm9hOE80WkJTOUY2MFBRMll0Tk1lYU83WGQ2ZHJKMThkdUU3Uy9mcHZBVWdsai9DUzRvMWc2Q1I3bmh5aVlNTVlZNC9mSEdHT01NY1o0bjltSk9YZ09oZzNHLzVtSVoweVUxRGhEcVBiaDcrVmRDL2l3Ri9NaTJiOTA2NkhwZTJUM3pqMlgrT1lQWmZneUxVKzZ6a0tUNTlVWWJoZVVZK2ZhWmZ1Y1haVUhZdnJzM3NrbUppN0ZTMEIwR2trS21sUjBHVEpsWWVHNDRlWkZzSVA2SldQdFlnVmpoMlNDTUthUFpQODY1aS8xUWk1U1grdlhwNnRSakdEQ0JObSttMXoxS2kwREZXdGFhUnNqNXZJRURIQk1SSkFBaWNnOUtUQVV6c1hHSHpLQTN3SGdYVkNBd2d2ZHV3QjlVc3llWS9PR05hQmJ6TzV4V1VKc0FzclhSUCs3b3dNSjQ4UkYwYnd4Qnp1WDNuVWxvSEp6YStyRmdWV1N5cFNyK0s5eVFMMGFYUTFxMWFuM08yNDFnR3ZVcEZuTER5bytIdm1oL0xYUFA2RTdRb2lJSTRHTWdvcWF4b0FodzBhTmYwL0o4VC9HRllGM2ljbGRnaWE5eWFQazBoZTlOd0FEVHl4ektYZ2VuQkY0R3JJeExWdXBrQU9BQUQ5UHVLTXJLQUJ2Q2hSa1gwTFRBWWNjY1F4MkNVc1VBQUFBQUg0VktGd0FlQmY4TExpbXBUcGhnQUMvR2ZCTmV4RE13Yk1GelJGdDQwdTZBRUF5Rlh3bE1hK1RLQ2tLUjgrK0ZYUW8xSWNicUpFQ2tTaGtGQXlWcW5SVFV2MXI1dkRaUXVZd1pTMFFHNzdyOXNBVDVQSFA0MGtkYjJLY2t6aFhrcWswT2RqSkpaeTczVHJjaHRVYVU1Tm1MWVJFeENSa0ZGVFVOQVlNR1RiYXhnZXZKNldrcG1kaWJjNGh1SEFGNlNqZjgwTUVuS2dRRUMxV1BDS21UQ3pzZlBoRnJiYkdlMlRhbnFZSWRXM21QaHJkcHRXZFMrT0dKa0xyajdQZmZQTDNtTGZ2dG0wZmlOQ0hSRzloSjU1UkFNekJZaVhLbExlS1lkTm0yck4vQTl0eCtPZ081NkZvWitKZEZlV3hsNUJYZURrdTNvTXh4aGhqakQvRGhIVG1KMG41MDNUWFNQZUF6SUJDMWtIeHk0N24ydDNCWGZmY3QyR3J2VHFhaC9QQnR0a0JDRnpOcnEyZGZOYjBRNkExS0Npb2t0SFFNYVM3Z0Z0M1ErKytqcnMrOG9EZFo1aDFGRHVtY1lKMzViVDE0YUEzTVBiZ3ZMUXpIdlorL3h6dmkrcGZzZzJHcDJadlZ2azJlZUEzbUJ3MWdvNlYwYUoxNjlZdFc3ZHMzYjVseTNSMGROWS9zd3dwNmZGU3poWGlmdVZmKzJjQnF2Y09GcFMzNHJFalJuYkgyU1pzMlpBR2U1cVkwZU8xNDdrdUM3cnA5Rmd5SHA5WEZuM2Q2UHhHbHpjNDFzZzRMWHV5T2pIT3lhMjNqSXcvM3VuL0ZqZTA4S2gxNE5idDQzUGJQU3Z4ZWUyNWJYZnRHdk5uczJPc2dVMVljMXZYTTJSNnhNSzg1aFkxdDd6MWNTWldWTCtxMmFueEV2QzNjVzR2Z2ZBVDFkYnRZUFUxU2JYMGpyOTZ6dXJZemY4blJmMlRiVTJWTmsyL0cwSjk5bDZFei85R252UEtiMmJCcnFqeFVnMGpEYUkxNHZiRTFyUUtzTDFsREtkMWJWdjMvdWpadUhHcFZrTDdudEFtc3UzOXRXdTNyN1B3WjF5aWN4aGpNVGRoY1RWbDhXNmR3cUNDSVlJakZPYkZsZCtuUmFrdWp5UFd3M0hiM3hQcWl0dWRSSHFLRDZ0aVN3MDl6YzNwaGtrNDBBSk9kU1RyOVRnK0tCditNK2F0RFVieFMxWEVVemMvYVlMUmhLR3EwYWZPeHRkMlZDdHFuQmIzeHJSNnFVMFh4dnFmNmFMV2JVb1B4WjdoNFA2cE42UitWRGRoT2pWN2E5ZDdzNUxzcUxFTTBtK1RSVGxhdU50ek1sL0htRi9xY2pTVzV6RlcrNXpwUFRtWXlIbXl2YjFLYlpxSWZkRnNhQlh6Y2JLektXdC8wT0g4azNTbFdOLzQyNE9RanJManZZMTlzV0I5SmVqdmJPemJzLy84NW9EMnVTMUxmSEZMSFJ3N3JQaU9PazJObGlpK0RlT2dYcloxQTAzN2RkcnlCaDR2VGRJMVJaZE91eGJvOTlhZzlVYlpsM01GSzJzRFhRNnhlQzlCYnhOY3p0THlsZ2NoVXRIaVpNSHJ1YUZSVVdyWVdiVEZaYmhVRFk3UlBkVkdaOXovTldIdmloWmZlRVl1Q1F2U1VYRnJTMFpVdkt3Sk50WjJ2OHEwamRVTUYrdTFLR1JGT3VKZDExSldWMUkvdkQwVVZMWVczT2JEclVLZksrTWx1ZkhpQTIrQ0h6d3Y1ZEo0SnFtc3MxSlc0aFR5d0gzRTlnWC8rR2ZSbjRFd2YvMXVlUFY0d2I2bkY1TW1qWi9QK1dlbDdyWEdYZ2FNT0JabE56bW5xY1JoRTllTEN4MW5adkl2V1ZaajZNeVhUSXk5aHRVMlp2azJxOUtoYW52b0RNWUZCOFZOVFRVSHZQZzFBYlV2aXB1eUhRQ2I5UUd3eDhQMStZaVRmYk1nNFA3Uml2UDAzR01lR2MwMUwzRmZSRWc4SnpHZlRxYXpZUHhzb0dzMDh6eStBV0F4SXM1czFSS3JsT3hrWkZWaVpUWGN6YjZuNVQ0cm5YNU53RXFWdDNyZDBWTklRWTZKTnRwRzFROU8yUk5PdDlZdGtzWFUrMklKeW5YdWZlcjJ2dEM4bXJVY0FyMHF2empWTFF5eUM1Ti82OXJDRXBTdU12Wm9UcnN1dDdGZzdKdzA1MDl3eFZqbFQrQ0owSmo0dFZFK0pRYUx1cGpMZzc3WkZ0TVozb2JXUWhOcDFHTVpOd1dzcU1VbW11N2pOVlpkWjZhNGVNbVVYMnN2c3VEMGFiT0lGOWlwUTRxN2pFL1VSeXZuS3V2MDBzMWFnakxURGx2WFVyK001NVpjYWRGQjFRRDZrS3E0aU9pdFl2MFFkejFlZHVvc09PKzI4VlNYQ01ESEFORDJLMDNrSmxSUWhTclVhZ0tBcTdVanQ5SW02VmRyTTg3Y1JOZnEybThEMEFzc0lpTUtNeXUvWDFJM1FLdjZFSFBYbnl0TWFGcGRXeU8zWmk0d1VmaUQrZlMya3VhRjNzUzczU1RpRTBFT05ldWVIaE5UWFYzajZWMDlzbU01UGNKQVZOMElmbE8ybFVlTTIyNVhZQVJrS3NxY2k3d2VkcjlrTlBBVExUTVFJaGxSZVQwN0NnLzYwZmV3YnFVM0labzlWTE0zTjlxekZwQzdSMm9VdGo0anpUZGt1bFQ3aWk4ckQyZDZaR2ExelNjWVZTY3IxSHY0NlpFRFZKNXU1Vzd2VHB3VDVNd3FmV0FtcmtGbHV4VDdLeVI2VjlYSHFoR0ZHeWo1UGNUbFJIWnAyajZiVUgyeTQ3bDUyWU91QXVRRHVtUmdYOEdkSjYyM29XWGw1M3VMRzdtaTdKWkRJQmZ1b2IxditUQ29FbjYxWUZRcWJMMXE1eWxoUzdIME9SS1ZhK1B0ZSs4elYvY3F6cCtzdGhwcmNFRGU1OW9CU29Qb2hDRDluY0dLSFlvakR3SzhCVDQvalJERlVBeWlGTitOUlFRbVorYW1vTFV3elF5V2ltSmpSV3VyMFg1MmpzVkpTNXgxZFJjWnA5UzV6bTNtQm5lM3l1UHFIaThqU0NCVC9wekcrajFOOWMvN3pmVWY4RC9RMG9MSVFwdUNvRU5uNy9JUDlCb2dKaUVsbzZDa0t2WHNJdHB1ZUpYVGQ0Tjh3TWpFWXR5RWFUTm16VmtvMnpqS3JoM1UweEhrbTdhckJnNDZxVTI3anBlZDAwMm55elp3eW1sbm5IWE9TeWJjZE10dGQwN3ZCdThEZlNFRytrTU9ESVFhR014M1lDai9BNGI5ZzdwM2JzOTk4MkNLNTFOOG5HYU1BTEI4eW9LZE9CbmFkT2pTSy8yUkJ6TFFEbGpWcmJFTHZPOGNVS0xpaWFkZVVDK044UmVvSlJ6NHdJaVpCSWxzNFJGT3N3VUpmUURsQ0pJT1FMa3BUNGxTNVJZc09XN1pxcFBXYmRoMHhsbm43TGljS3loYURjNjVjZE5tekpvemI4SGl6UkxDaGVpbjIyVElrRm1aelhrSTFsR3lpUjdiSUhaaGNZNFFsNGhRUjg0OWlFZjBlVWVDVDRUNHhwaGZqUGhIS2lCaUFxTXJJaHlSNFJFVkF6SGhFOTlTVXFTaXBJVWhQVHdtWkp3cEVUQXRNdE1qWUVaMEZJWEhpaUNOTWJjM2hIMUI5b2R3TEFKYVF1bnFQQ1M2aW9kSTNUbXpNdVNpY3ErckdnV1pURFhNa1Faam5aa0twa3duWklBRWpBeGhmQW9JNUF5ZVhHQithaWpPSGRMemdPdzg4UjRnNG9Tb0ZTbHNIa2d2dk1zSUtWekhKV1Q2b3RkbnVKSzlybVI0ZVZVeGsxWG10eFJWdXdBTU14WVRyYm5jWlpuemM1bGNHbWxycEErMDlPU0FOamtrbU5DaVRRL0NrbHhXSXBiSC9FNmJ2MXFzVll6OWVQazZDRzAxL3lDMk5SdkEyZVlOTWxCWml2L3pGR28xbThIWS9pMFMyRUV3UWV3UW5CMkcyQkU0YTRKWU01d2RSVy9ITU5qeHRzV0pyY1hKUFk2V2lhTjFQZEUyeVU1MzJXQUsxcnJnMnlsWU93M2Z6c0RhV2ZoMkR0Yk93N2NMc0hZUnZ2WGVkeFVGa3BDSW5Kd2NtTjVmaW1DdjJ4cHY5MDkvRDdJUHVIMUU5Z20zejhpK3pOYUJPUUtxbGxMSkNRRUF3R1JDemdSOFFld1dFTGdseEc0RjNheWhrMDNid2piYnNNc3U3TE0vZEVtTmxydnlCWXZjOGtZYjQwZXRCKzEzdEM3Sm1MU2dKQ3hKTG1pOVlaR0NlRDZzRjRGZWpOakxJRjZPc2dwWXIwUzNaWWg4SmVpcjBHODFFbCtEMk5jaWJmMGc3dkIxQUMyWVF2Q0dTV0M5SHZQMjdnbmR0b1VvVTFoMUVPS0hVSFlZODQ3QStqSFFUNkRmU2ZScVFlS3RTR3VEODNiNDNnbmpYZkQ4RkFhZFJ1Qm5rSFVXdnA5RDBSVUUzajBZSFNsMWxORWJvd1N4MzJnN2h6ZHZobUYzd2JCK3FBOUFmQkRPaDJEOUhueC9oSEdQRWZoemFudkJlcjJrekY5UjdHK282UzExdmNmOEE2bC94UHdUcVkrUytOZ1JGZ2VPSWlWclp3RGh1SU5JZ0FDaFlzQ2pPdkNvRkQrcVJ4WndjRHF1YllFWVJCak1ua0FPc3BzQVNrM0JxQXFVbW9GUmMxQnFBVVl0UWFrVkdMVUdwVFpnMUJhVTJvRlJlMURxQUVZZFFha1RHSFVHcFM1Z1ZBMUtYY0dvR3loMUI2TWVvTlFUakdwNFFMMTRTTDBibm9iUDRId0g3emRSL25NeVlBaUJjeXBvb29NSEZqTHcwSEVQRzQvdzhZd1lMeUo3TENBMERoNk5CNkVKOEdnaUNFMkNSNU5CYUFvOG1ncEMwK0RSZEJBNkhoNmRBRUlud3FNekI5NEpvUkw0di9GUENLVGZnOU1mQ0tRL2d0T2ZDS1EvZzlOZkNhWi9rczdIeFBNWmZKcEpLbDhPNldlSm1pTmdDcVNyZ0U5WGc5STFZSFF0RCtoR0VMb0pIdDFDRkswazhnZCtkQmNJclFhaGRmQnBQUUcwZ1FDNmwxZ0U4T2toK1BRd0NEMUNORjJEM3pta0hoWDFKampCbjdhU2hBU2N0cE9FREp4MmtvQ1NNRlNFMGd0Q1Q0Zk9ELzdjVWhlMjhNV3FXSXBWNFF0N1pJSHdSODhtUHJxZFQ2dk85T0hzRVlXTGloSExmQkVpbkk4ck1MUlJKY29rRVVXZ1VhZWhSWVMwQkVIaER0eHZDa1lCS0NsZWRoaytLU0xOK1FtWUM3a0pPWXc3Z0NJcWR3Z3BqenV0Z2JVUkRScmp0elk5Vy9NRW82aFVEdlEwZVVxTEVMTXgyUWNrSGdDU3BVTGhlSUVZTlZJdzhaQ0pRaEdIcUNUY00zbHRNTFJIbXpJS05kdTEraGtsQkxzUlgzOElpdVBVaDBoMEZxaXB4d1VvNG5VS3d1cFV4L2Y4aDdKME5OY0dXd0M1eGtwQUZrcGlKV1VYUlF1N2hueWdvUG9BWWhlbXdNd0VBQlM1VkFhU3V0eTJud2l2MytON0NSTkYvcU5TTEloQVJGMXhSa1JHRVNFeFFTTXlvQnc0TVZlTW9TS0JRbUVuL2xUNkJiZHhHaEVZZFRKRzQrNDdKRGFnOGhyTHVnS1FVWWtUN3dpaGkxVHRyVmJhZzlISWgzVmtDaWVLLzJMdjV5dWZXdjlnam1pckZycmRKMkpaNkU5SHhDd1RWMFFEMHFtUmhzcXdpc3RWdVNIa0lzOVh4SXhJYkJ4d002VU10bHpsSXFWS1BoS2xxVU1oWUdHSWxRZ0tJYjN1dklXNERZcE8reTliYndCdUJ3RDFYcllKRytRWjlQS0cra2o2ODVSQUhQdm52c01BeURwZ2lrSkRTY2cyckFQM2xvdzZDTWVMUmhqZXJFTzRjSkFVY1JBYUtHUVZXTndOeUEzQnpXVjByZkt4d21uamJGbjdtbm9wZGlEUVdtYW9IZWhMckRRR1BvVnl2bXNSenY0YTl5dFpNN1ZtVzhxK1B2WGx2U0RLcGIray9keGJJb3p3U0M5TllFbFpNM2hNUGRXRWoydnZYbVA4VktIaG9VSURNZjZxZ2dOOW02U1hPTEZKVmVZWnhtRUx3TlQxV09kaXgxN2tiTmdFMEU3Q3Nvb1FyVEtKUUJ5Um1Fb0Y4S1NVcEFRZ2paU1duZ3BreFdmZ2lVREJIeHM4VUxXaWRSNjNXOXRrcHdKOTFyYkVGR0RrRFoyaUZ2NnJuZ0dzMmU1SWR1eWM1cVBNejBRcThEUFQwY0pTZmdwczJtTWxMdFlTeDBiUzJFb2VPNWxjMk12eS8rQU5ZMlRYNVhrVVFsL3k3bks3WVZpQ0h2VHQvSTB0a0RWdVM4YnZyTU14SktVSGlZaHBrZENtUXpjK09HLzljMmllK3VQcEQvZG41M1BqcytKejdIUHFvLzlWZGN4aTNHTFdJbE9YQlY5cnRlcU9wZW1TMHQvbDB0eFgvdkdBLzcrZEpmcm8vL3RtZWJ2Y1lBUDFwNmt2ZGIycFVnNnJtNjZxdGQyOWRNMDMxNHRtZTk2em52YWttYWFiYXJLSnhodHJ0SkdHMC9heXhSV1liWlk1WnBocjRGNWx6SlM1cFphejlGdS85MGQvOWxkLzkwLy85bC8vMTExUCtRcURpSTdPQ0VNb1lRbEhlSVJQQkVSSVJNUlBMU0loMmtUbnZWKzFlc29jcDc0R3lqWFVTS1VtR3VlU090ZmNjczhqenpSNTVaMVB2dm5sWDBDQkJSVWNQUGM4TG1SdDJuWG8xS1ZiajE1OStnMFlKQ0ltSVNVanA2Q2tvcVpCME5JWlFxSU1HNkhQLzJRR1JpWm1GcVBHakpzd2FjcTBHYlBtekZzb2xOcllMTEpic216RnFqWHJOZ0JBRUJoU0N3S1l2L2JzTzNEb3lMRVRweElwb2FkdllPaU1sTW1ORk1ZbXBtYm1sTEwvd29KV1E0YmxFQ1VWTlEwdFhlQ1FaUGpIeU1RaXdrcUJibDJRSyt3RDZBSDZ4eUpFMC84WjEwekdtOWZlMytGZXZwblBZdjJabjdrWlRBdE56b3hiUDZaa3pVNWtOMlV4TDI5NnRXbFZwOWw3eDNtT1pkOEUyMVo5b2t1TTdnQWszanJlOTkyV2Y0VXg1dDlUakpyaWlVMDNPR3RzM3Y3YTBNaksyc0xXZFVtME8wd3BMZDF1aTR1YzNTSm15Z2o4Qy81dFNDWE9nQktYMmxrNjVWVVdSVytBUWFXTFlvWlZabG5LTzd1U1NpdXJ3dU52K3E0Zis3bkt1dnYzci9SSFJhQ0hraWFRYTFLbXFqZDFmV2s4cklhTW1USzMxSEtXck5teXQ5SnFVR3ZZYkxRNUk2LytFNW16cjVQSkZaUW9WVVk3bXZQMitIbDZvL3dqQ2JuZW1wYnR1SjRmaEZHY3BGbGVsRlhkdEYwL2pOTjhPRjF1ajllSFpubFJWblhUZHYwd1Bwd3V0OGZyODh1S3F1bkdlU1hRRHFXYlRzdjJpaVdsWmVVVmxiaXltb2FXanA0L2p5OFFpU1ZTbVZ5aFZLbDlNVmdjbmtBa2tTbFVHcDNCWkhGNEFwRmNxWmFZUjVSUEpWVDIvbmtsci95cGZrVlpJWEFBS1ZMMlFrM3hneUlNZ0pCQ0tpQ0FneUFKRlBZM2JDSm1Wb25XajRrdTBTOWcxZGhMR0xsSmlEa2gzWmRkYW9FMm5RMXNyd2tYVXB6Tk5sYUNST05PQWhET2psN3M4ZlhmNEVPR1J2MXhDRk0zTkg2d1RiM0R6dmg4RlNoZjdFZ3JYbFA4dm80eFZHMGZhUi8vZnZIeU9mc2NmaUtmcEtmd3FYb3FualhQL3VmQzB6ZEM2aituSjNFWXMydzZwMmRlNnRCMzQzTSs3d3M5dnd1OTBuZnF2ZmErL3RvU0Rna3lDaXJXSFBjZnd1Nm5EcUZ1SlJCMlBVMElOV01nVkw5T2hGb0lEVHNRNmlEVWppTHNSdUFRaDJwRVRjOEVRaDNudlpZQ2RxckRvVHlvN24zNjQzTDNzUnNzdXl5M2FwbVU4RkVYM21WMzlINHk4T1BycTEveWhTamNBMW4yMEd0enUrelYrNWhqWVhzTlBJek9Sc3U5aVBVNWxqNWVlOTcxR3IrcjhkQ0orWlU5TmMwN2pLRmEyY3lVS0ptYStHbDk3VmV6T2ZMM2JoUWhPdlFwTnhyV0FNVEtqemRZMGlaYU9uQmVtRUxoQ1hraU9pbG5MdmFiaTM2TnkrWEJ6NXNxa2RLc1RjK3lQVWNUUTc1NXcxT0ZzbXJIclp6a2pmek5DZy95TW1qL2xyS3FhZ1NvOXFhNjEycWxYdit3WGx1SU45U21TWVJHT0ZHdnRadzdWWGFmelYxM2czeG5KZmU5N0hZd01MVWZtdTBYc0ZueGw5dmFUMGgzQndVdnFPWGVXM0t2ZFJtSWs0dC91NDA4QU51UHZISHJzWW82WFBJZ3JwVG5kZDVzRzdLdXhCaEYvd2krUEZNSzJrV0NxYjVjY1BjRDRlNXplV2g1ME9FSmYveFJieXR6a3ZRekhmV1RxTHJ6V1NLbkxpTTJzamJMbmpwTWJKbFkvUmRjZGNOMWIvZS80NXFiM3BLTHM2MnpsaEVaUnREOUtyNy9BcmJoaE1XRkJ6NGFmaVFFQ0NRVElZYStPQW1NSkgwdDN6aVY1WGtuN2Y5cFI0NmNPRE01YXhlbFNxblp0VnhkNm00OS85RTlJVGRFRzRuekdjSHgxa0hDWS9tc2dCV2V3dURYa0N4NFpSZW11ZVRDVXdFMlF2MEpmUllGTXp4MkRvbU9ZNGlWMEFtRWhIMnNFajBSTjdsVlFUSlRpY1MyYlk5QmpENlZTbEhWVE1kK2doWjBVc1NUa0dHQWlaWUxpNlk3UFJMM2pINWJjRFA2SnJKbS9nUWxZbzQ2VFVBWTExbVg4UWt1a3NoTlowSnNFU0wwMWtla0NTYWFKTVZrVTB3RkVXUERsZ04zbnVkWVlkeXB0ZlBrZHNVdzlvM3BwcGVRT1ViY0tGOGVDTTVrbTJLTTRZWVlacWhSUmhndFRvd29mZlhUWHpRS3lxVkpoa0NSTVFiV1lUeEMrMDRxb2xENnNJblpsdUV0Ry9XeG5vYW44V2w2bWhmL1dwN1crWW5XUDdQR1NFYXhOQ3FXaUNUT3FjYklrdFQvVktObkt1SXpZQ1JHLzNRam5FU3lBWThicFZpSm1La0g0d1hBcVNjUG14MFNuZTB6aXcvRE1WVTlPWDFHZkt3eHBYRUhkZ1R1ZFIyMWNjOFRMVllNeE5KTTRJdTJGTmg4ZWtTdjVtaG1RajJjaURrSjJud0ZabXA5UFplTWxzVUdlaW9GTkZPdG9HalRuMUJkeVpPVmJhbzAwMXdMTGQ4N214REZRbHNnZi9qUlQzTXpXTGp1ZXVnSkFUVmRDRHprMVlRRmt1bXZOYUNHeDRUK21nWDdZNVNPUGtYaVA2clBLOS8zNWVGL2x4a1FER0kraktManUydUFDczRCRVBhK0JpcXFGNmYweHNYeEg0Z3d3RFNMcHQ4QS9La0x4MDl1eDJyeGowMXExVG1oMDBYM1BETjZsYWc3cTlsTXZiVEZMbUhGSzFsakxRM0c3VU54RytubFpFOWNUV3llekg3Vk9GNXU4OVAyKzZHSkFyMkxINDJsckJ0YjBJNk1PTXdJU3g5OVZmdDliZXRZMS9vM3Z0bXRmcmg0UUQ5Mi93bjkvOW5UOXRrdCt5Zm5Famo2Ry9vblNReFJaOENZS1hNV3pMUE9LL0lvb0JTWWVrZS8rZHRUTHE5NXp3OUNNVjh3M3pHL2xKT3ByWTBvR2FvL1dzZi9tYjcyUC8vL1VUQkFnNFpWdTlmakZBMjJrQ1huNzRHZDRCTnlqcDF6Sis0a3ZzWGxudnNKTnk4U3lNRkVaQUFvMXZ6OSsrVTF2WTdYOVhyZmtLMTdnUHZtTzdyVHc0NDQ2dkxISEhmdDYxejNCamF4RjNOOHVIcnMraFA0LzdXTHBka0JPNWdhUUg5Ri95QW16UzlWSmZHSVNkcVhaSkZmTVVSZHhDMzI1K2FZUndiME9jZy80OWUzMUQxdDZuT2xGZWpFanlZSDdiZFg5Zit2YmVjeHg2VHdwL0JEUHdWUU1OdUUxdmsvZGtkdng2MjRPVGY3cGwvaURTK0lmOStmQXNpekFSQm4vdi90NlFaNllGTW1HeGtoc1kwWDU3bHZEQVJmaWU3ZDdsbE85eUQzdHRWbFQvY1NCM0VVMnc4WkVpdXhGS09hS3hHVkxGaVI2cjhCL29KZjUxYm1sdWRJYkdZaks4QW1uYStSZDA2akQ3M2dvQlhWU0lZMk5IN2IvSWZvcGVqcmdaMU84VUtHL1JMd3M0UDEzZTdzRlM3K0hUQ012bUo1emt4bjd3TFQ5RXhMaHg1ZFZvUWRuV1NRMGFaNzJNdnFsSDdPMUd0N25SQSszdlZ6OGNmcFowbFRvYUNiSFU2VzdISjJCRGx5UVFGOXdvSEVjQW9VVWlJOGlwWlBzWklWVXJxOXpVKzM0aS91UzJXVUlTaFRVRXZCV294UlFiTy83NC85dWIvK091T01VOFdMZGZuL3V0ZXp2QW1XSmM1b01UcnBKazNQdnkyMmNnTm5uR05PT1Nka1JORytOdFRiVTVXR29MYW1SbnRyV29sOWs5Zy94Z0ZuSEV5SlEyTWN6dXFPYUtwcUNXZVFReGxOKzBoMDFNd2ZTWC9NbStidnJpdmQwMTNiOG10Z3JmSHYyUWxjNzA4OXNtVDBKajhLbm9tNmJ0NXRYOEk2dUhZOUoyR1NhZEtaOTlTcTk3UTNRR0c4VGJGM1NUNm5yeVFEa2VhUTQxUHBEMHorV3FzTllGYVJpc1B3L20rZE1FVktsSHZWWnR0dHVjaVFFZU5MbVRCbHhwekZqTXRac21MTnBuZnR1c1dPUFljcnJ1eERIODg5cjA5OXZ1cnFTL2p4ditqaTl2dlNWMmdZV0FFQ0JRa1dNdjE4b2NLRUR3b0lIa0pJUXFwMmtSZGN1TXFxb3VCRWk1bDVqZGpWcnBXT3FnemordXUwbndOVzlCSURVUG9nQU9DL3V0MkhjbXRueEhJeWNvMnVGUjdNSFhaNW1XZWx3ZmRYdlo1Y1liVkhuT2RSVDdudWVCcUdlMmErZ3B1OU9sOHRWM25OMjhaNEorK1c2NzAzUDhJa0gvdkVqVDcxbGVuSDE0ZWJmVE4vd2J6alY3akZiL052TFBlUGY5M3FQM201b3dEWnhLSEtDM1lYVU5Xd0s1K3BlakVDTlRienRNMXRicVF0Yk9GcVcyYkgydnY3VHZqQktOYk5QZVFMZTlyVGFIdHA5WjBESFdTTWd4M3BOMGM1MmpqSE9ORy9Ubkt5Q1U3Ulg4R0FES3lYR1pTaDlTb2RHVmE3UnFkcjFlM1hqY0drWnhxem1Jenh4cHRpcm5tbVdpTm4rbS9jK2hYNngwUC9hemNOZFd0em81NksramF4OWQ4TmloSTJaQ01xMWg3WXpJUjIycG0xSHNUMlQrRHBLMHJNL2p3M25uald1N0dQYXQ3UC9vQXNpVk9TcGNOZGxnOHZsaFduVno3Ui9ub0xibXkva1hWVHZQLzladlF0a292ZlNwWmJqcEZrR2MxNFJqQ2hDbTJpckkxUFlncGplNnJjRVovR2RDYjBETGt6UHBOWlRPclpjdGYwT1V6cHVYTDM5SGxNN1FWeVQzd2hpNWpXaStYZTZVdllTVE1zbmNzbTkxa3VaNmExN3ZQQWNUOHN1UC9BYXp6cFFROVo1R0VQZStwNEJCWjZORS9qdVQ5amlXZnozT0lsUE85bFM3M21kYS9zYitNQ3J3VUlEUC95V2REd1ZjK0NMVjZIYzZzRndSc1NSZFlvVnVwTlpjcmNxWHlXbDY5VXFIQ1h5cTBTQUNBbXZFTnFTbUdKTkdudmtnRnhuQ3haNzVFamgwZWVvdmNwVWNLblBKVXhUMlZUQVFBK29qcTFzVUtIcm8vcDBYT0tQbk9mc21EaE5FczJ2bWZMMWlZN0RuN215TkVaVUM1KzQ4clZGamR1L2dJRHQ4MmR1Nzk1OEhDT0owLy84T0psaHplTWYyRmhQUmN3QTNCK0R6eUhCSjZHb05keVFiQmdZQ0hDL1NkQ0ZFRTRPSmRGejJoNUlVYU1LMktEcjBRT3dsQ0dPTlBsQUdwbzlmOWx5S1lnUjY1WDhtYWV2RVZIOTBaK3Fpb1ZUSFVNanZxaEZDdk5TeVpvbWExZ1lPL3QrMktGRHRKNTUrdlJsZDdLVnQvc1I0V0JUSjZTSXdDRXFSdzU1UjhBSUV3N0t0ZXhPVFA1aEd0V2xibndLNDlqQlVxY21LdndjOUthSXVzNVZkOTNPanNWMnZuand2Ky9YY1c4S0tFdTVXYjltMXR1Q1Q5dW4wQVA3d0RjOVpDQVIvUHhWb1FudmhEeDFUY0Z2dnRCeFU4ckVmTjZLNGk1OVhzQ0xxZy9rR2lGVFlLcE1rQzFhbGsxYW5QZXFvZG8rT2V0MzM4ZVVEN1Y1U1p2bUp2Zkd1cjlQditROS96cHY1ei92ZUhZY1NvOEQ0MmtlT2xDS1ZIcUdsV3FYYWRXbmVIN09saGhKTlpMZlhXRFJzMUcyTXdXUnR2UmpzYlpPYnZVUDdCWDlxN0c3L3RpK0VmUEdnOVptb2lMWFd5UzYxeG44cjRBZCtFWkN5MDB4V0xMVGQxWFlJVkxzZEpLcy9hMVdKcU4rOXh2amdjOWxIbmZteElNTFhqYVZQdTZMTFN1ZFMzU3JObmlmWE1zN21mZkhrdEwwRnUvTFAzV2JIaU5sZEl0QmNUdEtyZEtRRnFsV28zVk5yU2huSHIxMXRyR05tNTNoQ1BjWVlBQjdqVEUwTnoxZmJQbk1YUlBmeTY3b0hzQi9uNWk2UDUySytHQ0hnUW94S0hIRzN1U1YzejAweE5zVFIyK2hPUEtWVU5JWkFyNUdESUJEL1BuWDhxSWdnN3FDdk5rdHBaVGJnWXcrQUlQcGZBa0RRaWtjcnkwQTk3MEpCVnBMeWtJY2x3OW1sdU1iWnNWcUt6OVh2MVQ1azRucnkwR3oreG5tcE5KbzZaWGtpZFhjZHZsekNRbm95WlRycHMwZW5OZDc3REFjSjEyeld4ajlzZ2h0WTJIYVhiaVNkeWc5K01sbjlVd3RMWjloMFl1V20xSnNWWHROcTFjYTd2S3FlbWhFUkhRN2JoQkN6UXcyWFl3MHp5VEdEMlRoMW5rODVTWUhLM2U5VThJRHdqbmRyR05jcTJIOE1hYnREUzl1SStLTnNpalpKUEQwVGkxSDIreExVcFN0Q21TWVZJakZCYXBKaytXWkN2V1JDK2J2WExVYWVKMnlUcUoyWmIyYVNFZUhlaXlnRzVCTUVldTZ4MnFURXBQRUNSTGcwQ2xqVnRjTVJFcWR6V2VwcmxpazZPRHdyMDhreWhhRWRJU2s5eVdoM0trRkd5MXhjcE0xbTZoZ3Nic3lXMjhWaWhMOXhZQjUwOXA0M0hSSDV4ZnFPUmFUZzduTnQ1NmJ4ajM4QWtkeTAxeXJXUHJhV1Mwelc1RndrWkY1Skxra0tKUVhFQjZwaEdpdmFNbEZWRktObjdCK1hYQTdtMEFuRHdlb1BsRHJQc2tmdndQamFpbjhHN2dGR3pvdTF2eUFFUkErUzFpOU5BTGFlQTBGeHJrZkRFU1h2blRTaTJjNXNNaUloSWhlamx2MnlUZTA1MHR1aUtWTXhFbENrb2U4eEhtVHA5NUd0QXRvQW5zTW9kNGtaUUZMSWYydzVWMFZGb0ZPZGJOeVUveU8xTEU2ZWJTVmZuaEorakhTdDhmV25WTllWRkkwc1ZPcnVDZ2xDWFMvV0ozaTlHS3RnVUdQbHhsNDIwcUl6RHd1dkhYd0Z1dzlSNFNWdm9nV0xYL2FpRFd4Y015R1UvNzNFaXkyWnoyY1RZRXd5YXNaR1lUdnVaL2k1SzJJWGl4clpSVzNMNHo2a2s3UHpxT2pxTWt5M1pKdEdTckcxUWVWL2R6N2s2dTNENGlkRDltN251dW5wenl5emVJeS9TOW5mczJLUG5uazd2Y1B2akxKTUlGU3hQUCt3S3Vhb0RiZHNlUG16ck9yRzBwU1JrUjdtRjVDMDZqaFNYR3hRSVFWdjdQcUVuRVI0MGFMNHFzWFlyRmhTZEwvS1loRE1xUlFBRTR4eVNuTEJOTm14U3dSY09wWk0yU3hkOVRIMHh6WExFdTROdHRUelB3THpQdktlMnhTM2xpcUNqbU53YUpLWml2TVRlNk1EdC9md3VkSERGT3hGa1dxWUM1MXNPaVZ5VmI2THo0YklmTlIySTJqdEl2Z0FxUUFBYVlPelFvSGdDUVRTR3N6MW5HaWMvNnVnek9aSWUvTWV1OWFEOXN2RDB1ZkJqcWVsbDU0RW1OVTVnK1l5a3JzdzZhallVaGZGbmNlTGRFWFplNjZSMHRteElkUkxUZmp3cGVtNk00M3k4ekQ3enA5Vno0L2RSRzI5clU5b1FkZDl6d3hWOWNRc2hkeTdQVVdzdHY1Ui9OVnpyVHRsV3FYV2MrNUlqem1ONXUxOExKYW9vMHplT1lrdnV5ZnZwVGFsN21jcUtONW5tYUY5b1B3Z3RkOU9QamRuM2NUc2Y3ZVYyL09nSUJrankwdWs0T3gwZTF5Rjg3MERRWHZnQ1FObzM3WTJ1WDduQmVadDdWc1VTWVI2TXA3SWtNZk14NUd1TFVEbjd3aFBrRG4rLy93ejExUS9TQUdJUW9LM2JVSER4V20xVENKQ2ZCZXcwdWtYWGdRaS9uNnNMdU1YV1dvYWY0YzEwNnRIQm5MM1ZRdWpEZHR2TVNncWk1azFvdVdpVHc1VGhYOStCYlA2YUg5SGtwUjVycDZDRjgzS3hkcnpPL0JYdlZVQ1VPQ3FqcWwxdXZNNW1wU1R3bUltcllNU0pjOS9jVUtqazhuZThhU3ovMVlWMEZlL0NLR2xlem0zcm81VlJrbDE1N3lUTFNRVTZzbmh2amlibWlacysrNWRQYy9NWDlSZGZMM096WC9YMGFlR0QzUUsyM1VyN3lwZmUzeVNoSkxvdUxmcmFmWEdBMm5GUEplYjNkckt2VmVpTWptdkRSUlh3ZEM1WlFUV0laalVmeEdSRFRRY0YzcVpYZEtxeTFRNGEzQkZvM1NXdUdTbjVETjFHeEJyQkdNblBralJZQ0hzVVNjZ3l0TldvWXhPNzhkOW5vRm5sOXY1eTRXNEtVN1VNclp0TFFUa0hJRzRFdGZkYkpqd0tHYk1PMHJvODJOUHVNdm4xbGhhN1RUTlQ4di85cDdWODQwNWlSdmkxYTFGdngvSFZsbm1yYitRblc3cmwxclgwbXgrNW96S01UYzdpbnh5TXJDc3dqUDBibDg1NmRVaXQ1bVNvSGpJTFZoemNrTExlRzFtNk1LODhiUzZIcVF1MVovVUZkUW9ORHZPTGRIY3dzNlFIVnphWC85RFFSTHVqVlVqaERnWXJ1YXBDQS9qTzFKQXg0NUE5Uk9GZmhCNmJUQkdKRVJmYWFvWFcxeWUyNEQwRnIrQkVCR3RiblovV0lxK0ZrZjcydGdyQzY1S0szZzZrbzR2QVBRNnB5SDFBNlhmcU9MSFkvSUV0N1FlaXpQS2oya0pDVFc4Y2I3VERFZzlrbFhGQkFyZ3BrMy9rSUN6amhuTERvbk51RlR0OEczUVNqK0xyZUdGb0w2YkhyZkc5czlodmt6bm5SeCt2L1QzVmp2N0dLZjl6OFIzQzNuMDllK0crTnZlcFozcUFidjNyeWIvNTFoK0pmS0Z6UUUzWEFva0JjbzR0QTZmVlZOa2loYzBFc3pYKzY2MzJzUld4M2hyYks3UmlBdEpLQThTdXNuaGxJODNWZDlubmpFV3RuWlJnazBFb0s0U1Z2ajliMlJ3RmJ2dEhpYWxBRTZzOHpORWVIZnRxUE1SRUs2UVk0U0VKV0tSSnlIMmNlMURtMzFONWdzT1NiZ2s1a3h5eUYvYnZDYVU3bHcxT3V6S3J2a0R2UXpjcm84ZXFKYjROZE9YS0dibm1YRWQwa3R3SFZmM0lSV2JlcXZVdEgrcmpocWR4N3Q0eVJBcVEyejRFbkY3VU1zazFOL3dTREFmd0lFZkc1eEFWSmpMc1NOYTMrbm5WdmV4eTFmeVRzWFFublZQTGNPT0VpUUNXd3V2NVZTTWFMYzdwWVVIYkJ5NHp6Z01LU1QxTG9NV1VPdzVVS0JoTUZ3cmNWVmNUSU1qaWlqTStwU0tkOU5PUDBGMFc4TGpmTUYxMnZyaHV2UW9qSEJ0M3BRS3BDYVlCNzNTZnI0WXFpSkFpRHVncXphc0FHU1VEUFk3ZVlWK1cwOW1ZSFF5NW9GTThSVUVEK04zbjVYMGxrUUJodEREK1dhZDZ0V1NlNFZkd2o1QXhxWDlKL3BHaGRRUFRkZDVHUHJNTXowRHJtaHJ1a1MrK0xnRUlEUG9TT1NGalJnTWY1TWRpL3piS1g4WGRPazRPQ3h4czlUNSs5a1p2ejZUbkJhOVYwNmNaelJVWU5Ud1M3RU5GZ1QzS0NjREMxbzljQnBDTTQycktCdVE0SG9ORDVOUlB3NVVDaURuc25FMGJ5UjlQUUUrb25CUDF2VWtvcWpCQmpsV2tIeEdNZ1VCQmVnTGp1Q1FuWkYxK3RoaHhVc0k5NjNLY1RRR2w1Z0orb0NMSUpsUExqa1RXWEM1OG1uN0w0dlJ2dFhNa0Y5Vm1nRERHRncxWWgxb2syb2Jwb1BTS0NoRGFBUDU0dHpSMDVTZFVMVjhLMTBrQ21qRUU1ZUdJZ25iSFc4eDlzdi9lZEc0M1R4QVRmUTJnWWpCaTMxUjFhejNQZjhPLy9oNW1wSU5FUGtQOVlPN1NFUFBaRnZLZkF5bFdocllONlRaSEdqNERTRkVuZ2Vsbkpkc01jc0ZGTjZXd3BNS2hMRXYwSHZ1QzlIa2M5Q2xrcXlOSzZzc0p3R2xrWjlQS1NIcXNHdUsyM0w3Vzg1bzMrN0NoVlNibnF5UlB6d2pFWVJNNG1GNzVVMlcvY055K3dkdDhrckg1cTdiOTFYejBEdkZwYS91ckJRczFvR0R5cndMN1lpTjRQNDZyM2xlMk1kSHBhNENyVUg5SjYvY2lqbnFvY0VLQkxUZ0cvK2lGK0t5eFgxUnNrUTB4YUNqWlVUUktmcW1RVkJ3eFpXdzV4WHZFM3RLSHZxMUZiSzNIVU1adGF6RFdKV3hqY1U5Y0pXZ2xJWlFOM3lDTkpRbHJYdmwxUnhWUWNoT290NXlwNzFpTVcxbVVVYWp4aEUwY0xuSlplTnJkSXYrRnp4STNmZ0QzVlJKVkNwZGRsWnp3Y01kQm50NWRBUEV4S2RUQ1p6OXpaM0p5ZTZka3BVMEFxSVZMeG4vQWI0cDBpcjFEcTNJQXVhcEczbkZFWHp6S2c3STg5a3IxQWZlc29HbGhPRTRMLytkelB1WCtsYWNUYytyN1JGWGVpQ2UyWTJtaURrQ2JrNlBQa25QZlRnUTZrVUNWQTdPMmVSWkJOUllqYkFpQmF0cnFkdiszdmRERTNRR1dvUFhKcExYb0c4dUxXeWNqeFJlK01Lc3oramFwN3RWajg2NmtDeVo0MDZBajFVVjRqcHRHTWVsc0c1Y1RjWTZEUDVXcUFTb2ZaUzN6T0V4elNjMnRPWG5ROUJSVFVsUk5ZdFFtSFE0MHVaSEZBdk94VkZSNjhkdG45b1d5R3F1bWhHQytOUlZzQnJ4bE9xeDJYN0R5M2Z1MDNWR3k4REVTUTVCc2FpRXUyYk9ibHg2UTJpRG1LeUxtL1F4NzRDbXBUSFBRdlJWQ1FZanV3Q2o5ZzM1Mk43enV2OEhic3hydWRJRVhVbnhkakhhaHM0c3l6QUNRSjFKeHQ1TnVIYlMwaFRMUnZJdDl4SnJROHd6Y0tkcEhpSDZxRHhtZ3RJMENpdm9HSWJCMW93SmM2S1liNXdtSEtVbFNRYkgwNGFMdTNHKzJHaS9nY0FLc0pKeXlPWVVsalpDazdrNDhSaWlPU29EN2NTZzNiVmovU0JGV3ljTVUweWZTSWE1UHRId1Z2QmZSdzNDWVlvTUw3am5sRWhvQzJYVFhmZkZQbzU2NVZTVE11NjNGcE82VytXNzNBVi9Mc1RPMUxCc1E4b24rcmh4OXFWMXV0WWVHbWFxY29UOUtTNm80OUVvVS8xdWhRY2tsODJLWFFTZ0pSUG1yUzBOcGRMcEtMTUx2QUZPSmMyc29RVnNGVWJ4LzBPdHMzbFRTOXpFY3BhbVdqVGt1bk1lVGdpQ21QZklpRWJLdGR2dXA4QnpCMXg3RFBHakJrRmdRSDBEWmFhVGxYajFwMzg0RDVpeVJiWnBuVlNYZVRZUW5KVHNsMHZkYmRHU0V1Um4vYkNVbDBMM0V0bkh2a2x5Z2FvYVlJRU8wOHNZQ0ROMSsxVlErVEgxbC9qcWZaS2wyUzNKV1dBczE3Mk9GVDNSanJ3ck9sN2Q4ZnJkYy8xQW5hT3ZNaDV1dG1ud1oxKzVTeTltdCtLY0ZBZFFtNU8rKzFrNmhhTzNVNmNWcHhSczZ0RnIvN0pTQlZmMEI0bDl1RG5NVCszb0krWWYvNC9Rd3lPMHdnNmZmNklyWS8vZjkweTc0NzFUdEVrVXBjNVFkTzRvaDZoTHV5c2NhZ25OdnJQTkhsdVg4U3BHWUg5Y2d5L092aGQvKy9NTkJPMEU1SjNITG53ZnZYYzBtT0hvdHhrQUdIYkJoaktzSHRqcjNia3R2b3R0MmlMbUVEUGJhRXF4YzJTN3VoYWc4OW1qb294NjFBb3U1NGZRaWhGL2crZTB2eUZNYWk3NGZVT3AzaFN6aC9SZkl2QUd5ejVEdnZTSUFxYnlaYS8weVByUGJIUUJPUTRPaG5kOEVpb1BBaUUrL2FmNC9idWxBYktJVGhrcG9JWmJFVk84M0VqN21XREQzYnJtNy9NemVsRWgzME9xTzd4dzJkUVB6c1NxRGFQdXpoZWlqRC9hZW0wWVNmN203TGJscXc2NVlrSVIvQU9rU3hIY2FrZmN3cDh2OGdWWmw0S21Ec0pqbG55R1ZKYjg3NW1ncnlIM2gwd0oxMzA3VGdCOGtnSGpWR0tLQ1FPcTEvOFRtSEhIREdpNEpreGNSV2Z0NDM1S0pBdzNEMXVMY0gybEFEL0tqM1JhVlowbHNLNS8zVHBTZWQyZERIWGNuQ3JYRGIwUVFnSnNtVlhHZmtVUVhmNEI1SHFjUnRzWGdVUEpBVkJBVVVkM3Vkd2kxMGYvQnZzNVJYZnFTOTNrZ0N0Zkh0WXZ6WVpjSWRQNG9EQWlPM2hmTzI4ZGtaWWxLNzhtMVRONnlMZWN0WnM1eW1xVlY0NWR5dHQrOUt3M2hCMlRkanNUZFlWdEtvTUVhd3FxMXVnRysrNHpTbEw4ZU1ZYnNNTlRoNWlTSS84ejdMT2huRTl4OFZKSEZFZzhTNWJqUkpJcjdzTSt2UlJQWGowZFAzbEFaMEdzM09HZnN0aDdnOVdzTWFLUHFGNEZTZmVtOWd3RkhEWWhmQ2VCUlg5UDBkTjdrNnBsRkdwcmRMZnJ4cEtQK3Rlck9TNmJkbVAyTk1wM1RYdStTejEwNVIwbWw3NUZNN25VMThKdnJUUzBnd2ZmdDg3ODlFVkNOUy93QWdpbHM3S2ZrUmh5RmcyUTcvdHZ2bDRGVWNaNjg5bGZEZm5TbnV4V2RlTmZ1c0JrbjZ5ampmVmczdXRQaEc5THFKcXpBSFkxUmJsYWx1S0JmTVc4UGVMbGlkNHplbnZ2MTk4dU1SelNsWWpZS2Q4WVBZNjZpZDlnMmFGVkVWb0ZWNkV4bjhTc05UdFFKcnBTd0w2NkVJbkpnK3RtVFJaOHVmRWNZQkRYZzdqQzNXODhrSnFmZDBueXlhQTdudXdISnNhY0I5UUlnblVzMEVRbUF4N0xVNTgwMGNTanoxeGkzcnVQVmRWSXRmZVc2TW9FQ2ZLWklXRU01U2JXWUhVRnpYTmhVWnJBVkdKL0hHci8vY00xTmpxek5NeUI5dml5ZXh0LzM5MU1GY1pZV21Ub05qYTZKRnB5eDlJQXhmQjVvYjVNdERmTEY3dy9NaFl3SHhMRDBOK1JVYXZrR3ZhYWxYSFhNbjdIa1NKLzVGeHdiQVRidnZ2MmhxbC9COG1HQVBuU0QzU3hyS05qQWRvaGlwTmg2aDc2Y21xUENkZWp3MXVkTzZDL2Z2UEZTN1AyUEZmRTU5OVk3b3Y4TjZrUTRINVJPOW5XNWR2aUV1N2JRV2lvc3hmZ2lMWVN2djlVVm9zR3Vycm8wVGNmT1RlcjNTNkoyY0V0VlpGeHJPM29DOFJMY3RRT3lOY1RYZ0hJL3FQRnM3QzJCandOOStaUGg2bktJZ0JEQndaRVMvSEtWRE9lWmZCY2dleVVRd0xnRXczSWFSSVlBQlJnVkJVVEFCKytUK1UxZ1BBQVFXdmZhME80YkpxeDg0U2NianE2eHZlbkFkdExqaS95RCs2TjdtU2IvRTFNU0g3bVcrT0dWVTRkOXdLSnpBbW04WWZwbDhyeXNOVVhtazRlc2pmVHlpeWJFNyt0emcwZnBnQ1hPWFdBTVhHbHh6TjhtZTBXWUNiVDVtVnlMRFRKZldXWVpMclUra05wRko1a3o4ZFdYUHhzbkZkdlF6b2tpcFBuRmE0ZXFIZjVtSHJ4elJwSHpWaEVjdnYvb0lOdmtyanZGSVhuMWlEdlBYSE5xVGczZU4zVjd4emowOWxqalFIYjVvSm1Ha09XbE5TYTUxMnlUenQyN1EyQ0RyWk1zUkVFaDFBeVdMM3hNRU11M0VaM3NwMVJJTXZRaDI0ZFpBTmtub3BrcDVKaC9pRnQ5aVJWTWVEUUNIQnFEQ25UeTQwbHdtZXJhRjJVZWdBZHB6SVJDbUV1L0p1bmxzbDJVdmRheG5uSVRwVlRBLzdxbVo4aE93eUdVZUs5ZkNZeThsYjY5NkE3ZXN1aGhQZmgwK01jQ0FiTzNDT0dIVHFkV21UeTYxVGhoalZReEZSMzBHTms5dlkwU2E3UDcyckVLMmhtQ2tCZVBZY3JBK0RJT0hPd0hZWnlXK0dOajJrRUthRitZd3pDdXcyM1Ercy9jKzd0ZE1yQ1NBcXlxMFA0T1UwdndnMEE1dGFDSGVXemYvd1dXY0pNMy9xTE1TcDdERDFZZFhXblhOMDVaODAzYWdSbUFwU0EvdlR4Z3lBczRvNFZ1R3FKWlFZNTlZNGxVWkw2QVVyZ283eHhlNjR6aWlRZnkzOUFkUXh3dm1GRkZOOGFaRzcyWWFmRWRDTG9aVVlLemRPU2lFT2EwVGFyRGhWTjdteEt3Sk5xME02SGl2amRGMHhUcjArbzNrSXVkYW0zdE52Rnk3cHNKNjlMWXBVcDd0ckF5OWdoamFZdXZRQ2J1R3ZsNjJTUE9xMlVJSTZpMG5JYnROckpNU3hMUVoyNW9lbnVxcWxWYm9TV3hNL3llT2s1TUQ5am5ZcTNIOUJNVC85ZnJKVlhGd29GTnRLZTdoRHpQNkUydUY0dDNveEV5SzYyWEdWZ3FtUFRqSlZIMFJyU1orNkRIQnZjSVI2dExtR1g0VHRZblZjaUZPTHE4U1ZNUEtDWEY1eVF4RG5OVUdpNXFkZUhGMk80dFNIS1FwVW1BS2RscS9xOGZNazlPTmtzMlVlVXVFbWpqbmVNYkFQYXNRZzVib2UySWFjRUNlaU11RUluaG1MVzlYbE1YL3F1WUhCOThVRlBxN3VMYno5enNBaTVTMHJxZHNFVW5ReXR1UUplSUEweGluc1R6Mi9Rc3JKdWZkSjQvK3VycjhTTmtaelhET2NnWTdtcy9jT1NveHJVZEdmdkRxOWtTcStFRS9KN0dYVmFQQW9DSU13S3hIczdqaUV6TE9obnl1UGxHdUxGMHl4c2RzQ3lTUmlrd0RBRXVUa0JsS284UEhjdWFjSlNrWVdvOC9zN08zeHJ4WDd1ZnM2SkxKdy8zQTZOWDBTblAxWmQ4RnY4cHEwV1BnakxvUkRZcUFIWng2ekVHak93WFdxdnJHTUM2OEdNYVIxdnpNUmhaUWIzdUF5VlYxZ2JlK1lSeGNuTTNmTm9SR0Q4RTN6eEk1V2xMRjFhV0FpWU5WZG55MWhpNXgxMTBxOE1MeWdVQ1c2TCs5ejU2REtkd2RkTjVIYVRzUFdGMjNBWVVOeUZJdklObkVkZHN4WHZpMmpzRm5MNC9LNWp6NGVmYUZ2RHhDem4wVGJpanNxQnVDZDlXRFZ3cFF5ZXFUK2lLM1F5UUpqT1djOXNjWTBkaWprUGNtSE5DTWJqWlU0c0E0ZG9oYTNVYUdnK1Vhdk1UZjlvYTNwWFdyUDB4VU8yamZjR2hkeDFlMXE0V0xWVGZNOHVEeUNlNUMrMWhBQU9Rd29JT0xuS2pZeTZOcUVGaDZ1NE84NkxnM28vVG5TVVMzOUJwNGc3eXhJOFNlNUFXWlBpaC9yN2xEYzdNS0p0WTF1NFVESjc1RDczaUNPU1JEYlIyaENqMkRpYUZIUVh3Ni8zeEJGOW5pUEp1U3oyZGVUSGZCTE1Qd0VvVkt2QXM3WlNzMjFPRHEzOGlqZ29UbzQ3MHF3QTEzVjl5WGorTk5KRTU4Wmh4TnVRK0M3UCtiZU5jNjZGTnRtQytLeXlSWE5XUWJqeXdCanlGWFhFVnNOZ0tOVTlPMnpWNkliK1RnSDA4bkhZTjJXZGdqUEFqK0pXMHg5eGtFVjJSa3IvUVZBRmRVSG1FTzJvVERoYUNDK0l6UDJWRFhBeHNUb256cXlJaE55TytuRjNsWjFKOXJrM21XTlArV2JqMGZHZ1pEb0gwR1N2NEFpY0RvS2Zsdjh2cUJsT1huUVdESTBiVjRiSlpqVS85V2lWYytMbkoycW5jck9LMi92dytXM3NGdmVBL28vOUlRMDRTZ3NmL25KT0ExVnY1SGtudDRQcEU0bEN5cW4waytRdmI2amZJL2tPMjhGN0twbTVXa080ay82YVVHVHBPRWVvY0NxS3BRODJtTDlSNWpWMGsydXZXeFdMSi94REhqaFVmK0JTOTliRDJqdlBiUHpkdUZpN2RtbE9SZjlRcUlXVmxlZ0k2V0NlbUkwMVNRaHZDRHMwNnVGWmhNUnNyZGdqUGdpWmNINmw0Myt2Z2Y4QnZzSWVLbEJSOTMxWG1kY1U2L0NXL2IwbnFGS2szcWNlcnRFbXRoMGN2NG1lbVRIM3MwdVBQK2dEUHROYTRGYnU3VTQvU09wRm85aGNsbGhnQnpQU0dyNEJJVVh4R3ZGQ1VHS0RtR3NvZmkvdTg1TysvaStJMHRKSG9IdVNQM0ptYzV2bFhhaGNhb2JNb0xCbnNGMkxrSXpFSkFITWlRdGp5OCswQjRaUFVpQ1RFZTlFZ0ZpdTBBSkFZZFRIY3dIUTh4bVN6eEx2Vk9FS2ZMMDFFUXpHZnlGRDVyUS9WL0F4RGF2cTR2YmgrRkt4UUUxOTlpRWNMR3ZGRXVKckViQzN6bGtHQnBTSWlHNENwaWdOSzR6S3VyZXNOZVk3OHgxUDJJZUIybCtQbXJSc1BNY3ArT0o5TVVJL05maW10dlU1YUVqT3V4bnZLTDNkeVhGRGkvV1RNWXR6UGdLT2tGc1p6eTJZZ0hhVDZhWXM5OU56cXJVMFE0cy9QVGxmVDRldXpIVE8zdjgvRnJ6enpZbzl3ME14bm51b0ZQNFAyQi92Z0tJa1IycThOWXJsK3RPK1dBWDdLakVuK3psZ3N4U1Qvd1QvUHl0TGN0R1BDR3JaQTlNVzhSV29yVk0rb0tBMXlLVFRBbjhMdHZON3k4akNqVGlyd05wVUp0R2JKNEViS2ZRSGdzWi96bmZXWXE5SmM3UmF0NEdSb3d5UVRCTWRldmFCeXU3a2E3NzRQM2pQUktQZGNDcUEvMVI3ZW80NVhLTlZ0MGhwZUFNM09WNnQ3NFlHcE54TnFVTkpNdzJpeDE5RlNMTU5xVGExaFNCZERDeWJrUWJVZkRYYStXeWZsYVJMdkpnU0plcDVnemRWcmViWkVSaHlyejN5VUVyekVhalg4blNYMzl5YmRwamsySm4rMWtLWENyNm9SZzRWM3VOUjhGUGo2R1FuT3FLN1BqK0xoc3JrQWhNajFmQWZOMG51NDFBeHJzWDJjelBtWC9QWk9KQXRPT1VLd2d0M2I4NjlzMUNnRWJhMzRQSkF0OGlPV0NzaGlUWlFYdTJmOWhtek0yY3NuL2t2RjZCZFY2czYwM2MxZVB6Ri93OEh0d28rMkdOcERSOUhhc1NlY1RnSmpzL1hxdEpDbkViMDE3azlvKzNTUCtJNmlRdTg5SldGRC9KWGNiNFJxcS9GKzA0Tk1uRG5Ldk8vSTA0K1lQM1JlTzl4L1Nvd1BoQ0NjZXcrbzROZEI1SStBQzBOWkFHK2dsaGNicE1UeHZDVWNTblhyWjFpZGZVZ2tNcm5tampjdm9CbzVpZEQwWXhDbWkyZVA2Z25Xamt3YjhPby9VT0s1TzlqVWh4WWJLL3dELzliL25La0ZyQnBZVFJkVlptZ2pOdjRBZisrWjhTR04rQmlEZW1XS2R0UkYrejF0MnRFL1luWWJnbFpsYXdsRHFBcE1YWlkybi9FZUpQMzR5cEU4MExXMHZzR0xrY1hzejJlRDZmTjhMdEs2cyt2YU00OVRzWld2d1gwbFBqSUN2Y3dsRERSVURqN25DeUR6WlA1eFJ1ekxndDBFMk8vaDFqOVBiMmRvRzBCd0dvUGFFY0ZvamtjRCtIWkx3SXhOSmM5UWxqb0pPNW9BMVJVbDY4ajZsczlSWnRtTnplR2lLb3FNa1F3cDVTNjVuZGE1N2RFbzcyb3dKSG1wUEpmUkNFNk9zOWVVVGVHVVJ2VTZvazl0VkU4TWNCUlRsQ24wSTlrYmZTUjhMOTExNllQMU5HTEoxcllFZHYwcnBwdnNESWR5Sk1jQkR4dHpZZ2R5R1VRUDVMN2ovUEJZQnlrbEFyeUFYWTNnZ3hoQUk3clVKb09laXRTYUl6bUt0N0NUUXpTTkgzdEV2YU5GWjJvMUV4eFdFWUtiOVlmT2d3cDlrRlZoWkhucEF1cTUzSWpIV3NUbU9jWTh2b1hKMUlBenlrWnNFaVBjMUM2UmxUaEQ0eDNBMWRHeU5zeW1HSzIrUlZRd3BTa0I3dlFvSjJYZ0s2YXNWR0QwZXdWVDZGWE00Rm41VzhaUThCQURRQnRqUGU1QjRWWVJLYUVtUlo5ZTFYK1JvazZwZTd0Y3dFQnI3R3NIUVp4UUVROU1FQWdVM2VQQmZ4Y09ua1l3SmVEd3dOYVJxV0IyeU5wd0ZMSGlmTGZMZHYraGRrNmg1cENpY2ZBZUc3N2hVbnpRMDM0UDBIZGJlVitQL1c3b0ZqUUZrOVk3VDQ1UzAzOFViM0p2eVlxOUZkdnEzamRzZUwwakc4SmJRdG1OeHVBZEdnV1Vod0pjNFBscmRSNWtjV1Jnb0wyaUlnV2VvcXFJNnFEUUtQQldGY3RrUURrUlVPdnpBQy82ZGtaQU9oMHMrenpqbmdycHdtU3NrRXFLenNKMjZFSlVMVUdkQWVUa0hOU3R5ZStXbm5FRmc4TDYwOGV1K0pUL0ZxYUkrUzJrOUFQNmwyZGFkbWI5U0FPRGlKb0RtYmlMTmNBQmFoTmZmSytjOXU4c2VHUW5TWjRLaXdmYVJYZVBBa0dBVEJ6YklOQ1dsTURJL2hXSWhIWktuUms0SHRpTTRxL2VOaS83dVpNRjBOdDdWdlE5ajljUUxZTlEwK2hzSFJCUnBzcnlBV2QzZUZoK0gvVklqTkJGUHMzamlSV050L1hKeHBVVWRWa09QbXZySWxJYitMUDVKN0ZTMkVQeTZ1eVl5S05NaHR5Zy9MYjRpejRJd2xZUHRwVXp1ZEZmeE5iSWJJWjZCbFZZSUU0c05Ec0I2SlFrbmRBUms1UVlFVWZKQ24xV01aZm41NTJaaHdwalFZU1FVSWhRZmdrU0hrTm1nTVZCbjNqeGdMSWRwZkJ6empBdFEwbEhSbU5NZ254QkNDQW9UU2tRaXdnbkIzdzhzSHB0a1pTVENDMGxWU1ZrekkwNXgyZkJHeE5qcDJwekU1cUtndCtIc3RBQUsyb1BoVWRhZi9XOHArOUwzR1VNSEpIeEw1ZU4xY0g3a1JUdzluVEFoTXBiUHlPbGdJWFNXRFowYnN3TTl6QzFEWFQySTRYNkJzV25WaDY3SEN0aVdBVE5ZbmtEMEU5ZlU5MXErWG5yMDVuVCtlWllUZ0xaL3ZiajJaRmFzSHJVQ21YZjB0UmJyYlpXSFR2Z1BlZ0UrK3RUT2JQNEg4UHFwSzdvV1BXcEdHSDFxdWM4N25TL2RZcklaTjYvcG1YSk1iVVYxTzhWd0JxbW03VmJ2em5CNVJQTTB5aFU5SXpVTjl6Z1RaeEs3NEs1NEdTZ1hGZy9Tc2tCRU04QzE0NVd4Wm9SekloenFhN2cxdnVnNGk4YU1HWXZyUnpOWXFpV0YvZnBNcGlUSW82RlVyL3YzdDlabjVaQlczK0RUZDdZM3A2OGlIR3ZFWHdlTVJFZjVEWVBURjdkQzV6QmhnWU9JeGZ2amNMOVQ2QVJ2NjBsNWEzN2x0eHUyeGNGOUlSazF6WTYxSFNrUlVBZmkyM2puNWxEcEtPL0Z5ckZKTlJHaVZSMERiS3QwQVA3bFVVeDczdEhmUzgwOTYrTk5IOXhuazR4ejlSZ3pQcHYvbHJ1QTZTcllzYTNHdTRxRkNmRHBybzRENndvYzhDOFpPSVltSE5pZWFuQjZ2K1hDNFhZTFEvZkZmK09xd3h2NXI0M3JLYTdNN1hXbXVma0R4QVR0Y0ppbmJvYkhzN0U0cDZ5bE9EbU9WQkxvNW1ralFyTDVNa3M4UFlyODE0L25IQUsyR3hiWWgrYVBPSHY2a1kvK1BJc0xuUWdVN0kvKzBFOVREL0ZjR0p4MDgybzRqazJNcWRGd0QvSFJXL1E1ZFE2cktOQnhTL2JCcHR6bmpFbThPYzJpWXNWbDllOXMzOER2dWJvdnBhdjJGbkhtNlpNcHk2OUhhZFN0VVZiSDJQeXV6cCtKdU85eGtRSCs4Vkc4cHNxcFZWVk82UlhNR1g2aUNjT1lXai94dmFjeUVCUlh6QzhnUHdxTnMzblo2UkY2Njd1U3NOMGtwaXBROEd6SzRTWGs4UXJ2aitnVW1rNFFhcWwzMGMyOWxVL0FSbEhmODBpSmxOTiswMldsQ2xxc3BmSTNoUlNIelpRRzNXSHVBKzZITGVkcUV4QW5iWTN5VzJ5TkN0YUZURHRCT1pZMWZrR01LcTJZMUtUVW5LVDRndVFvSG1qd1NXdFYvUUNqdEppY2E1M3NnKzFZVi9oNHo0Q0NVZ2Evc3UrUENsZXV5R1hiYXRjR29ocWFWL202dUNoNUFnMnRsZ0VsUmhoWGEwT1o1L0gyZFEvUjVUS0IzdTNvYzNkYXkxME9ITE4vaTdiV1grOS9WMkZjcHV0d28wdmE4dWZIdWJJc2RtVjJtZWtxajNlN1AweG1Dek1mUGJiampNUzJoenVua1hWaVJLOTlMWHlVM2ZIV1d1R3lwekd6WU90MFMwbk82ZUdTbGpMUjNXODUycE1BbW50dmU2ZVphdTdZUXpUSzFtUXUrOUwveks3ZHpSRjNDZTRLZHhlUmVOaXA3YzBwU3NtclMybFVmZXRmZGxGc1JlTG5POFJ0ZTd2Njh6R3lyQ016YThJSStTV2FTT0ZZY21KTkgvZXZ5TzBXNGJLQnZCanhjb1MyYXJvYnptVDMzUUxhOVh2NG5mVDg2R21ROHhaZjlzN01WLzUvT3QvWCtJYkIrdzhFQm5NRnA0bEVBTTF0SlEwT3VXZzRud293S1Y4SDBOd3FVdXVCaVpML2VxTnFrcWdGZDQ0L2l5TUw3dmlvV2lYSlB4VmNreGltM2pxbHZkSEtCUUNYSGMrZWFrd1pOSCtPQ09pUnNzYVdBalR5REprS29MbnJEak1PdEk4dXB4VThlWE9SUzJQdS83blpQNzQvM1U3MUNxM3pkMmxwQTRMTnhVWm1hN2JFL2V3TDdsMVQ4TmZQTUYxeHN1eVpJenJ1MjlpNEpDYkhWYU5UN29JZkxlMTNlSWxxVDVQalR3N2grUXp0Q1FRUlJ0VzlObVJzdktGd3UxNDdTdmk0NW9kdG1SeUpmc0E4emkxZ25XaTVDLzVuT1JENytFRGVkREhiUk9PajZ3MGd1RmVnZHFsUEFQSEY2dGVBQk1UdjVFTDh2bS9oQ05YcEEwTnBsK3V3WTRobDZkdC9LUkZkd3pGaC9obkpVUWdTQmlzemVUWG9wbXNJdU5QZjFlb3pnaGVycVdVSjJ5UnZaN2dSQUM4SU5TdzJxLy9zazNUcTFGVnI4QXYxdDlYcHpKT3ZMTE1qb1hFZC90STZTZUk5c2VzWG9pZmlQYXNIb25IQWVXSUk4K3ZUdVI1OEFkL2NWT0tHbys5NU4xcGdkaUloaXVTWkhzSEpwNUF2dUJzUHA4OUNobFlUa1JuMTJ6NjB3Q1o4QnA3c2NRUHJSRUpteTF3RDBES05BRnBta0dSdWpocmx6Z0RkQVBvdXQ5U3VPQWlhbjJ1WUlCVVdrVE1LQ2ttVGl1Ri94VkN6VjZSYVN2S2tLcm45ZHhjWTRvMEdCVExJNyttODhkOHZGS3MzYzUxWm9na0pjbWY0Nk9lRTB1VFRJRmw2TS9KbzdycmVSUThHenZSSlovL0k5SkxablFUN3ZkSHBydjU1SzlOckhoTVRraWJOR2xUSmVLWHhudlRkSG5pdmJvemxrajh2NlZ2a1U4M0YveHNCSnVZYTNnMWdYcWJyQ2xSeVM4NHptWlpBZ01SU2Q0QjVPYjlqQTJCaWJsd1FHMW1wbnkrNFBPSno2VWIraFh1bDdRbTRoQk1uUis2a2ducXpaeTcrWTlVb3JTeFA2NnJBNUFMd3l3b2RmR1lHalZoSlJQQURNamlidWw5V3JzTEk0VS9ZYzdwUysvVzYzUkhhaUFleDJ0dTZqdmhDZHdIZTczdFhxZDIyTWFLRlV3QVRBTG5ZMXRiT1hVSXVDNjQyZDRkVnEwMWUwODVkQ0lydk5sZGtFRnR6UmZSbUJISFo0NXNtTnZkUjV3SEp2c3d2WXlFSlZYdmp6SVV6eklrTlZaYXNMZ2IxVEcxbngwc0R2Uit2cnplZXRDbXpnUUFtSUU4ME02MTZxMjVMOXZzeTAzSjdiM0NKZXU5SFRmeDBLSzdmL0JYa0h2K3BUOXJrL045VFVYNkQ2NEpJLy92STFEbDZ1SEUxeGdwT0RhdmU1WFBjc2NNTjhjYXBjNGxFVkNkWnY4alBqODYzUGNhcnozdjBpQlg3LzYxMytFUkN4b3ZvMVh5eldMMC9MeS9UV20wd29ybVRtZ1BmOXdlY1owM2tRMlBUY2xxbVF4Sng0ZnBwSmVzTkc5TFFwMnBzWDBpeFJ0ODc3YVNwRUZ4L3NJRFc4WHpPR1YyRS8zbW9DM0N5U0UrUHJJN1Y4d2REQUJNQW9VSjRVR2hiNGxwcVNsRmtRVXF5bSt3Q3ROcEIzTVdTL1UzdUFjdzlhRVZHd2lUTjFrNjQyU2hmM3I2amE2RUtqd2VOYzdERXg1VG1ZZWR4WjUyN2p3UTEvaEVvS2plbmJtZFJvOUQyOVhSc0Rrbkk5VHJFY0xMTUtFcW96ai93OFNMY3NyVmFwZFFsRDBGZElRdFFkSFZCOTFuYjNJQ0Zha2ZxOXhmK21RbUxudWFSL2l0Qnl2czVoNG1iNHBIK3pXTlpHQnVQaU15Y2FpdkxtWW9JeXg1Lzh2Z0o3N2ZIMTJndGRwNWlFSUMrazh1U1M2MDcxN3h3am1rWmZMeDdNRFJIaXkwVTJIb2tLR1hBemtEdjM3cEJDOVhHVnlSbENrRGZnVkRwdWZ6TnRadS9sNW41UFlOQm1mODF5K2cyREFVVGh6NWZ5bVJ6cEt0Z1hRQUVyUkFvakd3YXYxMlBzTkRTOEtVR0tqcU5CS0V6c1pXUHFvdHJsdW9UNEZlbHFRUXlMUXpoa2VRaDYzSWtKREF2clBsRkVlVGY5dDV1Skk0bmlLdE55VWdxRGlZcFpzT0VHZEdNMU1lMk1MaG1BY2NINGxWWTFGYWIyaExkd21Sa1ZacWNYSHk1c0tJZG9GT2gycS90UTArSUVBaGFFdnpoSjAvenczcEZGU2hMTVJCYTc2QXk4QzhJZVIrQ1ZFQVRwUnh0cE1BMmlSQUt0RVlpeU9qUTZjdll1SzlGdStGalJrSXAyamQrSlB4SUdMVStqWmUvb2JYTnhkMThwVlZjN3JFcDU5UnBGZkZFaUVHaXJ4YkpJRlZSMTJ6bnhUME92VDJLcWFlbDVOZHBFK0NkbThxMUxIdGExM1k0RkR0MDBBZFdIWnNya3ptWHNhc2t0ck9ZOVhZczRsa1BncS83c1l5SEJCWmdPdG5Hei9kejV4RVQ2OVJxaGRaQ3dNdE9zVDZsY3hsY3k5SkhRTTJWM2FIWW9VTkdYY1Y4a2JRTStqTXJpVDhXOXJ6RVpxSlZWY2NJSFVTSkdRQU5ITy9Hdktwekt4NzRRWHRsa0Juck9Ya2tCeGdTYU9MQSt1M2hwSHVmV0NNWnBOWThrYmN6UWtWbjJxTkYxNkdOTXFrMjhha3pReDBuU2pRWG9GbXNVT05WTkRiL2JvZGRIZHJVejh5VFNZcnY3Z01wb3IzK2VaWU1VS3dvODFRbU1ZMEYzSGEwM2Q0d1BWamFhRlZja0o1VTF1a2xpbnhJTFBIOFlFY3E3KzhsK1FXRitBV0hSM3pzM3VteFRXOUo5QXVKd3hKZFR0TkpydXoyZ05CRXd1ZWg4M1F6VWtOMFFJZzhvcUFnNDJxejIwS3p1OTBWRDM4RXBMdmEwVTY3T0Z4OUxEV3ZKTXU1YnRPTDl2SWM5U3owZE45UWVsRG9PdXJxSldKemFjdytUa0lCVm1pSHY4SWl6NXBuNmlGdFR3dEVOV2tDdkxWazEzN25pVU10OVQ4SVpNd25wb1JtT3NWRnNCSjNGU3ZORzlOd1hlbjhSVjI0aFhjMWFlekE5c3dhY3I0YjhocnZ3a1NsT1JDODdERlZNSFhNQklJYTUxaXFuaGVoZ0ZMR3lLQklYdDYybUFxNFNnRFhIeEpFOGdxdlRha1FEb21TTWRDWjVrZU4zUHA3QlhXdlR6cUU2VFFTc1c2Z3lvWjdjaUE1TFQ4REcyY1NFeHdWazF4VFFNdExyb25CNFlMSWZ3TUtVcy95amNLa1IvdlBGa3dScGZqR0J0UDRLWDFuSENaM1lEM1VscS9xRnF5MzAxS3VpOXB0YlhuUlU2bmJtYlJlcXVNYlVwcGJWcENRUHBZN25XSlRYZWlGdHJVZU9KaHdwQ3dzaUJBVnJHQ2toSTNLTnc0N3pHK3dDd1RlUHJDT1NYZDY3QUtMVmc0K0ZJKzRwZEVrWTJzR1hnMlErWE42cEFxT3BKemkzNXdCTmU1clJnYklkazc0ZXhXVXdPaVdBTUhsUHlHZTJLdlFLZTdZREhCeFNROENwQXUzUS9vN2sycVB5aXdMcFRXbWliTG9VaTBTdWo4bHRuUlpVbHJhTEpMYTJ2NEsza1o2TzBLUktEdDdGRG9GaGJRMGFBMU5hVS9wR3lmNTRmeUkyUUlDbnozd0hqNVRYYm9weGtvcFpDL0wzODR2dlgwZGV6UEdXbGs2aTlNU0taUWc5RXhUOUg5UzdQaGdGTUxad3ZUbDAzc29LOE5ld2xCK1lVMjNhNks5VnlSY2tXMFFUWmtzWkZaa2VpWDNtYjV4OHZEMmNiS21kWVBDNnlHdHdCejdPYXlPb0EyVURxVEhkMmR0SytJMFlXaTJhQWF1YWlwZTNlYzZodW1pRVN3YS9Kemx6OGd3Njk4VlRnRE5OWTY3dFNLNUE5ODRsdEdnY0hLK1F5d08zMDl0RktaZ1FxM05UWDdnV1NTRDNOOGxFZlZ1M3ZVbFpNbkFSU2pFdnBXbXBPUmFhdGFMZmo1TnJuNGpNeDFOaXFNRkI4VmtrTkhFT0ZwUVFHd3F5TkJkU2tyS2R4eXd2RmdjbTMxOG5jMVlOalV6STVWVVNJM2lnUVllZFZiVGg5dkxDMU9Mcktsdy81WjFCUUNKVFUzRXVveklwZ0tPWElZMkZ3d1g3cUM1eC9IbC9DTnZjRDV5TWhzNnZIbG5KYVk4M3ZvZ01RaDBUcjRQMmljbVFhQ1JHQWFGbll3ZGhKZW4rZjRhY1YwTjBTdjFqUlpCTFpMT0kvR2U4U01zMHQ5UUdOUlRoQkgzalNKMGxKbmt0REVoNXFHMHVrU1Z2YisyRmkzU2pkNk9uWE5hQ0FseDlZUmI3MXA4MmZCdVlsNVo1THZIQjlCY1h0MXB3WWIrUk5lQ2ZrNElvS2ZDQzl2dDJZQXI2R1dwWGlVN1QyUlJNU3VOT3RWKy9UdWxWUm9MeHUrTnVnNVZHZDlLcGtZSDJpQmpUN1Q4VnhNUVVYdFIyeUNCRW43bm5CWDZrUUM2ZXY1UnlHUDl5UEhhQWh4eG9YQjZWc2NxTlQ4eHFTNDE0TGhNOU1lS1dzZVpRTXRBVi9UUjBLUXJxOEM2NHhoVDhkRUdiSUtyNzd1SEliMnVibFNPVHk5Uzd1MlNFNGhKRGZKUHd0bUNiUnpaVXp6aHlwSVZsWEVNMlNkeTMwVUkwWDFadjBlamcwTW1mVjBmQnNmYi90L2o1NWZoU2pNL0ZSRXhIditjc01ZSWVMZGtjYmZ2M2EyaTJqcmY1MFRoQUFrRmpsb2ZYUE5nUTNaRVZyT3ZWOGZqbXYvY3I3eGRxVm41Y0E4VU5ZOW1zQVJXclorSHh6SWFnaUwxKy9OL3o0VkgyMFFiK3JRV2tpODBFUjcxRmZ5WkRZMnhDTkZHc2d1Sk8xMEpOYmViREcxQ0Z4OCtEeDhmTjZ0WStpOHRhQ2JSdlc1c0FqSnp6NmluczhvOHdMdHRWMzVxbUk3NWk4Myt1bjY1STVKc2doNElJVkdjYUFjUFgzZFBPYXo5a2ZxcjZ6WlVUVTBDTlBJMG1RWThIVS9UVGs5YlArOHRPRXczVFgvVzRVTmh0WVlMVnQyTDd6dnZJODdOTm5Pc1hsMjNGR3IxRmRZcXV1ZGhPZGZyMkZ4NXlTdlA5QTE5b2RObVJHZVBMRGJnak9qYkhpdXdBTC9FeUhFQkpuRE9GSlNpcUNGQjhIZGg3ajY3ZXUzVHArNEJmNFROd2lJS2tnVVY3OHc4ZXI2OHVoZGtjRkRHcXBPNzFtT0tpVkxOcVc4WW01S2lHV3lGQ1F3MW9UWUI2cVd5RGtOL3NCZ3VJTSsyb0pibkR5ZmRjeEx5dFArNVFDSG1DazQvZTZSQ0kwdEVwVWhhSDkxWUFudnVEVFp0SkJycUQrVDltUWlOQ210M1VpREN5S2NkN0M2dC85bDA2bUhLSGFZSDE3a2tJNHVZNWNjaFhiWVBpQzZFTGJ2Z2U4dzMvaTZ6SE84ZnhZU2xqdlJVcFkyRmg1Q0hsZnBHVExCRGdtR1N5bDdNTmtKYUVaQXpVNTkrWDB0V25wVnZmZngrbW13TjVLUnJ1RmYyUGpQaVVIdzZNL3hleC9Vb1hHL1kvOWROOGpEQlo1SWZ5UzJPRVhPblVWd1QwcWZ2REN3YW5BY2ZPWS9JSHE5S1V1U1ZhTG1uL05nN0FTZVkzNWp2Q3NvNlZrdStyeVVyMXhMaGZBUjh5cjNUU1kxUmt1OEYxbkcySXRCak9oRDc2RUQrOUY1UzBnZmgveGtWMmErRkZReVBBTWVyU0lFZXdmcmVxT0VhUXhRTVNiRkFlMFBDbm9vOE5DbmxuT21SZVY0ektRU3p1ak5jTXIrV216VkJaRXF4UEpVVDR4ajJ3dGQ1TWNvZGRtQXpaTGFtRHBUMDBkajlnZFpENUlEZ2MzQmY4dUM4VnQrUHFZaUxTMFY2Y2NFVWlhUkx1VEpJV1ZzVmtZS1hENGEyVHVXVzR1OUxMeE5Cck5kV1E4bDl6QlRubFIrNjJJSnZveEZ1UU4vYW4zV25icWJzZ2JaUTJEM1pwN0N1a21leDB6aHhXQ0JVd3RXN3k4S0M5STZOMEphYmtFdmcrTUp0WjZNcUY5STJtY2IyaDlmK0p5OWJyeWFiYWRCTk4wb0x4MmlyYTd1M0x4cnBqZlpISEJhOXJzdXJSdzRsN2V6U3NJS3NLRngrOW5RK2ZUbWZqZ294ZC9ld3RQQ0FFOXc5TGEzZ1hrYkZQZFRJVUIrMGhhTjRucGR4WkVSOFFtaEVaYWU3dlpYMXN5bHI5MHFjNFh5Y3k3VHFwVDVMRDJHcnZMcG9uY3hZUnkwTll3Y1BVNWplOVgrOTR0ZHpVOHpPakY5UGRQTDYrTlFrRG9YQXh5SzhZM0ZJUDN4MHFLZU9tL2UvTTdvZmRjNUJiRlFxK3FNYWN4SW5oZmxsczZwZjNCd0g4Q2pCSjJyb1NIMWZZY3UyVHZNUUYzK00zd0hnNlhXTnAwdTUwcXlQLzdJbWZtSHR1ZE4yWk1WaXlFamVlRmlVaWFXcXFjc3pUNWlLaExpZEZSR1I3UnAzRVBZUTRtc0FQRUw3QU9LV21CaVF1Vk5uYjNGRFlBQzZ4MCtKYlhEVFdhQlZxRVBJMGU5NmxDTHo1R3lmM1FIemVKTThlTEdCYmNQdmgrbmFXNm43cFpFYTBmczY2WkU2eDUyV3VzVzlKTzNTTTBuTVJXZTZmZW85UU10eXNmc1NOTEZTQUExQXkvUUloS3BYWEl6angvL3FibkwzL2p2dVU1MTdHbk9STkFWZmVXQ2orMjBBQVlRMS9rZ2hSZjM0RzVxQm5EbFYvQk41NS9vSHR1ZGJ4K2Uxb1VzQ3ZGTzNwbXRvYmFWSXNYTHcyam41bU1WS2FzZWJYMW1jM0xHUkpoeE1saSs4a2NlNXdaTmF2TDhWUitLaWJIeGFFZUl4RkhnalF1VUYwa2RHRWtRb0cvcHo1REF4Z2dyaVpmQXE3Vml6OGNleS9WN0toUmlWOURmRWFVdXpYS3VoZEg3OW1UOTk1TFRmeVpIaWlIbEdtb3RWRXZrZWNjbmd3VlA1azZBNk5PU3BVT2pIRi9GNkZNcklaZXFpMk5FaGxua0ZldWVuTktrSTZ5Y3p6VTBoaFJxOGs5b3JFOEVKQ3o3bnJ0TnBHeE5GNy9IdFlhYjVKb3hUL3QzZmQ3b3JYV0xPd3dCNk5vVytjdkdUZVVWOGRaVlZTaHNMK0tRNDMvakFvS296MWU5TDNZaTFRR0tIVGw1UlRvb1lQMis1ZnIxQ0JlZzJQQ2ZjL0xQK0x1ZTE0MUFHcVJnVGRCdnM1OGg3aHBJUXJpbjhqaDRPVlBNRlF2YW5pY0RZR2FiekJ4S1pLOHlOMmlpQ1BxWE9KWVdieGdnTFRlMW9EYzJaOEJSaERuY1puVFQzYjhIbjBMcFNBM2pkZjJ0YXU3NlZ4TU5kajNWMThIUWsrM2ttQS81ZUZnVTliU0FsVTZzaVVRUDc5SVM1ZGJTRHN5MDNMM3FxSnMzc2FkQTc5N2dBeGE4SWRRWHZNRFJJSmZtSXV5MCs2S21NdHFtbnRYOVl2RWxrUjVsLzdFUHZObFdsb2c1L1NBV1VyVHEzKzJ4RElSM28vQjhLWUNZWGxPTEtRclg4cGZsUWJiaDJLZnkxNXV6azlrdWtiTGZpNXV2Wm1RMWxwTXpNbFhQMmUrRjdvY0dZdmNXelBlY3VQSXY5Z1lwNER5NWdoZW55bDl6U1lSYkpRS0tYRFBMSCtWT0dVaUh2akYwd21qSEtDeUZXVzJjMGhYQk9sLzM5ZFYxQ1ZESFAxSG4zMkh0RUtFS3hyejYrTm4wTVJIWnIydXVKbHVzWXNmck5RKzYrRHVwSXJBUzNralBzR251NFlBVzZuOUUzazJBSll3aG5TbERqUWRjTHZxYlBaSExnT1ltd2p2VG1ZUWIybXJNaG85MndIN1Q4Tk5aV1B3SUJHZXlKZW1RTGc4L2hDbmxJTXhraTV4S2V4K2dKb2k4ZGlyTDlBUjd2elFvM25yYjNFSVdma3V4ZWQvbXdLRHNFdGh3SndUWTFkOGZNQmprMzNzelYwN24ycHY3NVVFV3hUU1hEdHFKcm92d1V5czI0VXM5SUZST0xWU2VNSVYzd3djL1lueHA3R1lYSXZKYjlCZ3hleHVmOEhBbDlpWmdmUE5FV3o4dGJUMzgxRlJJeHdYcjlIeWMrKytOWUNBWjRkRnZHOEhqL1NEaUdOTlpaa05hTkNTTjF2bEZzSFhGc3I3UTBGalAwODdXbUZHVzFBTEd0N3puTWw3SnNhSWhsaDEvdWp5clVjK2RUcCszMmhKbUJCM2VhMm1iQkVaeWlsZFEvSVZtclh4TytUTVdocElvQkRPdCtZY1ZTcG1pWFpWZ2hqZkVvd3U4YjlsRHFvcUJzTjFSak5pblhQRTFCVFl5TStpc0Z4bGh1eXBkTkNUY3RsYUZldUltZGN0NFVScXJlRUpOdGd6citpcUpzK1ovREJ5QXRjNUVzVWhxaDZnbXRVV1o2MTJtLzhNbWFPajEycmRZS3lLQk9KbE5vajd1WWRzTEVtb01QaGZndjNxejdvTDE5MFdrNEwvZkV4WnY4R2xXdjNqOXJ5VndLRk0wQ1hWbmFidS84K25YMEdRVENOdFlsZVdhVk5lT3p4aVE0bE1iVHF1SEUxRko2MlllbnovaVNBeW9INjhKT1dnaTJ4Q2ZRN1U5N0NNLzl2R3hNQ1F2emdlcHd0aTg4MVVFYk1LR056aGVxOU45NEhONCtnM1Y2Rms0Sk1zU2g4UE9Eb1EvenovRFdXdVYvMU56UjNObkxxN3Noc09aV210VVpMUVdBWXNoYzVOYVRGOXZJblBNZkZ0NWFVc2RBZ3lJcklpQXlkWXdTR3Z2WVFkVkw1c0IyeW8zQWZkNjlPZVNUYlJEYmpZdEpBRmxEMlBURXNHdFpxRGVkMUw1UEpQOE5TQ25lN092T1JjbXhqWEZEb29ya2p4RnhVRGNYdUM1UGhDSm9YdjJyZWZPczVKYmxmUVI2dDdNVlBKaEdYZ1BRTW9Bb1RGTHFyYzRSWmpUb1JxVGhoRTBvMWkvWkRrN1M3amhjZmZTaGZwQVk2SnVTSEFibUt1ZzRYblNoR245NmpBRG02eHVCdFJua3RaU0xLV2pxT3J1NzhJLzlRME4vcEh0V2UxMFlvaEpGbHBIaTlsOG8vcmsvanBnYXBQVUFPR1lRSlRmelVwUE5Vd2JmWnhGN0VGMnlVUmZTQTZBaHI0NnE2eDlwSDN0VWxlUmtUaTU4MmtQOFN6ZGJ3UFVaNUhVQXpTMVpmWC9tUTJNZnp0ZWpneFVCeHVCbzVEV3lYUHc2Z01pTlRrb2pTUXhKMmlRQWFFaUQxNWJ6dGtDKytNOVBSdEVvUmtjS25vclBUTWJ0cmY5cm5sbjBkeG5OVzNjbE1WeWVOQmRKWklEZWg5eFRNY3lhWUJKOEN5SXMxcDI4aisrWmgrOXpUalNiZVl5bW1RTTYvK2c2eTBleFcrWUJxd0ZVeDhxT0NDSWM2d29vQ0M3MGxjY2kyb3F5UGI2VTNLcXQ4ZFZySkRKcnJJOGhjeC93cmxSaGE4TXZQclVVZ3V4bi85bFRjcXZXamhGeGVWWlJtSEFoWENUWTBvcFVydmRXUTlCdTlPV2RTblhKRVlDN25jTTJPb2JqUEpnNERPclFZZnFKYkNrY2h4M05PU2lGR3ovUkF3K2IxdDFaNmU0Wlgyb1UrOGhQVUYyN3NjRm9IMWx2MW1jN1ZxTzJRd1RwZjRVekRaMzlLcm0zNXRWN0M3VWo4alkvOWtjUk0zM1Faa1lEL1ZZVlFrR09TNldPUFdnVUhTeXNDRlRBS2tmdWFVc3BYdnA0OUVPY3hjR1ZDQUdoUzZJQ0k5OGpsMXBid0kxNXhHVUFyWmdVR2FZVDI5QkwwOFdBZUFXZG1HNEUxN3BmMzF2WjJEcXN0K0xnMndwWkg3TkxNRUgvaVpkUHhhUVZ0bk9DdTRva2wrMGVmcGlUbFN4U3VDRzBKSXo0djRSdHJFR3VJN1lqVWhZeE1yRWo4Vk41SmU3ekVIaHRONHVwbjMySmVhdmY2eXl6UDZVUDBSMTlteFhiUHgybFpOeFJON0g3VDhOS0tVMTlsMmZsc0JkQWN5MWxmMVJRVXVNQU1WZnBucEY0RS8zTTMxMUhQTE84aE93UFU0RXhFNnluanlOMWZzZCt2WUpSTkVLNGRSUlI2d3BVYTlRcCtwUmxFVUpMYmhFdU5MVXFuYWRvZ0JFV250cEpKNlRWbVBaQ3MyNnRKTWE5ak1nTDA4REw1MVJHdDkwaHR0K1llQ3FUbFJHQ0hucDNPZjQ5NnVheDRKOVlPY2ZCejJSWXZ0REVuL1B3VFhLZHBBTFBEQzhETXd3OU9IU0ZnS0ViKzk5ZnM0RThTdEd1c3pmOFI2QVIvK3ZERy80MzlNWG1oQnBMMWlHcXQ4amFJd00yZjdPTjJHdUhNcTh5dzhrRUJ0bHJtYlZaWHRvd21JNVREYU5qZFU2NDFiVXRGMUpyRDZwU2F0VHFxVW1VTWp3NktnV2R5ZXZwcUVQVjJBUkNJU2drSjJrdE45ZVRmM0t2S3lRQ08zMXdzem8zbDg5OFNYclQ5WkVORk1vZnRKTmpTd3R4M21lZ1VNTWVFV0t2Vnc3ODRlOVIrM2tralBSNklROUJCUGY0ZmVXMWRIVjUwTDBJQUxxNDN3UEx3OWYzaHlFTXlCczhJTVB5Wm81TzRKSGtFUjdGbE1PVU1SSGw3cjlWSGZLN0Z4cCtjanBtK2ZLdHMrLzdSS3Z4bmhwSGVEbVBWVU9XZGtXUFBhbmNYWmc1ajRkNzNGUmxUK2Jhdlp0elMzNjE3dERIdkRFdTd1VzMvVmczNWVIaGd3d293NDkzTk91eG1mTXFQOVJOby9UOFVDL1k2TUZEQ3U0diticHBLUE1SY2lUb2NEM0JKMHdHTEs4TkErU1JzZ3YvU0RMdzFhakF3bnZSRDdRay96TmI5RGpvZWkwNWZiSVpacVEvL3VHSWcxalFLTkdSYVJsRWtGSEk1cDdHNUNGM05oU2UrbmR2RVQ5Y0tGdk9icDNVTk11WFRKcUtRcm5SMlpPblRUOWRSZDM4cW1HUE4wNTR4ZTVzZG9rNXE5WTh0L000K3dBSG44RFozRllTcEpNbUtEREt3c1FZNGp6SjlwUTFsam9nK2xsNXVHOGpSeUY1aUhleFlteGNqSEsvdFRSN09pSThlenhOd1FrSzVZOEsveDFwNTZaK1BKZldSMkhmcjRDQTZaZHF5WEhod1BtRUF4L3BKS0srRFU4ZFFmNExkRU9sSmhRMUpPTk0vTEdCWmw0aWpZcTdlOEtqNENuRlVMRkVDRUlBV1FpdVlIVHUrR2xqbXdlSUM0QkVmOWJYMGFBbkErNFhsd1dqczRTMWg0MVBZTzN2S0VoVlBJS21xRmNLWEtsSWlCK29yVUxjSkd2SWowSUV1dmNvSUh3NEtGanMxWmo0RlNHdUZXdDdDRGtyTVRTQUZrc0F2SFFHUGhJZzR1bHk4RzVKSW00TXJtZXc3YlBCVUhpeXhDeDdYMkNmbEdNV0xkbytHWTJMem9meTVUejZGL2wwREpQWEl2RklFVkR2aEJDdWR1dmNaUFBudkZDTGNPdncyVkRhNm8wSm9Pazg3WXdIcllhUVVjYjAxTmsrNDFWUW5VU2hNNHUwOFpIWDVNZExPbHFLV3QvR3g3UmV6RzVzQW9ydlFkT0EyYnVzSUVKYWJzSnRlUHlqYVM0dWdwUUZtRTBiWFNKQjRWaEZQdWhxeDR2QnZpckVEZm5HOXNZbmZDODRySGhGeHBLYVE4S25GUkpCVGdybHNHMFVOZTRjdW5kNlJlU2Y4QXZMbkc5RkR3bzlMNEZURjJ0bE9DZE92SFRkanR2SWJ1ZTZsdm1IYThhdkhYcndsN20vamFOVXRDZnJYY1JWS2daMGlaNWMvb1BtbnFiMndmTHc5dDNZcGJ5cXVpb1NyckxsMUhCSi9xa24zRE9HZXExYnozWGZYSFEyNUJsNjVoaXNxbENncVNwRDhnM1BxVGQ4b0FyaEN1RmhOZUhWRUsyd2t1Yll5cW8xaU5XdmwyL0Q2cXhXcUczR0szdWRHK0ZheVpqZVRJZDVoeTlmaEtId1dkZlZuYWZVRTJLa3N2OTZFREhxVFhNRm9ndktPc0ZLOTZTTkx5MmhKRDkzY0VRRjFSc3h1amw0ZURta3NzeXdVa3IweFJOWHpoTHlRa2QvUDFwaXBsRnlwcHVOUGdEMkZzS2xZSE5HYWYydDlGbW85cTFyZlZZUktHR1cvRjYweWlzNys0d3JVSVpPN0dOZmxUUlFyNnE4bk1rOFd3N0JDZXZPSXlIV1VscEc1M2pLWUt1S3dXbXZCUG9tTEE4LzZKZVl2a3g3dmhXZ3RCSlEzTXhhRHpwTUtVWTJQU1hWVm5qakdmUm8yY2ZTWVFlVE1vUFFhWDg2eTlLY1hJUkFhbElaL0oycUo5Mm1mdHdrZjRSQkJ1UXFBVktybStoalFVSkg4RVAyK2RGRTVDQ3F3NDlWcTczc0tLWmNISmdPdWtNNHpOak94YWlTY3lKMWJqd3VaaDhVdGNzMGsvMEx6d0s3bW5Fak5iZHBJQ1h6dDgvVEZSRGlwcUg4bksxcW85dXZOalFaVWErR0trZlZKVDdrUndIa3QyNE9kdE9tcFk1L3pJY0N6SzhIbUNNb0dpTkRRaEF6WjJHV1ZCVWo4YVRoYXNRQTc0eHIwZUFDVjB1TU5HZW9KRndwVzdOTTIxY3F3RTJHVSttU3NBdmt3WDVKYUNsNlZrOUpZcmw5enlidUN4RVZpVDNxcno0V1BEc3MyN3A5VW5MdE4xKzhIMHRoU0w0ZWdSbWFQQU9tUFRudHgvTjVLc0ZGQlU3SDZVcGtQNWY0d3N0N2ZCYVJmdmlrOENNOFM3MjJFWS9Vb3A0dVBhcy9rOEVmcTI3T0l6Vm9KUjU0b3YxTy84cmdwUm90TzE0NlQyUHN3alRQMk5TRlNsVXJYc3E4K3RqNXFTZkJCUFhzQy9teGpwZE1KUWs4UEY2VGRpa3p6bTdIV0NxZUYrbS9PRk03dGpzaVB6UzJXMnMzRzJ3ZFpoMDJFMHpsM1Z4RmRyMFlHdDJySjVsUWUyb1VJbWhkTTEvZnB6Y0szTXRxSFlucDNmWHlvV2w5cElRTm55dllNcTFxakpNaWpYcklWOWVtT0RuTkFDRjFNaUJKZVMwZGpqRk82bzIzaXN5YW1WTFI5WnhZbTJpU29qV081L1FaSkppOTZFWVNodGQ3a2JBVnJYRWlCNitKcXk3VUxvaGlHb3pXWDBNN2dMbHRGajRnWTFta1ZSZ0NDWmpjOHJtS0tkSllDL2dwNHBCK2hvRFNEWkhTUzVnVWxaTjBtTDlaWXQ5VFYrUnFya2MwcDBkclZsZUJUeStMSm9vcVROaVoxZTErZGlzVEFZcC82YVJ2aVBUandyV1VtK0xNSWYrT0xGTHlIMm5UTjBsbTBDd05KQzdrazlPNmtFTkhERG9xQlZ6b08xakVvM0xWQnMrTm55SGtmQjhKdzVUdnp1VVVtelhVbVZWMGoxZEs1clJOK0NGU2ZjTldOZk05OHJVbkZ4OU5QSW84bGVlUnJ6dDF3VnBxeXF0UWUycmx4ZWh6M05rOEJGMWpFbkxEVnFkb0ZBQytGUWVzS01BWW44aVluRzF4Y3BwdXFTUTF3MmpENWpyVDBSbWs0SjJTcEx5dStWVEt3bkQwbmtkNXZieWpIMHo4MUxIOEt4ZzBFOEFzZW9qZkNQeXM3WkJ3TWpNaG1HcW1iMkdtYTNGZlFEc3pJVG8yS3o2RVp1bGhacUpyZ2ZpcTR4UWZIWHNRMzdBNGZUTWI0Y3ZOcnhnelU5WURWNlUyeml5TmJaVkhUblB1YXkwTmwwYk5JNmErbGV6ZUw2UUh4bm5GZ1NsRDlXNEJEMDlqVmQ5MXZ2SWdSSGo3Y0oyZTN1dU9HMFdTRHpzOFBIUzNidzQ2OExoMWVIcnFiVjllQk9POVlKNW5MdDhHcTRHdG5uRHYwNWZ2UVNDR1pFVzRtV1c1N3dCYXNiR2prUWJUSGd0QVlsNVdkMGwwaEdyQlR5WktXM3o3NTJIejlLS2FsUGphRG1lN0NVVXhYVmdVWXlRbEJveHpDaWQ0cXFibXBaSkQ0VTk0ZHl3VDB3cFR5YW41NGZhWk1ublFta3Zrak5UNGlIaExmSzY3clNKWXVBRnA4KytzT21RbnB6UDRqUXpMZjNlR3pPay9YUytYbmJodklTVzZMN0lFeGpWSE4zVUNqTTdCbnNwVVNuQkh4Rmp2a1E5UFdMOFhSdDQwTnRyT0RYS1NOVzh1MGN6dG9EZlBadVB0OW1ENXdoaC9QVzVqYWQyZmZmMUk3SDdDa1VXVVh0Zlp6d0pJQUY0cmxSSzlScUFhb0MvMnJ3VzZaSm9TbXN4OFVhMW13d25EbHhIblBPOEpOSERMcmxQRlNYeUtmK0l2djkwclZKMmRyYy9Tcy8rRmRzUGtaSUxPanZ1bmMvTUZ6THZTbS81QzhhNHpEb29kUlZpRFNwNGhuNkZEd3hla2o4UFhDRm1ESHVxa2V0VStQLzd5R0lnYkIydGN0V1EzUXVYQWR5bmt6WFA4UTd0emVMRWJ6UVVhK1cxRkxTdFphWlJGLy9ZSW1SeXBxWHF6N0RrTFBqMG5YdHIzZUxPZzFFbnJjbm9nUU1scC9UT2V0YlY1c2RHN01DK3VYRFp2TCtuajc3cUlMMHZQWlArOEp0bUltY1VrS05FWjF2amNOMDZxZUVUQzg4Z2ZwYTcvbVJqUkw1ZWxxYTV6bE5YZGRZWTMxczhsZUV1UFE3dnBuTWw5cXJqcGxydTBuTjJ3Ni9BNm1kZGd2V0FqT3FMMGU0L3hvazhLV2hiL0lXZUU1RWpPRUlDeUdUNjllVjcxZ0Z1MmNxV2lTM3N1aUFiNnRmdDV4STJBaHVBM1hNRk1vMmdJWkZnR3Q0bjd3WEdRQVdmNDhvNW1QamJ6bDh2bVhnUUl6SUMwMjFnelYzRVh6U1dsYmNmMzlsckY0anZZdGU4N1k4anhVZlZ4T1BTSlRLQm9DQ2VvbUlOL0hxenc0UGtLRGhTSmluRGt0Y1JVcEpUNTJCb0F6VjMvdjhhbTgzczBHbitBMnIyOTY5cHVWeUJjbStRbC9MQ0dVUjB5bVp2cCtIZVl3bERJQWt2aTkyQWlRdVYvOTVUaTZIdlRYN3ZLTXpYTkduNzN5NTBHUjU3VUdpOWJ5aWZSRUI5UFpORTg5cCs1SjNLT1ZzWEhtNXBEeXNyYjJ6N2JwZE1Nb3NpbWVXUGlUTHI2bldVZkJOZ3RNTHQ4RStRdy9TbjZYWHdGeERWRlV6dkFqdGIrVmtBZ3RwaDRTcUo3dmtLZnVKbnZrUzVqM3Z6dDdrcDRRU3dGbkdPa3ZBbzdOK2Nock1kdDZZcWp5a3lvUWw1d1JEenVlcGNmcmZxa1FBVTA0UEUvUGkrdkZLOGdMZGtpdkdDaGhFakFIUjVrdzVFTjBKdHNqZEp4TnFjL0dUa29oM01FTlpLK3poZmVad1Y0Smp3ZTQxeGJhVzNtV0owTG5yQndYbVZRSFpJN1BXcUdZbDE3UnlOSmtiaFBGcWZKcnAxa3dEbnkzU0QzNmx4TE0vdktUT0NJbWR2SmN0aSt0OCtMTlp6Z3BtMG5NdEN1THlvdm0rbHlDa0J6dFpaWTlqdmIvbTdNSXEydjMvMVFQNEQxOVNlUndnRE5aODlZRGp0YWdhMEZ4Q2VYRFFBdHB3dllnUGJOQXZsZ3Nsc1dYMURaakNPUUNtNWFXbTNtU1hFd2JPaE4vSXNqQlNKeFJGSHllbjFXV3pMOGVXdGdURXd1bWduaVhFTFdnWG13bTJXQU9ObGdDelFENWVSOUh3c0kyMGUrNWlVdjNpVzgvOEpsNjZaRzVXQkkvTXhNWVV4RGFMWm1pMy9WSDFkU053bHN5Uy8vZGN1d0wva2Q4R3UzWTIzTGFFSUZoVlRIQkViQ00wRkIveUZyd0h6WVRWaEkxNXd2VUFMK2ZYeXhUWW1aNnhVc3I2clJDVEJmR1FKMVk5TkJ6bDBDVEhBSGZIVGhhcENDanlpeWEyVzNKaGpCVEJmMlIvVGU2Z2F4NjI3QTUvOVFJWVc0YkNFMFZyRVpNWm1GSjlhcUxsb2paNG5IOHRvbk00Q2t3a29oTys1MnJWWEVZWC9Id3BMSjlCTWtjKzVrZ2xIYzlxdUhTUWhzaHNUbjVIbUJxVWJ2NW5xWHVJMXFJUEh1R2tpZU94Wk9QRHlGc0lvUENhd1lySDkrd2dib2VKWEVOc0tmZTZXWWlBaktGUGRNMEFSVnhDemNNVlRLbG5tT0dRWDVRVHN1UEJQRDRIUWhhMEZycnYyUTBwNDBnYzIxYzAyOC9lVlZVSVdaTldUUUs2TFNxNW1IaG5wNW1KVDhKZkFVZUJhMlV5Nm9aczRWS0FBUmtwL1Z1K1lkbTZzR1Nzam9OcTQyR1plR3FnUzFYa0JDNENYNEhSZ1F3eHVkQTgxQjJmay9SLzNEODVBTHg1bjVoeHRHOE5GNUk2NGhya1JPK3IrZjNaQThkT1BuQ0RScitqN0xQeG5rc1FDZUFoK0I3WllKYVpwekJmTEE2OHRjdFdQSXVTVm0vbWlOQUVXa2l5ME1Ua3NWdDU1azdSbWRDdGFGMWxRcUQwMlBnQU4vQTR5dUZUdlI2a0Z0SFloS2dVNmJIdmhjbWN3NzRCMFlrbjkyMmxvVld4WUwwc09BM3VaRGFITXFXRUFIaVQrZFV6akZMZjFOSFpmOWZSaURnVDdBalJzSmpyWGxTWlBsa3ZtakUwOGxuL0ZOa254SlN6V0dVVFMvU2xEckplYlA4RHZRb3lBSS9pZzdyT1FpbDVhWVZ6REtweW5tbkxwRUsxOWlkS1kvRmZTbFI0QUo1cmdWemwzeVZLNDdDTzVkM1lGeWtYUEx6TXVZc09hOGk3RWx5WjA0cDQyQWlQby81a1FocDZXV2Yvd2h1ZWFWbzJhYlp5ZVk0dmROTVR6bmpZL1VxTGhzV3NpWDdPbkNJZEFtaVY0Q0xoUmxLTW15TStHYmdqTUtlbG9CRTFFQzdwaGdIK2hzeklxT3ZIUWJHNWZ3TWIveUJ5T0wxQXEvSlFKWExCREhySEdLajl1V1ltWExXeUJ3WlFLTlRkWCtnSW5obGxTRXNvVlBaTEZBYkE2UFJDYWNrK1NKQitMQmpiamlKSVNmVzh3R2FGZ3RYbTlpZ1loa0NuVHdJSW8xNGNyVXc2dGxoeWxXY2J2U1NoNkRiREpNamlIRWZPSG5zUDFzT0FOd1dpUXVrbzNWR1dsMkZhY3prWTFUTEpvaEdKYVdqb3VpcFVUcmhhV214a1NucFlVckJGQk1jWFoyaGFhbUJYWjJVVXJXTkhMNVdFNEEvbFVlT3ErOW5DNmdhWC9DbTF6ZjNIWUdBdXNic2dWTUJXU2dieXIwZWRsSWJtQ3p1bEQ4MDQvc0FYZ1krRUhaRHVvQjhZN3FGa0ZHSndlU1BuNkVJTjhuRzJ3SU9CVlBmQTg2b1hZT1ZNODZId0E1WDhIaTRjcGNuSG1tZ3dhUUJXcVFTay9WK28wbXhzODlldVNrTzdLbUJRVTlubHBCMUxCc2pGT3NwalMxTFFOdXFDR1U4VjhQT0VKbHFtZ01YRDNrMVN1MEJBTHpVNmdLVnhRR0RnbnFDc21jZm9pZlRmQWExNW9lckpMV3FHdmorUEdFWWVWUlZIVmt0T0NhNDZIRi9ialdPL3p4RnhLdWxyZTc1Q3lhSVpWU0UrZGo5L0xSZkk0NlRnQldvTjZuUzlIOFZjL3JXc0dPV3hDQTV0SjN0aHI1S3h1WitNSTdxdk0yVkV4NEJBNGZIQmtBbnMrU2Q3eTJvVHRKTTUwTXdlZGNwUFhqOTgzbWEzUWVMK3ZPMTVnLzNzSjNYYVJsNFAxTjcxTGZUZTdyVEphTEI5alphVy9VMkcxWW45a29QME1ya3FKWkRKdUkyZ3ZKOTV2Mm8yOEpLZTg4YkpaaFVpaFFLUG1IWEtGQWk4ZXB5SVpvbmw4SktUY05VQ2J6NUVYWTBHbm9pU3N0UGd2d0t1YVZnUnVVNWdJdzNsWkdyUlI4cXJ3LzA0bXNCZW5QVmN2N2Z1S3MwTUd5d3JtYU1xODVNYUVURXA4cHdlcjhneW5hYVNOY0JycTJwS2kweGhkRHVTZS9mck1WMTJyQWJodEhvcVd2QW03WnZzRTFTNG1md2kxL09uWlNYcktPajJselRReU5pSmdXZlBwQ0s2UXYvSVJ6cHN6V1EzV3BySFBYaUIyOHBWL0tKN2Z1Yyt6eFdnQ2VQenlCWklwc2xJZHBMK1RHNmhkbTBldTl2WmJ3WVRBSjFCOTlsMlYwUmoxWk92S3pUUm5TaEdGamV1dmdUNGN5b0FuTmJ6cFByNExPY3JPK2JUSS9wSzJjUW1Yb0grZTFnek5FVkl0R0Y4U0lPa1U2QUJwdGhWb1FKNWhTSGtoMVFQcS8rTlFnYTVCZVVtOVlMN0YzWEhTRGQ3dHptR2xsSDlBUHc2RDFJcnNIWXlOOHhudWlBRU03b3dwMW0vWkdqL3lCOGJCbmpONDhEM3AzazIwdDlMbWZPOXlQSEloRW8wbHdGMTlmNktGbFpwbElQNjVZckp3WGFPcGYzelFTVCtQU1lyUjFnZEtlbGlCWHpuVDhPVnEzWFI2RjBFV3BwOTR4ZmhzY3YrOXhJZERjVno5Qm9PK2pPN3dub1NHaDFqbVpWMzhYNW1mbzl5NURLU1FJSnFlakNER1UwR0JjRXZEQkRCOURDUW1Pb1JCbFBja1h6Z21rcGZFQU5QZjhPUlVhN2ZpWTRySVVwa1lPd3d4N3AwUnRiSWlPc2xPSzNHK0xiMy9mbnFEQlNJUEh4U3pSVnBvUFU0S0IrTVpveERkU1lOQkNlTUFCSXRvVmVQNGx0V3N6MzAwQmJJU2owK1ZVMVRPb1pDa3BLU21kMDMvMU0vMGNQU1F3aWJjeVhlUEt1dVM1T1lLWjV1MGk2cVV0TW5XNWh2Y3BNUlBNcDc5S1R2M2pYc1JGa09BMG5yeStudkFvMHZkSnhRY3FFZjFKTVdqc2RRaEF2MlVBNkxjUXdGVHBmTkZ1RHU2NVdJazNiNHc3YjlnZkk0cDNmTEpxLzJDdVRybmRROVZjUlhtQlhTKzFYQko1NUFoMTNWY3NuRHZVV3ZSdnBpa3NkcnRhall1ZGUxMFpFellkNWZNUEozOGtiUTZOM2FxU3VEMEt2S3VKNnhGODhEa1o0SndkblF4MVdGNlJUUis3TEV5Z3JUVWJZcXRHSjZFUFZOR2kwWmtneDVVVGN0a05sd1hqc2phalAyQ1pJOU0xOWlUSzBIQTI2VjY4ZE13OXFlUlpBSzJVeDYwbksyakpLckJRZGt0M0h6SVJLei81MzFNS0FLbHF0L3ZEMWRGVjVKS1Q4U21WYUxqNlFLQ0hPaHFreFBENEJTd2QrTW1MWjhIMjg5REVWcG9DZFYyOEg5L1RBYTF0RzZ0SWJ1U1AvR3dnbjd4OExJMmQvVGVOL0JlUGpvSG03RFNUcGVML1Z0NDdxYVp5cGlRaWZpeDZKREorWkpoTGlFdUZVNEhUNFdkZTVFYmtIV3J3L3lvOXpRS0JTQUY1NDJiOW90QnptZ3hNK0hyNWYvRmlSNzNkbExORWQ2RWxMVGVSa2h4elAzbzZYNVVQaFN0bDBjUUNpTi9aQVN1Y3VBQ1MrU1IvQVFyV3Frdk5qSndCOUMzSUFGT3UwS1Faa3RGRVVrck1nK2labzdNakpqOE9rb2Y2Q2JpYUtnQm1RcUtCV1NPSnYwY2p5SE03a3AxbVRIYkg3NmRaekRlN28zUDFhZnAzN3VvWjUreDhNZjFNdHZaUGRlbTlJL0NEdU9lVWorTDg2NkxyZERMSVdZVHdxREJ2Si9WRTNYUzFBai9RdFRzSXRQYjZNQXhSTTA0TkxEeEhTWWJhVzV0Zk03cGxZNjhaKythUjRrdHlRZnJac1VVRmllUmpxTjM5OUU0UWFENyt3VUVhcXRaZXB0Mjdkcys4a1A1d21CZDdVUzl4M0dFK3QxV25RUXd1SDUySUN3eFB3UVpGUnlVYWhwZ1FUOSs1VDl1aDIydVdBdlp0RE52N2REc05OZHVzelZ5RDlWd25PN1gwU2FneWFySTRJU2dRRCtZb1IyWEpaNDFteVdXTlpNbG1hWTZkdFJlaWpkTGthQ00wV2RyQlpycitGNnhocjdPK3hVZFQrOS8yM3JTZjlwdjJQK3dkTkl2VGY5dUNQejl0TjIxLzJQN3JnQWNIT24yKzFOa0d6YjJQOXZibHgrK282a2RWb1VySEVyRXhxZUZnOFhtK2VPTjdKVGF4T0tkSW1GbVUzN2wzakR6R2kzSkJRUlJ3dWMvMGllWVJXR3ZWOXpqUy84KzI2L0VjYWkrTXhDVG5BNmtOR1VtRm1FaGNQdGpUdzdRZUhvU2NuMi9DQkNJWGZCNXNtbjQrY3F4enBLUmlhUkZ1bmYyejhQQ2h0WnV4b0NGZUoxNzRob3NhQS8xUUtiQ2NhSmxZM0pDU1dsQWI3QWlPRENWVUJldmg5VEphQ08wdktqei9MeU9ZVUp2eCtzRjZzWldoN090RnhyZUxrclAvWTZTbUpKY2toMGNWRTlOU1MrTFZTT2hNWW5STWFsd0FOZzEvTXAxQWRoYlVsYXJRYlpaeTNJY0ozbEFMd2RZZWlUYkViRFVuMXdIcit1YlkyWkdpa3BucGhxYjFuME12SDdvaG5TOWRVR2Y0L2J0WXk4d1k4QXE4NVI1RUhuYjNSRTRNY2VpZUlwaG5MdC9vcnlpYjZhZm5yNWR3Y09ZNEkwdENDTlM4TWhxbHJqZ3pDVzVZbTJ3ZDBEdURLMmJpQy9zSU9PanF5SjUrc0J2MG02UWUyNVdmVTBvSURrcU9wUktLSS8xNTljdmw1WFhqUlNscUpHYWs3cldIL1VsckVLMSt2U3dSVW1NUVVxakYrS2pUQXZhTk8wWUJVeW5tMGJoYWVHQm1ZZ3k5SWoyWlAzclUzVncxREdFMUNFZTcwcDdKRjRmMjhvdGZFUHBmVWNRZVEyYy9maDlsNmV3WVI0R0hWVC9HVUl6T0VSQ3hBM0VoWDIrOG5zOTJHODk0cWZYY2pET0xJM2dhbHVjMWRyclN2U0ZJZS9mZHdtTWNsSjY5MFNkOTRiWkUyYjN3eHgyb2U1Zmh3L0E5N0l0NitGMnRJajAyekh2dWdOelJReDc1Tyt4cTRpYmtaUmtLcTRoSHVVMVFrS2NaVzhpWHdLbzJWTkpSakZhS2tnVW5iNTFJWUJXZVNHQzFTVDhhWVhFcy9aam9IemdlUUZUS1ZvdlRHMHFEQXFLOEM4UVZIMTQ5aWo2Q2ppSUp3emRrTEkyd2VXRjZ5QkNqVTBibGpRZWxqZlR2YlNtUWNUMkZUcXNNeDhMencrd3hNNlNRNnFqV1R6bHR2VHlNZE5pOGsxWmZYQllaSGJFdVRJTWk4NFpYb0x5bGpiZVNqOWxheFhXL09vZW1SSk1xVTRzL21Ed0oxQjFMLzJUMjVHYXFSNXB3Ni85UG40cmRGSFhOTFJaWURVdmNFSkFSV1JMYXl1OVBTY2p2UWRhRW5Db2N4YWZrRHJTcEtTMHVRWkdEWGZ1dE9YbnI5U1BDT0dYUDZpUlNYSFZPRGlDSjhSclNSVU91Lzc4c0lpM2lpcENYZmJiT2R3UDB0d3ExbGQrZm5GZzAzS0xVWER5Q1M4a1phSHYrZGxsdjBOcWF4NExPRFg3K3ZPeWxNTUlTY1d4VTFHcjhHRmtUeXllZ3VKY1ZLaktZenNmVHZCeHA2TTd4YVFleGVKZUdtZUpZYmp3V2RNV3ZNU0pwY1lZSkNIcjg2cEl1YStVKzhTcTl0R21paWdJYlVNa1p1TlNVV0xzQVBncysrWmIzNmY4REtCSkM0c0JRc0FlV0F3LzhYeFAzVHZJUzZOYzdKcmJ6QjJmM2E4VXFscytOSGFkbWRyZHBOeXlQcEZXcEk5K0p4bHcybHB2OXpISUlSZklTd2hORmxWMzl3V013OGpPNWIyTW4wd1ZhYUtHdjNudkdxY3djN3NmWWVZaHZocGJnL3Z0R2t1WGxveGhRa0hISGhnM2dDanNPb09WRjd3RlBRQXA5QUp3djFNN1lyS3p1Nkt5RzdCSnk0cUlUR3NBMTRIdzJjZmZWNzRmMEs0N1gzYmpQcThqa3lkeUhwcU9qcnd6OTdsNzc5dWU3UWZ0S1IxRGtMMWt0dHdEME1xNXdXaWxLTVZxa1YxblJOdURIUEdFZTlkbjE3WXdtMjRKZjlWWUJKSVg4bk43QlZ3SXY0WjVmMHhHbTVDTkJrSWozNU84L080SWk0VWRwanNpQllVSllqUG9TZHJGSnQ1T0dIUEN5RkpSZjV1RCswZG5OOStzSmh3MHY3U1VIeDI5R0YvZXZGWTR2dkc4dkxycEtaWFNLanJUSkduWjBaaWJnV0RMYXhVYmJERjdBQWpMSk5qd1BnWVA5azJQQ1VueU5NZjdkRTZpUEwyRmJCNGpKTlZpZjN4TWk0ZjJnKzN6NTBVWmlTajYxV3FvcllzWmJzdmNVcnJnc1JWN2luZGpwRjJ2aVo3Nm8zcHJ0cnNRMUc0Z003NXNTYWdqV2hoeUxsR3Z6dmZTR3BmbzVYS1IzU2w1NVlWNXBMMVphaHBmbUFYS0Q4SDkxOTg5eG5VZkdqT1IvWHduQmQzMGQ0SU41dkg3MWpzV2RnMDNvb2pWOEkzSjJnQlliRW1FRFlaVGF6cWFOUG10dEFvZVAwcm02RHJ4NWRaem9sQS9jQjQvc2ZrQ3FyNHFKOG90TEx1bFNrYk5VK3RWc09ZZnlMR0lzSXowejM3M0dCd3dKQ1NrcUpRZlBnNXpsVFQ0MElRREg4aHg4VkNFMVZTQkNzWHpmeEs3K3RWaWtYWnZ1UUZMdFlWSjFZVjZKTmJjSUgrZFJRdWFSeTFqUThiTmpTTjB4Nkp2bUtlbUx5ODJabE1VMk9qZ2N5UTRaUE5ibGlDR1ZqYTlvOTMwYTR2MmJhWlFUTC9JbGVndlM5ZzdpQXh2WGxYQTlCKzE1NHFPZEE3NmFmSVcvbXNwL2VSV2tqbmQ2ZE9WM3hCLzRqOTZWMzQ5TVpLb2pYc1hkRE1BRzErQ0swa3JETVB5R3JZcTZ3ZTNzeFA5UzYrTU5zbldvelZGOWY4cUgzK2NZZDd1KzdlV2hRaGl4ZEdiemgvQU5BTlhia2JLRDhvVUdzcUJJeUVrL0tHdkgraDM5OHVtcjBycy9wb0cvWnhueUd4cTdsc29rRmdzNlN1Y3FFdGNaVmk0VzlBUlRHUHJDYXIzaWowWDBNZnMzcnVaQ3JnMkxuVm5SZlk1cG1tVERZdTJGV3FJRXBaOWIvRlRLNkI5UlVZRjFIT1hkek5UbXZvUjI0S2NQb2Fib0d4a3VsZDRPSWxZWDVTM05RK0RpQUMwcVFJWjI4UHg5Z3RSeDFJNWp2SnRaMmtFV0Fvc042L25qMDBiMjJwckJrU04xd29FbCtjQU4zWTlEeDVROXJRVzVjVHlzTE0xMUpWQ1ZXM2RmN083Q095UVE3QXBoMU50VXM4Z3cwL0lhdmdGMWJLZ0o3MTJmS1YzRzQ0Ty9EblF0OFp3Uy9PeWNrZnQ5UGhqYis2ZWJIeTdDQjM3NW5sclRBdUlIUDQ3OWhTS2hiMk9jZS95Q2Q5Ni9qeldSNmxyaWREMXFUK0xnM2RJMnNEOFNtcjM1OXdGaThXYkZNNlM0cC9RSFl2RHZoVC9RbjNuYy9JOWZCS1c0SjVwUHJTTDFUaE0yc3JYem5iNTQ3bjB0ZUJTUXR0SzNrYU9kMU9BcnJmc3JOMktmSml3cEJGUUZuUjZFbCtzKzdrbm9VWmZ5Mm8zenhmSXJmS3lCUC9qSEpMQnprUGpvY0dYSE0rVkRuVExrNzNrYUtZTS9YeGdBaU1XTnA5cWwxbnFYMm00TFB5a0ZWQzY4N2tGV0xuY0IrdzduRjJmMXBYTlNmOHZOdVZhV1N0eWR4ZzlSdGxBS2VORS81SHdzRmtFVHIzSzBzeUpKSzJ0dDJCOEtldkdPMlRjajFCQ3NjTjVmWUlPSFVKUHhxY1FEcmRqbVd0YXo3UWdvbFVjc2lNOU5PTENIM1Rabk05V3k1R0ZGS1N5b2lYQ1RFQlRpMmtPa3BDVWRYVEw3a0tPVTFEOXByYytqYk1mUDVCQU1ZbkxJQjFGeFZadHJ2bEhmdVFXUWpNRFo5Y2JxVjFYcWFvY2RtbzlYWDJjbFNUY3UwTkFabmVMa283bld1bG05M3k1S2d0NkZFZ0lPTjBQanV4R1FCQWtwdFRvKytwbFVDek5ZTTJOaFEyTG5XdEJwN01NK2JUcmZ5Tmg2MzVQZ0FHYUhrcmlIZHVtWTdGLzFvM3A1SnZYMGlENGVLcHhKekdRMmY2VEUxaVJWbFdiYVJZTWI3OWRpZkhZdHkzd3Q2OHgwSTh0Vmw5aXBKdWI4V3BhNXlkb3ZWZU9KYmkwQ09LbEdPbHNzU2NjN21uandIdk9UK3QxR3BSQzRJWHFmUnZjTGYwNW1uNE9YNUJJd1RsQlJabWVycFY4OUd1ZnZUSFpyVDIybmQ4dDFIazMyR2dhckM3RERWZWlBNUtFT2VrOXF6OUNYUi9YWG9rdy9DMkJYSUxtNjQ4bnFIYXVWT0VKRFZVbzZLaUk2S1N3NE9oRVhHQm1YRUJRWUZ4OGpPKzhiUVdzNmtsR09XT0JYVVBGVVBmL09XTDIzWmIwekozT0JVWS9VMFJNQTl3UWRHTGtFVWptZEtsOGx1c082ZFlhWWhURktaaVJQOXVhNkNKbmxDWkVMWHM1S3NhUFNHWmF4RHdMMTVTWmhxcWpTaGxDM3d2Nm1ZTGV4SWlIVGJqRkNHUnlCOG5UMTkwTWhwMGphNWVvQjB1d2dvWWxucnpKeXFwcGNzdm82QXpGWm1Ualp2dW5GTHBSWHMvVXI0MFBhMm9IQmJpNys2RUp2MzRBUi92LzhzZjlienZoYldkZTY1K1RZMVVJREtQMTVVdjE1RkhkazNNOHZ0M01TT05sRnhaeHM1aG01MTQ2dWJpaEhHMXRmeDJKZng3cjNkNVp1WG45aHQvci9WNi9qaHlvd2NrNTlqVGQ5cU44dkxKbUNhSFZKcWVjM0xPR1VHK1gzeGhoNk93ZWhNYzVPdmtFZWNLUi90TVZjbldkN29ZeUtmTWJxM1dxSHNodFBUZUo4UEFuUlNFUmNsTGNQTVRyWVUwZExWK2VEN25sYWczdHpsbTJHcElCTGNydHVwRHFCakpZTmcwUEcyKzlwQVJhaWhMVFJVL3F1R0I5WlJ4aVdEcXJlQnJvVG9yWHJCdzQvNEM3L1RYSVBpcTRKTWl4R0ZXWUVIRTA2dzA3ODBGR3I3ZzFKTi9FVWRYUEMyYU5hdzh0YnV1eGZvUkpneWFCZFIwcFFYWDVTUWcwOVhDYXNKdmRLbUVzazIrSFV4MlEwRjE1ZU82c1ZJUFdteEZLTnFzS3RQVVROdHpuNExGaFhmTFdaWWFWMmdJbDladFlHZ0o2Ui9QQ3p2MnQ1eTNoYUJZVk9BZFhEbkJXM01oRkg2bHpyR256d1BZN3BQUjRWZ0RTQ3FNMmFqY0lNYmdEL3hOOSt1MWRvMnR1YmxwMUh2c2N3d0FUQUdjWFFJM2ZkdGdwZjNkVzJYMWlVODhrbWhJTlE5VEdCWHJleC9VcnRFK29RQnBnVTRUcXdabnB2Nk9EdjA2Vlg0U3pMb1orQm1HTUV5Zi8zN1VzaVlvdEgraFIrU3kvMUViV3VxL3I1Lzc3ZE1RWlFSMW50NjhFTkR0UG9XbFppLzNSNnNrWk1VWmdtUVNHVFRlNjdYZGdPc0VoN0NEdlM4U0dibTh3UnI2dzlnb01tbnFLMnJlVHdDcUtwOHF0cVI2eXNrNEdzdW51RnphMi9uL0V0T1gwS2hCSUViSmc4LzlkQjArSm1hRzdzT0syYW1XMGYyMkgveGhtSlFMdmFSdHhPc2oxalpnanhLa0xGSm5yYlV1R0tzanBQem12SitzWlN2TTFMVVNZNm4vUWovdVJYenJrbUtaMzdIeS9GZENhSGxFdHFsWkZhT051T2lJeTJJVjFxeVNYbUV1bFM2QTVxY1AwMjJMWmQ0YWQ1ZElnTzVYSUwxYTE2QVA0d2NLNldNa3N3cXJSU0YrbUVoQzhkekpRa2lkTjZ5YjE2V042MDlPQkROTnd1MWR0QUxWck5UOFl0Rmc4ekt2RFMxM0JXclRacG9VTjk4Y2hlS2xsYitnd3Y5allobzhYYzBHU1VhekJBSzY5SWM0aHVzVlYxUVhyNU90dWQ1UUU4Vk1HUEZkU2NCb1FEbWxwZnUxdGhvUjdDbk9ZUWlCUkVTZ2tTc05FalBITVcrYTVVb256d0tjQlFHVXhSVlo2YjI3Nk9WbHlnQ2FlZnpDWlMxK1VROXVUVWYyMk5Yb016S2FJNTZJQkhEVXB4cWpUdXlxWHk4YWNDL2RjbWsxNnJMQzd1bjFxU0dxZWVUT0JoVWlvM3o3QitCSjRVNUlvTllJSWNGaHhUdmJIZGg2aHpBSm83Uzd1VHo3MlAzSDdRVi9CQWtic0RjbUZsbkI5dThGMEM2LzRXdmJEMlhPZFRVdzlaVFcxNUpsK2labFFWMUhhbk8rT041c3FSUXNtYW9aZEFad05xS1BWZmE0TlgzcGtvK3o5QXNtMGFGZFFlNjdheEkvK1BhQ21IY3JSYUkzNDArYnRhZjZwVHlOZUFocDhJdE1oM2tkVzBWcWVMVHNGTFV4Y2JnSXhVZ0RUSlZyVGRYNHoxb1ZXdEE4cXlyWjFnUFNjcHEwa3YvOTN1NlNDbXBSdGNtQnlmejJZNTg2aTVKeTliZWE4OHFzYVgwc3ZkZ3ZKQ3pUejJJd2dPT1NXdHM4THp4K1UvWk0vOVkxdzJsNjBkMFoxZEdPbkl6SytoVUJVK0JyaHdPUzI0RmxVWXVmZjVHa2xyKzZyeU43YmZGYThxTTRWTkZHV1BNRzVoMHR6WW9HMXdqMjErVi9Ma3gwZEY5bzYxWmFaWENRMDlsR2hLWmNpbkxFZXR3QUEzWFIxOW9WUytuclBiTTN6TytXdDZ4MklIc3F1cWZaYXhIRHRWTngrRXRWMjlXQkJ0QzVxRE10SCtwSy9aaWVGbDRiTzNaandmZ0dYTWR3RWk3VkNFWnYyT3UvZ0g1VzJIckVzSzdBUG5PdFBIMXl3eG5QT1ExSm1HMHNsRGdiRXZGc2V2L09WZlNIRjYzZThWK0JwMUJoVDdPUlg3Ukx4d0p0WFpTWTlGdDN6NHk1SVVwUlhBUHBOR2ovTnBQNVdQVFc5L1k5NytCY2llTE1iZGw1Ym91YWNjZG1yOUlvOFVSRW9LQW9Fb1NaMnEwTEFLeDlQeWlZVHE0T3JnbWpmblg3c1FyeUxaZnRZY0EvMzA0UTZySm0xVHZEUnlRbkp4S0xoZ3BMUFNKY0VpM3FmRldVZ0Ira0QwUHNBdks2dm84a0RrUGlEQUU5OHBuU2NtbDg2Q2RMbU95cVhrcEpJcHNPTytvcDZQcnA0UFh4ZXRPSW5IeVNxN3kvU24vV29QOSsyM1RaQXNIYWpad3FNekhYdFh3V1hoaGFIaGlPN001QzJFcDQrYVB3UjEzdGVIcUV1L05ZblozeWVDNGh2Qk4zWjFOMHJWOWJTL2ZLZlhULzNWSGVFN0RTZFpJamV0YnNlVGdYSDZDZUNXMGJQam8rSEZHbjNEZTJKazFyRDVPNzJ2MzZSYnUyemlKVXQ2UDRFN2g0aTUvOXB1UDdPMHEzbEprbFpycXluT3VXaFR1dEgwNDg3Uk1oTjNkQXhUckRud1dqUGxhQlJseEVkUHY2Zms3d0ltWmxwVTlwY2tzZWpYRWlZdWVpSEU5enRJV0dibEhwdU9qQ3FjcFJlWHpFWmlpcWJ2S210TDk2WCthZ3YzUTdFRW5jcFZtTm0wUTlzV1luMVpmYjVrWWlLNkcyeEU3b3pkTzkwdlgyVzc2RFpCRXJRQm5nK05iLytRKzdyTWRLekJSbVRwdEVnREdmVTY0RDdiUVo2ZEZqcndCSGlkWExBL0ZlWTd2QXJ1T1UweHAyeTBFZEpjSWh5S0dUUnBuUjFIWEQ4UFZsTzBuRWt3aTlYOStlSjZNOE0yN2xCeDc2K05vNy96bWtVbWp3enNhdWcralcyaFdTUjVEaHlOLytReEw3SUhRb1ZCL3hFakROdnJzOHFkZjUzaTk1OS9aUUlLWll0QzR4SlNNcWRiWTRKTHNIWk5YVFkrMWdkVlZUSjdKK2E4TTdmNkIvUU5PZFJkZkt3bFN0ZUs2T01MRFVaU2NMTC81RjI5d3VIbWdVNytOZ2hQZHdlRVY1ZGZrMWp3cUU4N1NDRE0yS3ZHbUl0M2pWVWJIODZRNitUMDBXKzd3M1kxYWVocTZ5VlRsbUdpS3J2dnJvTDZDeFUrUzJieVZOZk9sbWJrQmowcmQ3MStwR0lMWW04MXlscnlEYkFpNUk2MHBhZEkvQjJBQjEySFdwTWN2VkhwYmNXckRRUld0N2ZJZjdLN3YyZDhtM1ZaUzZxQ3hkbmNOOUNNbmhZTW90M2FhRE5EMVpxU1dtam0wMHRyVEJRbVQ2TU50Y2oyeUhGZTl2OStTZC9iZzNDNE0vOUhXdG92T2t1TDk1ZzhZcDdXT0hmYUtzNzJRRDdQelMxN3Y1MUV4VkY5YWlWS2M1SHcrMDlIRFY3Z2UzUjNMTTNOLzdaVU5PbHpUd2QraVdPSExhKzA0eVpIQ1BmTCtocTAvZXFkUnZzUjNJaktJTW04NzVySzZwc2FPeVlDcitQVzM5VGFVZmZOSGR3RVhIT0grSXZzVGFLZ3NESHFjSTd5SDRvVklMZVpOeGZpYWcrWG5LY0hiZEEwWVZXVndRUHFrWUhOT3ZIOXR4eExLNWpJTXBOS1hUY3FhN1EwbTZ2ZTVYL3pIRnQyc2VJRDZjNXA3VTUrVmFKMzFIWlpEUE44K29PN3UySlh2Vk16YkVFSy9paFM4Qkcza1d5bmRxWHFzem51TW9DOHlieU5wRUVYTXJIRERVV0xzUlIyUzlma1Z0ek9aYVEzRmVBelI0MXlaNEg0bW5sLytTUmFYUHZwZUhRZ2xtSjRzYzZBSFgreHhsRkxzQ21QbGR6V1Qzanh5Wm5ZU1hqYWgwQmtEU3RZSjYxajluNzJqRldDV0hMck5TNFBZbHQvVzVJQUpJMGQxN3E4MnR3dXdieGRLQ3VUWElEMjZZaW0vMHNGMkFpTE16K1hsMmF1a0J3WlNQeDdKMGFFL1BlOUcxbXRVQVNiNjFnelYzUEQveEUxY1YzVlkyRnJiTTIveU5yWTNmRjlCUjhQQWJGbmd0ZUp4WHBSdWRFdWxZUDJpckJORVZtcGNjYnpwV1FQUVNEZVE5TEcwUStJNTFTbTRHSDd5RHNwRTNaWGRuR1VwVlBpNzRuZjh4NFR0MThhV1ZrWW5qaENzcTdrTDJZZ3FvZkN2ajJnUnJxUDZwZHd2UjNVanUydDh3eEpYWU1rWi9tTGowaE1ieFFVNFlvK2wvU2Q3T1ZVejMxd2RoYWVKZUZJOUVMQzRaV3p2bllaRE9yT3NWWVhxQXZidUczV2JFWTAzMW1mYUt1NDFSdzRaeEkzS1p2WmFPMkxQRUZzbnBYS210R1FJSFlvTmVVMjRURXg4UWhQVXBqTndNSG5XQmc3aFdzVVBEeFd6M3VveitMcm1keGdVYnVwZ252ZlNDR1JKNWY2SW1JYUxqYkIvYkhCTlp6cGs2VTlEc2w2WTc3ODBTTStRVGlveThPUkx0Rkd0c0ozdzhlR0hySk5YeGRzT29yS3Nob0JJZzlmWHpKaWhYdklrZnYzcWQ4cEt1TE41R2VuODFkT2gvYi9JQ0ptTUlHZk1GalVIZStuZjBnSC9SY2EzMm5ONFUvanAxZWRIRG01YUdSM1hZVStrMGdJQkRnUDhIMWQ1VG5DREVURWIyOE9tNGxtUHlNSlExZ1pvTTFWOWY5ZlBWWEpNLzVkeWt2TGdmT1hpZ0t3aFRwanJBNHVYaVpGdG90SFZQWS9MQlpiZEE5NXBIb1Jkcmg2WHUzZnhsVHVCdUFmaEpoeXpOWktHQUFnZys3aGNRQ2xjQVN3T1ROZ0N4cGtxVkNKUUZqNE42NXlIc3YwQXNqeFRjRXo4ZFQxaktXaytDUnZLY2ducWtWekRJS085QWdyNWp3T2NHak5oTDhDbzh3L0NlT21tVld3Witac0lYaWJHd1YzeFU5QXF2R1RaMFBCcy8yRDNzalByaGovbWNjS1NZZHBMNFR1b09PUUlzcldLMW9yNlR3SFF0UGY4L1RLMFhpOFgrN1BUdmZ4bVhSYjlKNzRRdkF5YlRrUFhra0pYKzg2VERQdndURXZ0WDd1M0lqTU8yRDFMK2NVQVpVY2VRRDUzTEtwWExtQmJjb0IwS0tPQk5rdFVPWmoraVRBTTBRRndHWndubkNpTXg1Q2pETWRxV3FPRlV4YnVtekFUQW0yWlV0Sm84YitGNXV4M2NxejVVYjE4eXdJeUdyaUdSKzVBeFhzVnNCbnVrUndUK1RrWFI3UE42Y2d2bisvaUp3bGlFNTQ3QW1XQkpNa3J0MWxKcmJKOEhzYURQSWw2MjdtaTYxSktEeHdFZXdDbTFvV2YyVE5zdVpaaTZ4bHhtcVhoRW44dGtRK3NTS2Y4RlUrN2srZFJPWG1QeklOQ2YvbjBqNzZSa2dDd0d6c0tRQTA3d0FrZENYSDVvQ3k1MWwvdHMxR3J3S0J3cnUyT1VGaTM2My9DVEJaU0xQVWhkYnFpbzRuTkMxQkgrWjhvQjl6Q3l2NFM4aVlqYVpJVysxVGxIWmRpWDBLemZVdW45VGlHS2tXakg0Q2NrNDdIcXF6T0Y0WGVOWlZoT1U4VXVXNFlQd2wyRUp0b0J3SW14NDdSdG9FdzY3bXJMR05WR2pCTWJURzBuaEc0b1BScHlQbnZCWkNGRElUMGIzTE5UakdNUW4vUzBHZE8wMzBtWUc1K2h2aTk5MGN3MTd4QW1mOGlVam9SbVRiQVNLbjRNRG5pZjF1ekkxbDhOMVhLYkJSRVVac3hGbzMraTJNR0lxVUtqUWJLUFNNZUpIb0dLUHAwcm01ZUJ6QzJYR1ZNSk94aTVnWXFwbHhnT2NFckJCV0RLb2dhOGhQeGFDdmdLNWNWZTNnYkZHeWNuS2tTaGRZQXFEczQycTNGT2JaZGRZQTZDMUZuNWNEKy9GdDE2V2p6djlIR2YrVnlYTGhDZFk4U1JMaTkwanlZSjZJcDJDVFgwc2dHRm9DVlVJbHN2Q3NENFhPR25HZW5Rb0xybktKSm5jWGRFNEFsaTJUWEM4aHUwZ09sSVR0bWdLbk1sazVPWlRLQmYveEpXSFhwVkdIaFJYTDY4aW9TWGNLdUtjUUR6bHdYZzVtaXZ2eTVJeTNKeFdDaDBvZG5SZEozM1hhWE9rS291dGlIVHBkbnFpY01mbmw0ZEFHQVBoK2VQbzEva25VN2Q1ekVQOGRGeWNVeXFJbzg4MEpBRkxIZmZxb0xCMldWNmhRdHFrV1JiUnVUSTRVYWRtRkg1SU1LMTM0TDBlN2xyV1dxNlRBeXJWQ2prYlpsTUpVU3NFZy9uTDBFS0RpZWpnRjQ4M1FCSUk1R3JjbjhpMWczem5rMy9hK1V1aExGWktLTmdyd25BdDJIYnhYMWlHbE1pVXJyMW5LNGtwTlRwS05pNXhnN1RoK0dHd1RldGFoc1lYazVVTjBGUi9vSnl3bHkyRnBzUVlKbHhkTHhlbzB3MEVLUjZKT00vR2JEamVrNnJUc2JZbGdpNnhNS1IxR0FaN2VWZUErU0VIMW5oVDdkdlVEY05CR3grK09KYlRaaFFFRTFlQzZqbmlYQWpuQ0l6dGZSUUtONGhQMCtUTmFBdStmaFYxTkFBNkdaeExKOWk1WjlqaGY5NjR0cVQxY1NnMDFhR0oyVWVqRFpBdTA5cmxObU5CdkJBNTNpWWtZd1IzaXlqZlFUN2haVlZwWjhwU2RxeGpPWVZTdWRFWXlnMDRYd0pHWEsrSVNTMS9Zak1tYzB4cFArVnlvbXJJN0xRRExya3RwRGtrVXJJM0tjdkJxWjYzcGkvVEd6dlVVS1Exc1BxaS9LdlJTcFZReHQvZm5wajdEUFRMZXlOVU4xS1BTMDBNZmxjZnV4M2VzZDR3QUIzL3ptRGNqZ0VsR2ZPL0MyRUNQekhXY0ZmK016TGJkaFVRUXBES2M3eDE0Ry9BTGpBWnZZemNaVWN1M1JwMW5SRFR3VHFuQmNscHVMKzFUOVdEMGk3Q3JDSEVwdHdia25FUEgxMDhCd1RrRU9QaWJUOEJWUjkySDdHVXRKM0MyZmppYWxlVElYR1BTa2x5NTRDSW1kMTNDT292RTBJU2t4bnluTGRueXdnR01pZlBzQms1VjZvRWNtS2VkYXpnRFhPRDhWQWlrT08vakFlMFczKzRQTUlWZVpFZ3RqTkdERzFFNUJFOUFWQlc4NzR4SXB2NTRnamU1aGtOWHR4NHdFcEgrUEZhMllLVytXbWNaNlNPM3BRcjNYVEFwOW40K0tzYnhlZnVSN3FSR0c0VERLSTU0cjUwcUN2NEpJSmZ6RHpzcG84V1NKRGY0OEREZGlCSXkwZzA5czhPa053WmRVNis2OFlpTm02QU5BcnlQei9vZTk1UUxydFJENGduc3JDdXU2WHJ6d1JEZUp0Q2hINDRrNStWNkk4S3VoL2N1djF6VEdaMmsrNVFYdGdud2M2NWNzYXRiK01USGNNTGdwQUZCSDZROERTY3dSZm0wNEFEa29MTytFSFJvTHhpSXdkWVYwUnpBRUlhWWdyNTAwZjZrRlNWWnYvMHNHclVsNFV6S1pxT25yN0xVeTVXblFKRmlKVXBWcXF0YURzTHFGV3Q5RjhmdThxbXk0eThSQmRZNC9pUng5S1pCb3RMNTF1Y2lVTCtid3JNbXNYZ1ZoOUdtcGtMc2hIZjk2TGZzTXFFem9vZW9selB0dUtSK1BOcUM0dDZWRWp1c1VCTUlyeTJxRlliOHpJWTR5cEhJQndXeWFQTFVOdGRONUtFdnZvQ3M2WURLS0hNVXB1M3RrSXR2c2JTZm9UUFdRdXN5aFU0V2JmbUk5UGhXRnh5SnM0Q1p0ZGUzWkJMYmNONENPQTY5YTY1c3kwRGZzMWhMczA1eEUxZ3F2WGVDanZZNk01TUpVeDNUZFdFcmRXSEtkYTR2T1Zjd0VuTEdCMkVGc1VRZUJDNVQ4REgxMElQYzI3U3g5cVlaZlhxN3dkeG43djZOZGJJSUxUZzZPdHhRTE8rcEJKbzRvRzN0SUNMTllLRFV0ZGRsc1NEZTBSQS9aTitOREQ5NUhCelpSQ3MrODJ2UkxrTXFQcGtOVFFCbzdFWlNxaXliZm9xbHFDY3UwN0wxaUR6YUY1L1JSSm9GRXRwUGZRbFdsU2x6d2ZjRHA2VVlheERJK3hVWDI5VWh6dXB3WVpuQ2lSWE8vdkxyNVVLVEVteDNzbkQzY0hQNTV5NGZVRjdGOWFjV0YxaFNmS09uQ3c0cERKWlYydXZYTmt1UTROVU9MQ3B0THRrbmZYSzA0OUlXdzg3VlFjM3FNR0dab3NFSzhvdk5aUkF6UHF5QWtlU3hvT2ZLQWgwbExyakpLU2U3V2o4MTFHbldvS1ZJUHpYY0RTT0hRRzVaTXZkQlFTWkFtazB3RXRNYjR5RnZPTk4vaHFRYmg0TGZWVmNWWjY4aHRyOExSakhWalAwT205ZWZKQUw1azREQ29QSlJlQ2R2SVFadnRjSkRQNGQ0SWNsc2xuS3Y4OGZ0Q1c4VXVleDZueTN5aEEvS1ZIWjl6bmwrNkx0L1Ezakw5K3pMNTJ3eFRQd0RTVHhnV0gvdXF0Qm5FWDhNbVU2RDdvZjRIVmM5NlRkNlhnU3d0SGovbjE5WURwUDloaGNrSDNHTDhzMnhEbW1MSnJtOFNLaW1kcDBTSVFlcG5tYlg4aFFJOWwwNVBLZzBNZktlcFRTOXdzMXJiNzhYVkpPek5ncTFQd3VweVZrZkNyVy82TEFtUTEvR29lOCt5a3hkMWdkRHA4UFZxeEx2SFBRTEplaER4a242dS9jZGhjUXJ5aWVlakVDb1FldVBFR3crVkNRNjltcHNrVWdwbXVqSUlxelZaYUhwMlNEQzJzWGNORDNySUt3MXBLYnAyVERDSHV5ajZCUlpCMkh0Wmc1Qm9nZDBCcUY0dXhTNkwwdXBDdnBrdXM2RXJqUCtyeDRsNGhqaUNsVHNnRXF6bU8ybktlaXp3c1Nhb1JoVjJlNzRMZUdjQ2UrSU9Ra0FtTHQ5S1c5d1lDdmhrV3E1OXByY3BRWWRNYjd4ZFNhdk91UHFFNDhTTUtZKzhTaTB4TitWWmlMdldVcHp4cTgzRnQrTTBmQ3cxUUJFd0JYTktoTFZhRUlFUEU0c2hRcUw2SlpJckV6anBnQ1ErTTB0ekZxYkRmRmF0ckF4a2lUeTladHlVNllkNTlycXNVempYOXJBTDdyRDhFeWJobHpiVlB5ZUM0K1pONVh3VkFPTjJTVU1kMGI4bG9EN3Y3S09BUVdmbDJKdUIySU9IR014VHNVcmhnbDFtRFJNNWo5UmRhUFZKNFJPS3F3VThnWGtlTVZTL0NDUDBUL1gyNnZISVZWV0xyQXk4UStGV2djRkVqa0swUHFRc1QzNUR2WmNuRFcyQ0kyeUlYb1VUNUZ3UkxOY09zMDRpWEF4a1JZbWxLQktCaThzU2xLWkJKdkM4bUhUcDV0d3hQSVVFbmswSlU1V0FmajZla0V1VE1FRk1XbU1KZ2V0TmRkSUdYSG0ra0hZVHUrU0hGaFB3ZVZJbFAyZmRrbUdKUk41OVdpLzF5bU5vNkdQbWVRSzBmQUdIVWRkbmJvUnFrT0hLaldKQ05Qa2hBeGJLSGM1NTJLckNoU094eVV0TTZKMHhDS2NHMUV5K3hUSGtjb0NRT2Q3U2wzaktVUVRoaFNBK0ZKVEllK1UwV1ROSnQya1QyaWZVZ0lPMEY5SG1lUTlaV0xRMVZOVnBldzlBa0lHMk1OK3BPL3pwMkhnOVdTZXhuczdUV083cjlzckZOemNTRVB6RG5xa1FkdGRtRFczUzB4VXArNW9Dbm1GVCszdmp3bXozeG5vbHRrYXZDSVlHdXkvZStmMnJaNXUvSEIxM2NBc1hQL1hEdC9rVVEwZjJPQi9CTDJRcmsxZGNqandMUDJSWjNwd0lGN2pITllnZm9HUFNuRFJPUHFWa3c0TndtOGR3bWZ4RnZxdVJlRFZySHRoQnYyc094R1gyYjRDMW5FKy93UFllM1BVQzZjL3NOU0FCdldsL1FqUVdGOEFQNGZSNEVLOWJtN1lrRWJYdm1JYVFzTEg5TE9GV2M1d0pSdmQwNHh0QllJcUhoVUNKckVBM1F3TkJZVlBoaWRzS0E1RDNiU2RaVlhSQ2I0N3J5VC9UNWZUZ2RCZjNkWFl4ZWNHTzlZcktwVytrc3lsUzQrZW9Ja2xQWm5wYnpqdE12eGZ2ZmlqNnNCNC8vcFhYaTNmbzEwZ1hpdU1JQW9TYk90MmNROHE3UDA3NE9iNDVVd0VUK3dLLytReWN2eDBHK3ZTODU3NXZhNzgyN05JWHBCVXBvN0ljQnBUNy84a3pZNmkveHhPeXo4TXZYMlQvN20xNUVWL2tMeWJuSDFuaU4xa0RxUk53aEpPVmhwRUxXRUNCcyszdUlRM1lwbk1PbzZXN0FhMlVEWHpIZ0p3ZE1GWkNKTi81amdwM09Uc3FzdWppVU9wZ2RBTU5yNmY1d1BkOGZDY21uMUpsbE83TDgyaGFvNGtDWEpSWllXWVJoNVc1bWNwNEEwbUI1MzNwWXFuOURGM3lqbDlYak9XNys3VlV3ZmlYYm9BRXgvN2hwL2VtSjdCQ3RXOHBWalB3MDhIcit3ZHB6eHIwYTdSeWdKOVVqVWoxSncvOTlkUUtKTTVBWFlMWVc1TnNpL3FiYStkTitvS3d0c1Z4QlFrQzRjbHlJMlN2VVZpdmRmbnNBcmRmamVuRG9IWkNSUzJKZ2ZWVk5pT1FiTnh4M2FyK2IzOEpOTFphamNESVMwMXQxejA1bHNaVzBWdTk5c0tnbXk0ckRBNVcrWGJKSG9HcmIwdDlOT0IzRGFVQjlQWGtiRHRmZ0hBamVlN2Z0aVhUUjRvT0FTVTFlUjQvYTZmMjk2UjlKZlFTbDRPN2ZKUEpyRWdNYjd3YW1LS3UxVzZuLzd6VkxKdEFyZlNqaXNJa2VmK2IwcGs3Tk9HTWdQZDF5MkZYTmR4SkI2T1o1eklOLzloRWo3UG5QVnRSY0R6aG1rNXkzM2gvRTFRZlpvRCswa0lRR2dPTlBFdStORUNTaG54TzBwMjZua3phVGZCYnlhUjdyd0pyeFlBK2ZLUXRoWm9ZZjV4Z1dWZXVYZ1JPK0xtaDRkbms3UEE3MllFUVE2UDBYQjZzNUU1eVBuV2FOaFVvdmVsdVJTazg1UDRjeXY0ZGZBaDVWb1BtM2ZSY3hOcCtjV01MSmlHWjZhMUJ5ZjVkcUh6UXBGTER1dDZ5dWErWDkwcmJFdW5uQjNMQ21hYlRIY2JmT1hMMzdxSnFFM3pKNWd1cFl4bERWR1RkUjNGdERjMzNpSmU2RTQvb3d0cGRZSDljV1lsRnRpc3ZHcVhLbC90KzVaVlVuT2tXQWs3NVE1OGZMdU1pOTIzblJkdWYrL3huV2paajZDY28vRFZ3M3hJQ1pja2FuTExvMHZXZWQ1UUlNZVZ5SmN3UXIyUDlBUnhEbUJlUVZEZU1lNW9lZHh2bEZsUnlvcHlkNERqTTh2bTBvSHQxQzFwalFkNkUyQUZVd05pTGF2Rk5sakxldVlrU3ZoL1hmV3A5ZjFocTNoMzJ4SlBKenVSOWRydnhGTVFUbXRZZG9WZ0xldHFHa2k5aFZnNWlUMnN4K2ZsQ1JIL2NBNm5mcVZ1YnEybFd0bTBsbWhOWXZFNkM5ZVIrcTNjNmJVOUpRMXdyeUpPQ3l5Sys1b1FxQk5XZ1hXYXA0ejlxSkg5L1laOWM2dDdJMUxhUWJPdWRKSnNqMWxaMnFrWnp5OEpNVHRHZlVINjVEU0VCVW4zZ2lld0crSnlZRDlSRklRL3BvcXF3UGRSRlBmN21XbnQvWlg5ZjFDUW1YanVCdDdXL0xVZ3NMNk1HTi9uaU9lT3pRTCtieWdJcHZOZHRlVG0vQXVLK00yRTcxYmRQTkRNSHJMMGoxU0kyaVFzcGc1VDRQWGIwUkprY0ZSRE13TWRXZWJTYUp1d0pTNTMvWUZ2emdtVDlnQlFiNDkzWjdRNE1wYzk4NWh0TkFncytwelpTem12djc2Vk42ZGtMZVk1Szg4SnBxV2M5ZCtpMXJlUzFHK3J0NlFVQjNwdTNmL1lMcXd3eVNyV05jb0h4cFpYWW5PK0RHa1c1Mk9qM3p0K1dBNEtOUGZManZEdHdUbnkreTBhTlhGWXRuUnhXMlpHRm1jWWE4cEtCVzBJazRxTHRCQytvMUxPZTE4UnJsclBzOUt5VUZaQzNGYWQ4blMxbHJvNDYrVlc3b0xJTHhhaE1OVFlyck5DLzJ3MTN4YTQzdzhLckovaWd1UUY3QlJjWmpPbnMrRjlvbGhJWDhzakk0N3VKVysyQTkzNW1BbWZDNmxpZ1g1ZFdGZmVWZzhKNUJKVHViN0JkL2NudjZEQy9lbnRYQjdnL0lLQ0k3SEMrNlBOSlh6MFZVbS9laXhPcEtrOTVsV2NIZVJKVVM4Z3NKdTBrZFVzWDBnREk0aGJ2WnQrbS95NlVQcUkydTNqZEkzOG9SLzhFSS8wY3ZVY1Q1ZTlYU2MzQlNGbzhGNVluN09hVzBPL081aFc0RTNqMitYdGMyMHlTOHdqMmNPWDJUMW5hWE1NRjhNd0ZuaHpRYzFYRWpQSjhxMDhKK3lyR3EvNmI4aFQ2MytibkQzRnJwZ0diN09SY214enBOMkFKa2ErSXhiUlpPSzdFb1ZGdnNNc3R2dHNRY0NOc3pweU5sQVg5YjdaOFNWbytCazR5OEN1MWowcWI3emJKbllWUktURE12VTJmdWwxUkRZMU8wRXhNc2p4UFI0N3VpVXduSjBPRCs0UFE4dS9ydHlLOUIyNGQrNWpoNmNoZXJIYi9pSVFMOUlDdTdFRE9hejB0d0hZZUsyaXRuSitjd1Zyc0YwSzV1QTcyRDFDVTVDWWJiOC91U0ZKL0VCRlYyN3ZnLzU2dUlodFFTemxndzJhMVkyZlJmUkZTNFBDUWRXbWVub1MyRHErNVdvQk5oUVdmV2JCR3ZyaCtGb2RKWHk3ak9laFJFbTY1VStwYkNhWW1qTW9pNVJpdUdJVndWYUFYWkh1cEJHV0hrNVNiYVp6VkhhYmJvemd5ekpPbGVwdHV6WWR1Mmltdit6QVc5MldNcGxxSTFNTEJrV21FM3kwREN2RlE4eEZ3ZDEvZlNmUjRENXE4ZVkrczRKWFYwckh5M1lZSWQ1bFZtNkVVNi96VFFWK0xJMThCYWxhNkM2WC9BdlcwODlQbTAwM0d0bnV6SzdtNXBTTTVKczV1V1hhb3U3MHNvV0c0WG1UZDlHZmV1dHQxeTVlZUdraCt4Zk9HbFdLWHpHbEUvcGV4YityWlVJb00rcUMyNWE2WG50MVNuT3J1WUV3elFyWm1yNTNGL2ZRc0dXbDN2VDV3b1VObS9uM3ZuWmlkdkV0Zmc3d01rY1Z6MzEyQWJnbnAvZVErVDdXbmMzeWN2UDduM0R0YmdIN3V0Wk5FTUdKQzl2STJORThHbTV4T3hOd3N1dE5XNmF6TjlOU09xNEE2QkYwMG5ZUitCYkFhOUV1OHJ6bkZnQkRaOWFmNjRNMVNmWkFOc2MwdGpKaWJhTzFYdFpXelU0RDV6V3FZM1N3NFZ2ankzNStFd3RtY2lwamZISGVsV2l6SThXVWw3anZ6TVBBbHZWTklsaFhiY0lxclJCaWV1dVY2RVVqRzVpSFpadjhuR0thZzRkMlYwTXRBeGVXNE9ZNmNzT3ZreUtuY2o2Mm1IZzd0WnRFOGZjYVZ5ZXJhZXZNNmtFY2RBYTRqTHJOSkFndkNDNzY4SytQcmE0Z3VFZHE2RlVmUWxjdXVkODh4TW11U3AwT096R24wKzhmOHkvWkp5YWdUR2F5MUd3aWJtSWFyYnFYeDBqTFRac1FrRzZWemRLamwvcnNBYnFVaHhhWU5sZHFiN1U4WTVSVnhiZ3I0U2VhVmhHU2Z0ZG5wQ0JjMlNEcjZvSU1kSjJBYWdHQ08xOU1icU9mbTZ5bDYvUUxNaE1xQVBESTNlMHFDR0pleU12L2xkbndHdFBDU25mUFVjOXVhZFJLaDk3QWI0UFdFcmZnM1l2YzZFS2pjelZyUEMrYW9XYTJ0cUFqMnNaTVpGVEw0czR5VHZtbkpyQlYxZEFPMThPWHU4NGVheG1VS1B6RlRUT3dTRjA5UlRUTWs2Z1QwcER1VGdybUQxTGxldCtxajB6Y1NsSnVNSGFVYWswSy9GRk02d3VXVWVBa2xjYWt3eGhUU0x3aFRESjJ1Z3RpOUlZd3pyaitNOEgxdU5QcmE2bWd5NlpTNEUwc0o1SmZlNHgxT1h1UEdXVWI4U3RNWnJQaU90OWxEczZpYkJTdjFWd1dYcGoxSXI2VndxbjZlclM5K2VPbnZ5MUU3TnZaY1M1bXN2VnlOa2VlMVErSGIvU0ViN0xaeGN4aWhUNDYraVBKTDZicG41OWg2aXdxbDNDVnkwZTVwWEgySGdSZ3dHdGp5a3I1NnhSTW5xekRtYW1UdUdyUmhwUEJlcjVlVkJqSmJvVFpxdUhxcmdhZS9iQlpBLzJhK21SK09CeDkxdzQ3eHdJZURHNm9qMm5aQ2Q2OE1CV0dwei8vdjhGZ1FiTUdSWFVxZ3QyYndwRDdUSmRIMlNmRG5nLzF1NFM5T1hQU3FEWTBhUDVlNDlrL1BmeTMvbEY4UlVpenBHTmZRd2pzOVBsL0EwbXdpSmRrSlpndFp4aUc0UTNpTm02d3cyN0tXS3I4Y2Y4MDBzeEFqblVUSFdFMC9IOHdUeG95dWFkdk5EZ3drUGNsTThVaFVQVUJUUE5wYTJVTXFtV0ZtMnd6Wm9RUHlUMVNYaG5mQitGbFM2Q2VmSE93ZmZ1ZWpkZkU5N2p2NXJXcmpWR1FMQk5jY0NISDlEWDV5elJaVkRjeXg2MTUyMS9hTUw0eWtwYVNmdXFQREw1aDcwZHZqdEZOdmRIcW5WeWMvSTRXaUFNT3ZUZllaSTIxelUzYTVXU0hENG9jTGlyY2IvTDRSWjUyNSsxZFZLM3pYME9EdHdrTWlPYjlrQnlsZmJNQmlFWkc3OS9wU1BTSmpVUWEwaC9FdVlGbVVnc28ydGVkeDRJUTZIeEMrT3RqUm1GSWh4aFExOGVsR2hRRkZKbUFMbUpyZTRWZ3pvZWlIbXJISVFuSUw2QzlSUWlYWXhKa05Td0xWNFQ5dWFKa3hHc1JsbmJqTEF3ZHc1elZ5ZmNlaHZoTXlaUEJtL295Q3duN0pHVS9VSVYyMldLTDdReW93dmNQQVBFTUFUd0JUT2RuZURobExldGxZd25tU2ZDMk56aEsxKzZtMmpJTTBHcVRHM1pJa2U2Q3JMbC9BcEhodzZtVUEzUUhxVE1OMFJHOEFFVExDQzNhRzkzSGpjNUdpWXFlRkdUZGxvamxUNW8vUkxCYU1TSnlhME0vUW1jQWlLT0cwa3BTZVpRaC9JZ1FQUzdtNHg0SExJT1NYVWZlVWdmYit2VVB4UE5CV0JhUmVOekQzOHpMVHB0dUt0T2FqVWxvbGcybUxPbFhaTk1HTWdiNVBFaHVjZ044TVJOczloaEVHL1h1ZjQ4TTJZNHcwd0NJVzRRcHh3MFVnemdIUll6NE55M0dZbFFvdUE3V0IzdHVpbUE3K0NsQ3ZTdVdaVEYrU2Jjb1YyVFRKNVhJUHhQZkswOHcwNTkvcnZUMkFUMzhBdXVsV2V1Uktrei9sUG1lSjdLbDc5djRMUzlvRjEwVVRUOVBlMUhHUHljaklnOTRVNnA1U1djOU5hMDRVMlRjVWJVSW9OYjlXSzRvQkVBUDlTaXlkdElnUVVJOEMvNHB4bHNPRkwzTkNFSVVONDNHMHpJeXBzWk9qdHpQMFVRWjVjRG9zSUI2YXVtbVBxbk03VzI2VlFwTlovVXd1VU1LczhTa1ZZbjl4U3Z5bDlXeWhQaXBmSWp1cDhlajFyaDB1UzRoSU5oT0dRc28reDlXeEJjbDVGa2xZZm8zaGZOb3p6eXBFd3IvNG00ZjNRU0pEQm1OVVdYQmM5TWZpbm9CYlRTQmlRRHRmL0ErN0hJTkJydzFDVi9CeitHUFlPQUROMDE1eHZ2K2J4K1hOOTdiV0Z0dHRuYldmZVorN0g3ckxBSnFoZEZ0QjJJdmhwV0FCTnpBOWpnc0VCUEVBMm9xdm01dXhXVnA0YXpCSFNza1NPNkFNNlh1eEV6VmJudE84OWF6VDBndFpHbUhGRE5aZ0NJeXFHeXVKUWxJTlZlbDVIRUhzdEZpckVhNzZGWVJzM2xpN3ZjbHhOZUtEVG13bzFXNGh6YXdTNkZEaUl3d3RQaDRGY0hOeVZFeXZMWVlpVXNOb29TRFRwWGF4NFpuejN5bWsvZjFIWmZhaWhFdllZRTJNclo0WlROeHBSMHFyeXFuMUNTMlpTMFBpQkE1RW96VEtBTFFkZzEySnlHSGtQR2swYUEzUHNtYk11WDhBYTJMWi9oVWQvR2d5SVZKYVA2WmUzSldmUVkvaHQrQ0F2N3hHMXh3WDdxZnVUKzRLUkZ1bk8rUTBncEZYTEJtUHRoTk5EWnNGQlVNUW1ON3FjeHJ1RVVKUmZydlFPWXh4VEw5MkVkbWlEVXluOWJ4WUlxeDJXVlFIalU2ZTU1eDdGd0k5djBSNFlIUUwwMlFiNm8rMUh1VTBLQitoL3J1VXZGM3ZOWkZodldKZFl3UVFnQk4zSTh3RDBRTE40N2FncUdWRjBEMUNVeHM2ZlkwWS9GNzVWNkVuU1JSWnlXbXF0emVUSm5SWXl0ZGFuL1dWRlRyQ2FJd2xmY0x3V3BFSkhZWXl6SWdKbHdVOEFZMVViTjltYWd4ZG9ralFXSVJ2NldjN2xxeXRHWHBrT0pOS0NlU3lNZEt2REVDVVdmVVoxRWQrVXUzektFMXFvUk9MRFJlU1lCbmZaZnhCRGpMRm1IMHhxbkphQTlDY00xU21rSEtDa3FMTmxlSGtUWlVXdU0wSTEvbWFGWk00RFJNbkJmY0l0KzNKY2swcnR4QjhQT01MbzF2SXQyTW4rSVVhS1hBOU5obzBJVnVHKzJscnFyV0V2R3FVVzJvb0N0cXNuT0crT0xOSE05T1ZhR2ZRUWpCQ1hjSWxoU2R5bndQOFVzb3lVTFdudUpzcFVsaCtkUTBmR3BhN2I2LytHL1gwdWt1eCszTnZ6ZkFidjg2ejJObzRvb1Jkc1BYRG5landXSll2TUhlOVB6U05ObXdCd0taSHJJR1hwdm1EK3VlRXFFS2FlWmlMM1FFbHJqWnlkTGlXbW9sTlNCaW1kdUZERFRlNW9rdUlOVm1rVVpWVmFaNUEwL1BzeExyM01UaHBxZHltWVlTcGJVVWlhaEsvSWhvM2UvdmNteXRZbUZSMWxZd2k3WUtPMEcxWWJJekdMbW95SmNnQ1hGRksvUzloOERjL3RDR0dZYnE5am9QT2lPSGFJZ0tUSmhFM0NqQkNja2xWd21KWTg5SklCQ3pmUFQxdFJUQXBIMDY5M1RFRUFhczJNZ1VCWFN4MkRrdVpVK0JWYTJPdTAvUUhNSFkyUllVT2Z1R1dnSmJsZWpYWFVBTTNCaStzUDAzdXQ3dkFQZ2h1cXA3NUN3MHRGSmJHNmZKWUdEWXdPN2l4K1JXenFaeC9uTXNDUWpUK3oyWWNvM2k4dWhXMGs2RWVCdldBQmhvVkN5NkdIR3Q1eEZyaGpmWTJUamtySjFnb0ZGb3ZEY3lYOUQ3em43ZXNHdENtTVBVMFpJb3M0MU84V3VITFJaWUNIQi9YckNQRkdvb1RQd2FOUFBXRDF6dmNEb3hlcGt4QmV2NkF5ZmlZY0xSdjRWMWNhbHdFWWtLSmNHb3E1TitIbXNpVUlxY084SVBON0xBbFlPRHhtWVUyQVB3WUdnS0lYNzRKS0NmUlZOb2NqTXpBb29FNVB0d3lpc1pyaW1rS3c0Rk1JaUdBS1FNV2ZaMDhQRE13K25QWWFCLzc5Nnp2UGwzSUprbmYrTWpNMGRFSmNhVkVYTStyZkoyenhlc2ROVllVdWp5U0xDazdvNHgzR252OWhwZmZIZUI4WUc1cEdjZ1FXRXRPV1RFM0VYU2l0M0dMb2RYZnRhREE1QWJjZkJXMlhnN3ZHMHpmQnU4dlUxZWVJTWovMFhlUzRrTTZDZGYvZ0g5Tm5DakZUbW5UN0dJYmdjeHZWSFZ5L3pQZWV0dHJVckE3ZnhCR2Z5VjYrTklqc0szeUhQaVdWYXZVd3FvWmxoZG9wbTJ1a0I1bVpOdmlrWHI4a0hhRjA2andROGlGaUppa1c5Q3ZYMmpncmNqdzEvRFZMc2dMOHlnZWhMcnAvV3oxc1hidTJ0aWd4SEM1cTF3R0d6MnZKazNUTjhybHpkQVlmMzV3ZWZqTmJXY091NC8vNUMxMTVsMUprR3kraVBjT1VMSzloaXlSd1BQVlJMNytaU01UUFdRbHFlOG5HMVZVYmw0T2lvc2lxWEo2dmQ2azczcU1lcEJPUkhSTFR1RU05Q2RZaFd5WDgzNkN1NHlpZURBbkMyNjNuSFdvSU5QeUJKWTBLMk92Zi9tOHhIRTVrREN2UWptOWtMY1d4ZEpZZUFPQ3RVcVhUL290YWJDWXN4NE1ucDk1UnJmaXdtUGdmb056SHpqTjBNQVRhZDM1eVkwRzcwV0hjSW9Pem9NaTBJQU16WUwxamNpZWZTMzRLSzRxY2U3SUJISzdSQ1hoOE5JY3RWRjg1eGJheldzQ3JZZisxZjRwQmNOQTBnN3o0MTZaUERRUGdmeWI5eU1hSWZ1SERpQmVMdEFZb0htZDZTM0VZVmZDNExFQjNScFgxWmtKdmx2bk1ONWdpSTZRZUdRQnBNNDQzd0g4R3R3VTBKS290MHdmeFI5aGhhNlVmdTdSSzI4Q0RkL3dhVG5CdWVoWng2WVk1K1FhNVdYMFZRbHNRRmpiY0ZlUkdYY0F6bWozTmN3UnFoVUlnVWFpdDVmTTJwYzZldEplNWJjK0txanp0ZkdMTi9JelVBUHdUUFNxTEFGcXUxSjNlMStob0hiUlhiSEVSS1pTSzlaRU8zV1I3SXB0cmc3Wlg2NGpiM3F6SHVLa3lIU20vb2VManN4b05peFFVNzJMQzNBUEVjNDBuNmpHdDN5MTlvUGVCdU9WNDVSOUpuR2VHZEVWSmJkUGxzWitVdTJkTUNxRVI5VEVpWjVkNlQ2dUhQNGNmM2o4bU5CelNOQzMrWEhONk5yRGpVOTU2R2J2ZTF4SlI1ZlFYekNrWjJ4OU03Ky9vNGZtN0tvaVQ4dE9tYWVVQTJkc0Qza0JxREZ3c2c1R3FTd3JVeC9WTGdtMlFwL0RLc1hORFRiTjZld3IxMmllUFNCcnl5cEtzMWp6Y3llWlVoNXQycTNmV2puMXh4djEyY281b09QNmovUnFiQ2pKVUsyZTN3SWNQNHlTN0k1UmowazNiNkhvYnErVjc1eUp1VS9WZmtETG1JNW1mc2pFcG5WVVlXcHZMY2dRdmhKQmxIRVQ4ZElkcFZobnZwQnNZVGFhTUlWN05qN1dMb29xbWFqWGhjbmpvVXp3djRpVGp4eFFDNThjVWt2bkxVTytOVk80WWcwT0hkV0dyZndHSlh0WnRCZEFvcGphc2txN1VxS1dZeDZDV1plYy82UWYwNkFlWFNWR3U0YUk1b0JoZkluZzRkVU5uS2JZRitnT0dsZzZ5cXk5ZGdocjZQeVRUdVd4TlZRdDNYQUpteWFRd1M2enBNMVBPa1Z1dHdEV3RSeGUvTk5GdWRGRjhucHZXM1JHL0tld3NBZHNrcFhnY3d6VXJ6dDU3K005dnkxOXM1c01PckJXanpXVUtHRXU1bHZ2ajJtYjhqNmtMblc4OVhDOVJhcEZkUk9JeTg2T2lKVmN4Ry9DQlhvVG40TUJmTzZ0bkhNQ0FIa0RLNHNaUFRTQTBvQ0Z1K2pZcis2UDdpcXpDUFA2ZFNZeEtFMFJRK2NWdE5qRUx5T1BBZGpubzUyVE1JNm9MZ3BKb0xQOEpVSkJ3OWwzRklieFRkNUdvU1luQjNObVZBN1hKMkdCV1FNQUxqQitId3dtenlZVjNPZTJUdEoyQXBWVDRPMGhkZUtOVzhSc1hEZ2xyWWhsSDJHY1dsdUdNcGR3dkEvR0VsM1pqMzRvc0ZZWUVxaWF1K1dXTW8xMkM0b0s4SkNTNHpVczdtSXhUdzV2V0VZNTFnbG13dTh6NlZwZ0NrWUVlZGlZcWJMQzBZaDlRRWYzWmtJd2dtOURCS1VRUkVvTTVJa2luWU55OE9uNVBQb0x5S0VsNFJTMFJwekZJR3k2VmJHTnFWaUlEQVBjKzAwRWttdlZ1UTZBU1BFOTNRTGdCaUdEaHRNeEFwWUs2M1F4NW04OUVub0tBZHZCOVdnaGovT2JuYVg5MFppODlGNE5qT282eGdmelR5aGdIRWUxUnhPSGltU1hCTDRIRG5oRUtGaEtTcElzUE4rbkhzYjZSRk5vMHYwZUhralMyajFuaFFtL2lFRGMzNTZBVmpLSWFjSUxjbGE5R2dpTTF4Sm9qdVNCYU85YnVBRm9lMkNlOUxObC9ubVE5TmhjUVloeFdVcmZPcEYrRjJ3RjZ0UHI4VXROU3hvT0xoSFNic1E1YjlWSUg0ZkY1a1lIYWZsRUVHM2kvNkVoazZBOXpreGNxZU1oMUFaallzNVoxbU4vUFlWeHhtUmNDai9sMml6UDh0UjVaSkhnVFJJbXpyOEduRVRZb0lXOEhuazYvOTQvdlZ5d1V2SVZIcEtrWElLNG9Sc1BrT1kxUVp4TndyakxMYmhDWnh5enFCMW9YM1UrMnNnay9LbFlYYzNrQVJFUTdRWGpqY21RanZKZUlPR1Z0TlkrQXM4cmtvaE1RbFlqS1E5azFGZ1RMUDY3RzIzanNTY2lHQ2N1eGlJTHkvckdyTDUyNnFVcWRqYVUvbmtNMTN6VzlxckE3YllDdW9nZzhzT3ZZcjRtUUV5dDRjYmhic3phM09ucHNNV0prenlGb1hWdVN2TU1LUGhlWWFRdVIzRXF0ekU4WXdHVHB0by85ekRUY3VwZU5xTjZPTnNIc1hqT3BMVk8rTlhKOU8rV1NvZmFJZnljUmJZNUI5d08rT1FJdDBCY2dSZ1h2VHZRS0czSUZsSVpnKzRoNEE1cWc4UjlHdkhnclFQYjZIRG5FS3VqOHFZR01wWllHUVBIRFJzZnZDR09COENYRGEyTFJ6NTQyWksyLzVCcWxoOE1GSzVsTWQ3Z1kwbXB5cG50NE5iMTRBbTdqYUlkR3crMVd3ek1UZFFMQXNNWVFnOUVFODJIRDM5TlBXM0FIblVudE0zSnJqUXduc2M4ZURFSmJnUHpiKzU3elNjYXQwdHZWZWNheDJ5NTBlQ2MvVEZqYXdjUFlIRHhuTGdGMWUwV0hoMElVNkhRWCtzSWJvRXhpQld6VkN5ODZ0M3RsNUFNczNJazdlTkxkVjRmZVo2c29Qek8vTEpsVWl1cTN6MWdHZUYrTnJlV1pEWUdHM0l0ZXJkMkVGYXZCclE0SG1aUjVjVWpBMGZlNTRqTWlCSEtHR0NzZ3VxcVlSTkVRT0lOd1ljdWd5d0lDRFlLQlRxQ2xBUEFCZW01Njl1OGhhV3hWQm5aR0ZwSUNyQm14QStMVlFCajVqSUp2UHlUWnloYXVqdzBWKzF6bnZBM2JHRDdjUitjWko3d0JzOGRrc05jdVRXR1lwMmNNWUdidGl4c0lJUVh3L0FwcW16UTg4dE1Edko5QnNQUWtxQm55QlBDbnBMZjdsSHFJZGFzQjIyRmE1d0paQUNWc1QzWFhKTXIxSWUzcjY3NEo3cmtFR2kxampPajdTd2N2T0FoOE1pQnEvVS9oaGg4YllPOElOZ1JTS3RwMG9BVnhHb0tqa0NraVdVUzBnVVpHV2xON3BSVXFoUmsySllBY0d3c203UU9OOEtuTEltOEREVS9LU2FYQzNiSG0wUXRSbTVxOHpDOFhvdjJpZmVXWTlTeFR4VUY1bUFiNW5FV1NxQjlqRVJaVkxsUDRYcVF5L1ZNa1dFdHdwUDNXZndOVHRYOEJCRi95YUFtZWtXeUorUE5IVWlWL29QcUVhTDRBRzFYTjYwbmhNQjdoTk9Gb0tlZTVCK251V0xNZUVUT2VLTWdEREpVQU5peEJiM2xUU2lIY0NlOHJkRFN4NTZnQTdPa3hTaStvSmt4VnBNOFROZXBHTENWME84d096MFFvNkpnOGs4bVBKQ2NET3VCSjR5N1pWRUdSSm1GNWtsTzVnV0xqeTRjMTdsVThyemhpRkhzNURTblcwS2tnbFh4Y3Awd3EvVGRjVm8xNEtKazJqcnJIM2dUaEVUVmN3QkpuRjhPR2NmNEhralJTWThoL1Jra3UvODJTUUdob2crMTdoaDFhZ3NKVE13TTNiZFV1dnZ4dEh6Ym8zQjduaHRxenhhV1ZDWjNuWTU5TXBPZHFQNFpWT1VmcU1JZ205dzBYeGxmbTcrYUFicTY2OTNKbjRhZnhSL0U4bWhlRCtHRktFZUxGeG1Dd0FQWVlDWXNldENWSThBZVZaUldnQVZvM0VQOG5IT00zTUJzdEdhRDJRMEVPbitObEVTb2sxcFppcFYzRUNCaGRMVGRrM2JVckpLMWpaUmZqMjVsOURoZWNLS3JWUWpDcER5Z2s3MEZDbUhFQWYzOUtLcVV5YTc0ZWVCWnArYVFYdHVTMkJYWHh1RHVXcTd5eG9Xd1E4bWZ3c0x4T2s4WUpsZWhsZXNEam0xbXVkS0l6ZHFMeW43RE1SbGZCZXdYblRiUi9ZS1EwalprSUwxb2xhNDJmMnE2NVJzWHF2N2ptd0NoTWUxTGZwSXBqRTVObmUveUszRVJYbm1iSFp6a2N0WDhOUU4rZGNIU1BvR0VxWE9JZWtacE1EbmMyQUFac3lsUHJuOUJEYVRFNU91dWpybHdWdC82Ti8yWTIrOGIvODMvNTBlckFJUEsvcFFuVlRNb3lSUFF4NFlDZ0xxRXVtYVNBekJmVFNjSGFxTUdLU0YwaWw1K2FDZHdsQ1J5b0IzM3UxQUU4djhxQmFqMi9nbUJMVWk0Z1UyV0NpZWhXemUzaTF2WWQ1eXdncWl6cWhWQTlicjlaTDl4L0pVbjJvVVgydndmU0E1OTlWRDY0KzFmQWd4RWxudlpjK3dHM1RsTmRkdXB4UmhmVUpHYjJPaEY0Zm5KQXFyZ0VoazlIblNXSXpGaXgyREMzNWxhWDB4aEtsdWt0Y1N5NkQwNkFXcWRxNEZ1Ny9nZkZYdFEzTFpMZmZyVDd2VDUwc2VkL0lYaXZoVmk5Wnh0M0RZQTBYbmJCWEVyeFdYNEVFK1J0MC9lQVRBMUZjK2RzRHA4K3FrQThEanVkZHhLRTRkQWNHaElLRFVaQmtvRzlGRFFhaDhlOE9SQ2ZweGlid1RMNThPSGp5dVg5UVN3ZjFHYXZpbW4rN21TWjArd2RjTVgzV3Z3Vk4yZnY3Nm81THVsSEh1Um5tNFhuNVZ1Zmpac1JndXFmMzBCN05lbDc3ck9EMzNPR0R5SkRlaVpWV25xOEt6c3NmMFpmZUt0Y0owVVhmcnBQc0NLZEl5aXBTaTY1R0RrZEg3UFNkdFphdCt4czZIeHFLd3pzcFhtSlZ2cG5oMVdLVS9ZYnowZ0p3OThrTnUvN3FGci9NSE5LRlpyanI0ZUZnU0lHTDJVa1FFOTJWblZ2UklJMVNOcG5ydlNQNjhxeFppV1kzTFFvMm5NUnJsWWtyTWh5TkVoWTlGS3BaM1JGUW9PNi9CWW1rbmduQmx5eTZIODJCMVBYbVB2OERpdWpLRkUvQ0pBREt4dGErTHlrMzNBNUNwNTIrdGJkeVRRZVZlaXNkUlJUL3pGdk9uZUJpeW1Zc0Z5ak1xUFNla2Y4ZVRUaitGZ0hIaTAzVUJoT3htN3NXcmpKei9EL3p0MVZpVzdIaGNNMHVQTjhKakRRa1ZweVBJNG1WV0tBb2MyMzhDb1FsZTZ2K0JucnpmbGtVWWMrbVhZdnpYKzFQZnozdVU0aklFZmJBZGJhdkhYbnpzcFV6UWgvQkdoUytZQlByNHNLUkFIYkpHZmxoaXE3aHpDM3lIcU5kVnlSQnVGeGZpZXF4VG9ha3h2V2l2MjRaaTZ3NXBvYTJPWnBDQjFONktPWGpCMjR1V2RrRVZkTmlwMWs4OWJaYUtOMkhsL1puVGE5aVNLNDRnZVRFenZKdXZNOWQ2aEl1TnRZNnU2dHpKSmN5alNBaGpqNVFaa0loWDJhOXNWNzJ0Yng0NlpsT1p3ZHZhOVJoMGVZRzJoUUlKZDFzMmFWcXg5c1ZScGdkUzZVTFd2WW5Td29NZHJGNHBFalpYeVdaM2lnTHVGKzBueEo4ZFBIK0NrSTNvc0Njd253dUgxcG9lWWF4V240L1Y5dEhNQURmNzdxV1poOXYyTnVLTXN4QkZlOXVubWtYN0lmN2lsejVhM2E5Qzk1M2xmdDJ2NUo2VkozL3FYQ0x3d1VxdEh2cnJYcjQ5UEVOelpUeDBjd2F2QnhpMFlsSjlYQlBnOFlLa2tJSUFMaUhKVmcyTHhvNXgzN1hydkZpeGphRUQwcjN0UEdlM2V2bHNRREkvZUxsRTU3RHJSc0h0Qy9vVzk4T25VcUZyT1JZdlJWVGdSd0R6aU4zNnhwaTBnS0I0ZjhuVURWVWhYL2t5WUlXT21VbUk1clQxUDJ0OUo0akc4TzBocjBhdkpkTWR6QW9jOHF4ZEYrMTVqUVZmT3RrbnkwcUtySXFvSVRUTXdPV3pnZHhtejg3TitqVkx6dVVKZTc5WXVIY3dLSnA2YzlhNHdZMmpYMHdaM1ZGWktCcW0wMHdGK3NoWmErZ1FtQWJzOSt3RlR3Smx3UXAzdHRMTkhTb2FNZUpVMTdqTW85S0ZXcUFwZTBhUERESzBwVkZCbTAyZjRsdDFldllUbkJEL25KWjBTMjNhcThSVjF2Q05qbGtkZnhObUM1UVhEcjNIUHdsWXQ2WmMxL3dWNVAxRGVRMXhJaUZrTHdWaWZ0c0x1TVdwUTJPckJlNXFxVGJsZkd2eVRvL0xTV1dhSGs5SExYcjlLRS9PL2tIVVZzVzdsbE0yTm5Rcno2Z29MNU83eS9aT3JsYXVwMEVrdno5enhvY1g4dU9LRVZ3S2xaU0JZcUZLY2NzcFdBY1VFdExDdVMyZXBDdGRpUm5hcWU3VUJWMFFvMWpOdTVYTkNJbTZmSWNpWHAyTy9iQUFseVBCaEx1aGtDNGM1Y1oxY0lqRk9kVUNwWUYrYUdZTldGelAyTzM1b1NJVGd3UUpPWTh5QzhOWkdpb0pzQ3BaR2Fta1RoWXRFQnk0RHRHd28wY0hQUDVGaEJWTTBhZytCcDNTNy8xQW01ZExzKzUzMFlnc2lFbFBNdERsMXdsR1YyZlZxV2lHMGp1dFE5ZnRSN0pwckpzWWUzai9lN3dubmRsZTRHdjY1eEs4ZnZJMTJRLzM4QjUrWS9OM1Y5blpVR2kvK3gzOWtQK3EvUjFLSU1zcGszb1pabStreWxPWlVWOUdNRmpkZEVZcUZoKzkrdVk3dnIrVjlJSS9rZXltVC9BQ1h2VmZaZlFmd0R2NDlWdS9mbTUyT2ZVMUY0QTVDRHd3SzdxMVlseGZiVDJSMW5CYnVINXBKTjE0SkY5bjEreVNqc3ozMWphNm14SnY3eG82ZnM0M0lPQzQ4R1YwSzg2NHVtSVZreCs2NWdzSmJpcElQVUkzc01laHlKYitudWxyMk1NU0xJUEcwQUhnazVOVnRVenJCR0xPWThDeDFsM1BSWWh5UEFBNFMxUW02UEZUak9obnBNVDVPWVBrN3hSbFRMaThSUjRMcFNYZlQwbjNuQ2Y2bGQ4OFAvODVHMzA2TTc2bEFSNDNSY0RNZnBNYjNOZysvdUlQakdxeCtmUC9PZTJPdi9qamgyQUhuK0FhUHVsL0J5Lzc3M2ZoUFhjSjVsRk9BYzErYjA3WVUvQVNxN2txRFNJRVdiZWV0K2V2dytnMm85d2wyTjJvTlRhbU9wUkhOUHVjbXU5QUQxK1hubHlxc0xKcFdCdjBUaytoSzdhUE93emNkeHYySzBFU2pIQStkbEcrZVkvTzRRanBKRGd0SHFRbHhVcTV0VDltbklKVUE0MnBPVUhSSFN0WFVPaWdTRWo4QkQrRnhHNzRyT2xucUptM2lGSFF2bkxYYmx1Z081aFlQSXpEWUx0dFBoYWZJOCtlMStDTXp6WUpXaUhUUFN4V2xDOXUwUkkyekdZc2FBamh1L3hFSDlMZkVSUUNRbGRSeDIzYkZyb3ltWGZkdVVxcFNITkRKNEZ0ZUxialQ2WFUwWjltR1lTQWpyc2xxcFl4UGlVK0czeEtRanYwQjUwa3FzUEMwVThXMFF6bWlTeE9HK3dqUUFSQVlrR25nRFJwTngyTDV4KzN1Yi9EeC9ma2dwWWdaQldBUWdrQ1VPaEVBUW9nUUFHc0kzbVU2aGhuWnpwQkVCN0ROajh4Qm5HTXVxcVBZRk5vNU14RHdDcDZQQi9rWk1samt1NWtieTB2L1Y0NzdUNEcyVUhwSHVwNDJtbGUvQmErcjczU2VuSHlUc0lzalpyYXdVbzR2OTlTQkQybEJOZHVkcXZ4S0Z6Vi9qRUUwSTh3ZVY3Sml2WlQ3M0Vuc3dNT1J4bktsVzZyZHhjaDYyQTdGUHBocHdySHZtbmJuVFkzVzB4Nk9qeHJmWEZyNXIvRVV2clNQRWl6SFl3WW05d0d4d1BwR2gzam9wRWdFUWljUG9MNEpxRzQySGowK1lUNytKOVBsUTQ1WVl1TnJwWVFScmhRNW9YZm0rVHVYZXRuYU9xTmtvcGd3QVc1MmpvYlJiOUZlZmtqd1VoekNINElmbzhaTkFWTWM1VGJ0bjE5ck4xcThkeVgxclNDcVVPQ2FhSGhGQ0R3bnNVbjFUNXNhM3RGbmR0b3JTck81eTdrZnUvNWo0MDZVcVZjSmNrcnZEWk1OeWlIMitNMDBtS3hjWnp2emxDZG1IVGZ3bWI1d05hTmdxMW8rNExLU1J4OU5ydkVVOXBjZ2hRa2xaWXhiamFmYjVKWkxsS2s2cHlhVXdvUHlJVXI3VFUxd2h6bEdEd0V6ekI5d2N3amxtbXFZeEtQdXJ0OHdhS2YvZzkrREY4VmZCZWM0ZDY3eXRrT3NVN0RuZVFaN3c3SE9IZFlhQVUrSm4yaTltaWpVamhoZ0FxZk9NQUJiblF0T1p2ZUh6RW5sMlJ2eit0R2c0QlFORDM3Y0RIc1Jnd1k3NVZKQzJzdm8yMUVOLzBPdzV4andCaUR5V1BNWXc4RHJnYk1HM3JXYkY4OHBuVHZQdGQ4WlNPeGU2OERORkYvazNDK1JoSFZvdHpwU1VVaU4yYkV2M0l4K3FFb21tVnJLb3lxUXFFM3I5Rk1FUEhEb2pXZGR3VjRvR3Vja0NOM01DQTIvc1lYcEppOFY1c1RHQmNmbU5BOUFzUXEyTk54TUFFd2N4RkljUTVtaFc0VFFEcUFla1l3S3RnemM3Nm91MGlJcUo4ZWdWVVJPVkZKdzd1SlducXY2dHZTVStjQWdVa2I5OXFGckJCY1Q0QnZPcm1PODhBdTdDN09nUzdLTUM5RFJFMnZYV3pZQnBlcmExM0VJQytNRHlESmlVZkVocWZFVXF6RS9UVVFPVEtzdGZTVTJubzZRTEwraFN2L0tzRG15Vm9Bcmd0WTZmSFphdXFjWGt3bDkzZWtWbUgwUjRxV0oxb3N0N1hZTm45eXUvMEZBL0Zsa0hnWVpFTXdCRWtOOHFVL2JNbDluZzN5SUJpQ0lSZ2d2UktmeXRaNmRPK0xwV3VpZnJjc2cwWmtiNHR0bzZXbElrYVBZZ3RRWW1rR3VSSnBCcmtTSngrSUlBOUVrSzhMMmUzeGhiWmlDMndFSStrS2ozRGNyVkVFQkNaVHVYUGw3TlNMWlJpbC9jcmx2a1hqTmJpVTUxaFJhUTJYeFhWdEdsaWV1eVRkMkZObUt0cDJHQy9zcmVxNitIRzFEZFgyL2lyYmQzeCt6cFNXcXhkdGZYLzk0WHBneW9ha2hTYkFFSGhMY0dRdnp3bHRVRzlqcUgrblNKdVdCc3c3TUt2K1NvOGlEYWdDYXpRb2VHTzhpYVNXdVdUK1NOb3llU09uL05tSld5R1JtSzZRZm5tZ29rNWZHRG4zRnIvV1hSWWFNZUtDMkZMYkZxbzZVVWY5TnlIQmVJdkhtVzJqYzVzVHVIVy9pTjBoWmYzZXZLa3lNQXEvLzgvd3hhVkR1QStQNGR1NjMwMFJaZE05eVZlU01zQWdkMHNsR2VZb3k2dmFObmwvKzFUN2NaVHRYN0RBcmpQRWFpOXZ1ajRHSC9vdkkzemJYK2ZEMzJZTzRmbWp2TFd2WXdUT3JYMmNabU9aa2x4OTJTRHBkMjNSWWV3WWZiUitxS3VqbmJNZE81Z09GYkRoeHIxQ1N6TXZ2c0lKdFV0WGNMVUdLT1pjNHowNGM2VU1EcTZ1by9ESzA3ZGxmQ3lOS0ZaTEl3MWp0VVVoa1BjTHRwQ2IvWHhrV1dNckJyYTlMQnVuS3BTZFNhQUNNZmQ2SDhwSlNKMzk3UmFhUVJOcUlQRFdreUswek9JUUdBVHBsVEJDeWhjR3dYNWo3TVpJVjNjejluMysvdWhnKzFROHVuMTN3Y2ppek82NzI1T0UycS9KRllkZXhldHp2cTRaY3hDRjh6UDVBWWFyNjVWNnEyemIwWWRYZjQzMElWaENoNWZHRFI3d0dsOWNmWFViMjE5T2NyRVNTK0JscDRMMlgvVzVaYnpuNmRKdFlaRWpWVGgybjNDWXI1NDJXc2ROaFZ2YzQ1R0M0WlRwSG8rNTZ3TjlCaStYM2dDRnQrRUhZaW0rSkNWdmtNSDZyaDRuYk0zOUpXSWxKVEV0WlZJQVdEL2s2WmRtcVZwc3U3SXNLV2M1QWNqNkN4aC9nT25MVGZUMCsvS3hNaUtyTWEwMm1FeVNka2ZwcjQySEtFUzJmYkhYOWpZUWVwL1pMN1pZTmx3T2RxdGRSQUFtbVUvZFZqQit3VzZ3V0MzME5jdzR3M3lhOVVWMHExbVhMQitPV2JDQzRhYTJNZFRnWVlCOGE4enY1T0pKUFBlcXJaSkRrbnpRdklWYWtKWTI4RUhpOHJZT2N0YmE1c3JwaE15dy9FTHRkWDFVY3dyb3AwTWYwQzYwQ2UrREdxcGV3VW5Sano0cStTSWEyd1hJTi8yd1IwdXNkS1UrV2xtTjVzNjNBVU4reUVnT2xURm5MWGUxVDVQYXpvQWZ1emQ2TnJZVmwyV2VFNThaSUdjbTVZMlB2Qk83WGlpUTB3S2s4ZUhjUGV3cmJML3kwOEQwbXVPaDluMGtIdTV3Ui9YMFpIUmFudjRIUDAvMXRmZjlVRHgwWDZYWkxsWC96L2kzMjc4RndXNGJzSFpyNXNiQmx1RHg2WFp2cjRyYzN5SGVPOTB4ZXo4RmVRSWJJV0hEWTlhWUVVSzRWcW5rVWpBMFJuWE42T1NUMUlESm9EV2MwUU5MRUR4VUQ2UGpqcS9GRFc1c096UkptVWdCTUF5UEY1SVEwOEhpY3hCYWY2ZjVhaFUyV0puMzd0QWJLbFIyMHVjZXFHMlVoWTdBMGd3Q1gxR3FYQk1pb2g3RFZHeGU0Y3dUSmJqNGpNSzdKZUN3Y3F1elJKbGFkZVp4ODg0OXQ1YmNwUElaYjlYZXFsTDV5TkhwRGhFaXgwc25sTEhpZVlrZE9XZ0R1a2x5eTlKbEJoRWZQTlltQi9BTXR3anVzRlJva0p2ekZ6ajgyMGdzUzJDVFNKYkxzM2IveHU0ZmtPdGJKQXRqT2RjY3NZeUhPK0xhci84WmJmbnd5YnhteDdrWXlpWUIrcHFXRUdQdHB1WWN2Nkd2SWVsWDJaMm1QZGFIZWNJZ051UFQzVGY0WW5QRWs3aFQrL0gxZWNiNUtXbko5SzArQTVYMVJyNVZQQTJ3bmcrc3NrdnZleWVTSUh0K0huQU1zRC9aeWlENXBSOEhDNmFSSnNXYlVOZkVmNHc0Z1BmNEhOTkdobkxRT0hCNUREdmJVKzE0WkEvcHN2czZqdVROSVJlSmo2Rncxc2dtNkFCZjJTa3hNUzFUT05VUlgrKy9wUU1mZ3Qvb3FlMVlIQi9yL2JwU0hqYjFEU1VYcTRkV1hVUFBGYnZOSjhQOFRtNFk4c05oNkMwVmMxdHVoeFZXanRQRDlTSFh5UE9OQ2svdFU4UXIvMVVoUVpZYTJIaldtUkJodHhEeDZSUHc3eHB3bkpkblBLNGNHOC9zcURiNzJ2SVpjU3MybWx4Zk1VSGNKV1M0OUVidlhMZDNMbHJNMHlsekNqTWFsai9GQ0R2WFZ3cGFSU0ZJQUxkSEpaSW1CVG12MWw2akVYRWlRalB1RTMySHZwOGhyQjQyOVdnU21JQnZDSEtyOEFBQ0NjK3pHQTJsOXNpa0R5dm9tZ3A2RlFaUVhXL0pFa3c4TnVHQTU2T2JibTlJaHorbFl1SHM2bzNDaGtYaGlRbXAxTnlDa2dvbXFkOVgzd2VVdUd3UDZJM2VQMml1R0FtK1VwWmZzRmxodUt5VVFHOGZjSG1LZkU5VXV0VGhBZ2NTN05FVUs4bGQvVnlzK1d5NnlJYmRWaytmVjJkVzkrYjBtQVBFWkluZnVYU0RLM21yaHlldjM1aTFlYUx2d2c3UmVaa3pHN2hBOHEyUHV6OG9WUXNvUU1wYkxYWkxUUHNQQWVRQkRrOGg3cTMvNzVhOGZmTGxidW1MbC9Zak5SaUFNVHdEVllNVzdWWURjbks4Tk9kYmsxdFI0QTZWeHFPNndMdGZFOEVINnNILzcySDEzWlNlbCthVkVqUXVSNTFPMXkvRHVsNW5xWThQR0hBMW1vblArY293UllkbFl6YmRuajArdDIzRkpwMjdURk1vVjNmNjhJa04ySFFvbzZMdC9aUWc5VG1Rajcyd2VBZmR3UmJOZ0ZiSlJZbUlXRFRrSVdOUW42U0hXQjZ1Q0dnVno1Nld2SW5hMmNaZUtWSTA3ZkpnQ3F4ZTBzV1lGcVUwdEJQUUFGTStud1FYTjRJbERyd1R1YzlWRms4YUwwQVBJR2s3WjlDZEl5VVlDaXVaWnVOQklwNGFGY0ljSk5hRUt6S0dscXd6Q1pJQTJ3S3JNSi80Y0xBVEFDRTZDU1ZvRHpIeXpRQjFEN2NhUHNKUWNWVS96QlNYaExFL2M0YVVpcVZlSnF2MVk4UkY4V3o5Ty9TM0Q1MzVqQnF3V3AvQXN6WWFPRjBZaCtONTBCd2NGVmVCbTNOSnV2ZXBYSVQ3NWRFU2NJelBNODJkck1UU3JyTWV5RVlkZk1WeFRxYUw0ZXNyZ0lEWW8wRGVlaC9qeStrZXhPMnpPZS9MUFdBZUFocWF6dVV0a2o2MUlQN3hNWVZqNTR2YTVRTzd6bDRLYTdwQ00zUEQ5N2tzSGdkTzcxR1Q3M3ZYbUdNVmhjTmkzNitBTzFUaDJyc29TcVcwTURMT3Nad3JXK05OZWNVK0gwa0Znd21JbHkvTHc5YWVwajNPWlBnRHdZRFFvVDd5Q3B6QnBVaUtwQVdRYWh4b0R5aHlGVWMzS0IrMUFuV3A3d0JhRGNTSUgyQ0VEVVViMTZvZzUxbGNrdUx3SXpEY2h1TVZXeGdXd2lSZ1IwOEFLT1I3UmtCd2pCNXVzT0tlNFdaS0pFZzhvSDRqL0o4Q0ZPNVR2S1M2bTU5czFhNDZPOFh1TGlOUHZnNExJcG9zWFBPcEFqcE9wZUxtNEhuZy96djBIaXdXRnlsczJXcCtmdHljWWpkN2hYalI3WDkyeE4rUzJlV3VwWUo3c0lLU25wTWdxQUlDWkl2eEgwR3k4RG54NWtyM2JOZ2pyU0dTaFFueXptOGpwTDFWL2VVMmxVVE1Kc3JvVVRGM3hSUVlra1dHMkR4SnVlNW1PRzk5RVBEci9TY01KNWtIWVlzRHVFT1haalZHRk14WkpIZkhId3IvR0lxV05hUkFRK1VjUExMZTJOQ0ZlY2FMM2N4ZWJRZ1FJUk1kWTdTOGJTdjIwMnc5UHV4elVJckM2NHp5UHM2OVc5QzJHY0JCNlFWNHZZUWVDaHgrQ2tDWGtTUG8wVnZEUnd5QW9VbWlQYXBteUZETHBwcGt6Rk94THl6SkMyUVhNU1BIV1VLaml5eXV2Y21vZTBzVkM4UisvSERDdHl5a0hMU0h4RFlnSldWcGtQN1N1NEN0L2k1UHFpMWZpSTZueDRVZEkxQ04rTzl0M091ZktvaHdsM3oxaXIxcGZ4OGpEUFgyOXNXbTByaDVsRmQzTGxyS0c5UVptSXA3cEdnMjBjS0NBaGdjdVhYRkUwc1hrQUNwL0FFQ05FRlZlSUh1cDJNZUk3cXFxd0Fzbk9XMGFIc3ZsZnQ3bXFYMDh6SEh0Q2hMcWthVVZlSU1yVUc0ejVSeFBvMkVEZm82MkhqSzB4dEl5RkF4NXVaVzE3UERxNlBhV0dZMm83RjdMTHR5Y3kzVGFIMjI0Y3RidUtSZWNEWllFNFFzaklUMUFBTlJ4ZnQyOHE1VVZNaEJDRU43Y091S0d2VlZkVUp0QlhwcHVxczVITjZsQS9sSi83bkhFSmNEa00rSHZtMlRuMm00UEtLcW9XdjVLMTh3YXk0aitJRENLbTdaY2trc2lURjZWWGdBMk9tTW82bS9nQWM4NHREMndaSGxKVXRQQnpYanNWZDBjWXFRWVVsZi9zaHFqTm5EeWd2cVhoYmRhbGVZbS8yUk9CVnFxQ3JOQ1RMeGJrb1BmY3JUdWVpbStWV1h2ek4wUjNPbFRIVTNtSy9LQVVmRUxvY0VpY2o4aUhTdVU1bWg3cXA2V3FXTHQwUGFNTWc2c2k2bGxXbDVZd1RJK3JoY3lweE9CdjBSd1hac0Q5aVoyaFE5TzFDQm1pcVlheVhhM3RlNjZSeWEwemY1VGJGMjJNcmtrM3Y1bGcxbWNyTmlaWmE0WGJkd3Y4OS9XOEJYTzRDWlNPa2pFV2JwZGp1dGlvWXJidkRXaWpuRWlqRk5iaGJlTCticWR0MmRFMGhoeTFyRU9QVnlzcE5Gb3E1NlkwS1FTU3VaYjh0ZFhaNEZaN1hyMW1oV3QyMVE3OVdRa1VOVlRDd1U1RGNQRTNBWndZZ2QrNzRLQnZWbXdqN0lWR0hYMGJKTXhITE55amw2ZEd1YnVTS1RhNWhxaFVTeVI3eWJ4eStiRDg5Z1BiNTJCdlVSZ0FJU0hRWXpISkVXTmx3L20reSttZFBpbm1wS0dLaVAwVjAxa0lGVUVnWWRqanczcSs5UjBMdU5rYmpsaXJlSGVXR3NpY3gyR3k4d0hiSU9TZDlINWVZd1pjWUQyYS9VYjhqY0szUjlJMlZ0a2pLOXduNXdiMExKRGYydVNLRThxaDZlZFNKNzFNU1A4bUhKdVY1MEVaZVlwZkxzenh0NnhmckZLbDVSb2tLaC9HRURMZ1JLeW5CK1pkMitCVlQ0YldHK2EvdnFnQ3UrVDdrb3pia21GVTI0ZUFCMDFCUGdnMTRJWG1BVUgxK1crNVdXaGl2WDVUYzdkcWpqM2JmUjdaYm5ueGlyYTdLQ05PeE4vQ3hSTGFLK1pUUmtmWXRubXdaWlBYVEp1YlVmM0NhdG95bURObWozV3NqSm9TcDM3TlYwN0Z2RzJ6T08vcEZmRmZGZGg2eW9nMWVUeHg4bmhpdWpleUsvMm4wSXdoRWlGdUNVd2tvRFJWUCtUUDE2NEgzLzAzK1FBQThxYjE1VFpxZ0xZamo2dDl1djdXQ0hjbk0zNTVhNkZ2cjNKRnlzMWpSRlZiVzdUakw0aS9yYzBLcVBaUGxkZmVYUjIxRTFlb3l3MFQyVW5pNG9Fd3laNy9QN29FY1pTN0YwZ2Fscmx1Z0ZENmd1bm1uYzRORVJLQnd6ZjBZb3RLcXljNFZWN3dsTVpzTDRmdmtzYmQ5K2FQOEN1WmlsdlZSUzJ3Nk5hbTVzNWRJUVlOSHBCRWErSXNBZi9QbXY4QUY4RnlRQWVIeWU4QjJRWSsvZ1o2THhlbVV6blE4N0NINXJFWkxpOVJUdW5NTTU3UlV0eGg5WEp1elFOd2JNbHJObHRIU0FGeFJvUlEzUmxUWUd4QTE4T2NXRm1kRk85dzdHT1dxcmEzLy9scDZmdDkxdEY5dGZscnUzajc2Vklua3lqRlZuR2VITDdBNVp2eXZxdC9RMlFqekhoQktsd0U3YXhpdTlpK3hwNm4vSGh4YTJhVFgwNEFxZGs3N3VDOExEWkxzT3FaL3FyOXpRRE4zb3V5UE10L3FDZXd5bmthakQzSE1maGlweEZzOG5ENitxOTcxd1U3UEc4ay9CMmx5Q2loUnBNcmFtZkRacUlGanNiMnlEdUsvdXZmSmlHT3lWbG80YlRBODdzanZvYmZUZEsvR0wrdXY3ZjNmZmJRZ0FPZEh3WW0rUHRWbHpSengzNjZyK0E5Z2Y5dGRDcFhCWExnT2JhWXlSOUZxeExDclZnUEowVm03YSs5VWhxY3N4c1J1cFdtcGZiWUdzM2J1ampGRWpzdXB6ZVhiTmgvaS80Z2VOcU9pVmZua0Uvd1ZMNG9FQS93ckZRZ2w1dHRkckI4UW1kOTJnRG5RSUU5amhKMG9KVzdRUUp2QmtxTFVpY2t3YkEyNFVpRHFqb3lCYkRLZVMzUkkvZnZCUUpRK1hZcWtjY2FGZjFkUy9mZkZ6M1hrZlBCcWR6eXFleFBsV0tjV0hVOUZmc2xGdmdvZUFDa1QzcnE5OU5vdUZQakRFdktJRWJzRXhzaWlTWW1Sdzc5c0tCN3ZnRUJLTGpGMWZyTWdwam5PSHJjcENXVDN3ZFk5L3dhLzFoUFlKYitpc0kzSGF5ZnIrVVZFcTErendSQTJkRHQzemh1eVJHVm1BcU9CYUhUNEtmRWxCMVlZSFZYZTRBZDNjdVZhbGp4UlEvZjRONTI0S3hWdzlzamxheFBNRHVaRzREK0VscUZ3eTdSUnhlQmFrMTd6S3ZPY3JtNHdVMXNmb0MvT29Bd1JJQVVRUWVsSzBBRU5QWTdZcUhRQUdrV1NsMktSdmROTHlMWFpobG1PUzZXZFM5L1dqWlNxdGN4M25CZ0pPYlN6NFgwYXA3Y3VVWE8xQ3ZjbE1uUi9lZStpRngzamd2WmFST1NpVXFLZ3p5ZldzSWsvdXlldnBROFBkVm5kZDN0VEU1bGpSdlF1OWprUFh1VmxsL3ZEdVF6ZmN4ZzBEN2N1cVI1WnFDdlRCK3R0Qm9SdnRKMkxXRXBMVkI5SzVJWnhuZ0lBUjR3UElPcW56dEh0cS9WZU5kRGRsN3kwWUg1YlBxSzliTXNqY2t3S2JYeGZhRElTQXdKc0hIT1pFR0RIU2tLcVBUdm16dHVaTnRtWVdOYzRiSzZzMlJ3UXpubjdPTkt1TXJ2dTRJNzdFcWl5V3lHeXZUV21CVDBYM2g4ZXI4WWR5dG9ReXRwQU55d2NUWWVvRTZsb1U2SkVtMjkxYUpVWEJhQWRleHFWMHJKd2R1dGl5bitxWHRqb28zN1pVRWxYOWNBK3luaFpHVitQb3VZeUNaU1pNbmRCYXdmWlNCMHlybjFyVDF4L0ZpcTk0a251WmpTbTlwNnY2bkxYTG5zY3k5NHJBQW80MzRaMHhBWUh5OGlCaHFndXk3d05jWWFISWlqWHNHNTdMeWR0Sk5YbE1Cbkh4NjJrYWFZcnMwR3NLZWpNWHIwcmhheEFucmoyVnFPVzZSVk52S3BwSFNFZVRta2xrazUxVy9HdzNLNENXWE5oNVhRMXdpUGtOc2ozYkhSWTZQTFNJWkVYd0ttLy93ZTN0amwrRlJtZ0NYa3pVd0JPeE92c05OdFRQN1dFakQwQjVTNERmeDVBc2JuZkd0SGpOVVI2YjN2VzZmd09HeUQ1TDJIUmdXZXdVRlp0VXUwOWZhY2xQL2hQeWtFaStTSEVjTkpReFcxUXZxUWRBSlE0ZnlRcmc4aE1VYWVIZHk0NGNyVVJrZ1MxZUdYUG9FUk9GSTNMOGlBTWNVT1lGVXdJZDBpV0JGS2xEM0lYS3FOeTJWRzJyMnFHTWQvbTBXRHpjS1g1T2JKYWEycnZlRWJ0KzgweU5HTnNXam56eTBFV2U4N1lsdzdhSS9lMVkzRWlSSHAyMjZlZGs1Sk0yOUozaUVFMlhXbXkvZysyU3V4WEs4c1Y2NlVkdWdVMWFQR0xTRHF2NGt0OTRWREUzT0t2dkJ1ZHhDK3pZaWwxMHF2b1Q1b01TOStzb1hWem1CZGVjVlV6allGcFZLbFdENk03YThNSkZhazRUdE1Md1hhdTdXeC9rSFZpVkpOa2FBcExZWWhQa2Zma21hd0c5T1NCRG1pZFJHaGE3aHF4cnVlcE1RVDRjK1c5dU9BK1h2MVF5bTIxdDV4S3lGY3FHUXFqQ1dwMzR6RnpLZTNpUmM2QXJMOFprRmI4OVo1eVFvYWVUdG93TE1rOWgxcXdiTGRJN0xGQWt3UFA1SjJxamE4QzFyVzFrVjF0SUV6QWNJWEEwbXFrazI3TG9iV3dnTDA4dkxNazZEVWhJUmorQkc0QjJkSVJEYXVYQktlZEZXQXhCUjBFeUd6TGwxcHF6enBYeVViMVBlYVp1KzJnUFQxTGtQVDNaNXVGeWtGV0o1YUhQbmF2VTFZc1pCbi9vOXVic3ZadjJPNlhQV2tQUGYxT0l3YjdtM3hES3ZMa2p0OVg4WkVpRkxJdVpRbStyWkZ1NEdhSXEycFF2d2pyVjZSREJEd3BBbHhDMUxKbnVhVllZTkg2YzVvUWE1YXNJRlBTZmxwbWpvZW94cklwUzhMcmcxT1VJZ2Y0YWYzWDZxRDN3Rm4vRE84b1ZnajZZSjhBWjcyTXZCY25rT2s4bFNpQjE4bTlhSFlvQ0hsV3cyV0pXRTNKRDZNS2kwcUhqcm52VjlHeGhrT2Y4ZXBsS2xLRFd5Y2RibFZoNExyOHc4MUxVeCtzWW5HeEtYaE5BM2FTN2FsbEVQKyt5eWgxOUM1bmw5c2ttTzNKTlFOcDEzUGFBSEVkc2ppTTJSd2VTWk9aRXZ2UnNDYUNaQnFOTnlSVUIxSlNXdnB2b1lMZFlianNMNHZXVVNwU2doQ1ExSFhNUDBDNEhuLzJWdWc5clRUVFV6YzZOdUYybk13SmhoK3NWL2llQURpSmxwUlQrYWtJbU01dmhQcldidmxSTGg3OG51OGtxVU5qczlwZHRmaUE4V25uL0VELzZCaFU3WFgxcEt4TnQzR3I1NDVYdE9xNjI5bUI0YmVJK3JxSlFtb0RDb3FodFlkYllxTFBDdFQ2NXkvZFJ6cWJwUEo1Mm50WE83L2twNWRYUHA2OCs3Sy84dUpEVWdINlhwODFiZ2s5b1YzKzV3eSsxK2RNTzY0UkpReUQ4K1B4aFMyb09zRHNhMjlYbFhxN1RiaSs2ZG1vQnE0R3NTVFh3eHFNdmFkbXFIdWtjWjZFU3RtdUQ2OVJFS3pUajl5WFdGMDdOL0QrY3lGOU95d1ZYUndkek56SDMyNkVkN0JRSTlib3BSTzF0K2dRMjZnem5IRkMyYW5OK3RWMkhjMGFGZzhLTityTGh4UFBUKzB0N1pTVzJ6d3UzSjdLRWtNa09ESXgvSkNLbUVVSEVlcnNOQTdnR3k3Q2pKK0FnVndSUlMySWZlVzdicGJtT3NxdFRRQ1U4dmMxa2ZDd2grTzY3T1p1SDJDeWY5ZVZ0LzJkM3lFRlhubVYrZXZmSGNzaGxlVUVhQS9MSzkzMnl0Wm1vMCtxc1cxZ1NpbE9KY3FLQ0toWEdqKzk0Q2dxeHdvTlNFdDM5OFl4QWJEQnBoTSt4dmNGR1d3cVBiYXl6d2lRN25lbWZOVVZRVVFxakRuSW8vZGtyQTVWVmRHVVRTaE5BWFZQWGczMktqOVZiOS9peGp1c0ZsZXB6SndzUUtOdVZ6bEZGOS9NenZlSlVDR05GdmQwQlRRUXdHWEdzVUZnWjJHaVZ2bG5FeVF6dmp6bDgwc1d5SGhMbGF1TVM0U2wwSThMVFpzaWV0T0YyRFNCVjVpckxtWGRaUklNUFRjS0JGNkZaQlBYZDZMVDVpSEZ0SmxjUVBiK2F3cWdFVmlyMGNmcXJvR29Qb2lXR0w5Zi85U3lSS0lXb0NoRUtYcmQ5cDJUcWdpdTA3czUrcXhCeXdJMGNyenhvUWorTWFRZ2tuNXZPbUtlbTRhMEZJQm5nT1NMVmZrQVAwTlhKZGFwZVJ2S29KaDI0VjUvMytKRXBvdEJuQ0J0N1VGQ0J6SGNSUi9EL2pFMlExMGRxWlhUcTlUVE9kSlNDVndXSC9SenAyUWtwSjYyQzUvUDBYUytvNHpwY0VqWUdTaWFuRVozVGlNNXBST1VFdEFwNEZLR3p4cWp1cUZWaHJRb1RwbVZPZVJwRU9wMDA4L0I0WVpVb3ZVb2RWM28yNGNnbUo3MWwrWkdGZjJTMmdtQk83aWsxUXJvTndZSktKdWpsY1dGVzBZSW8wRnA1bTExL1lnSmIvaFY3MDhVa3BtelhBU2ZYQ3M3cnR6MHhiUVduNkRjaEZSdTRJaWEySGxmbW92d1VzWU1WMWlidDlLSFdDdmhpVGlOSXBFdm51R2I0OERFZ2cxZk1HNDY4QnpuTDg3eWszZnVvWnp4Sy9vWEpHSm84RmtRaG5EYUpiQmhlM3ZHNGRGSldnVDA3aEwrMlJDWkorQzllVzdUamV6clI2akVtaFk0R2c1QWJrWllraDFoeW4wMXg5emhiSzI0cnp4Ny9LdUJLYlRZcjk4SWc0czd6bUVOcUt2WnhyVkdIc0NnUm5yNXRqSUh2WGxEL0hQNnV0akZBNTJVdEoxOEFWeUY1T2tMQ1JrNWorMENjTHdHcjF3cXQ4dzZpVGxCOTcyOXE5cjZ3UzB2eUh5aWJLSkpKUFcrcG1HMmZ5amZvd29VWmJ2cDVYbm1NdmNWZU1EbmxrSi8rcitTeXZQWDVNUk5PMVkvN0E4cHpTTzFQNS84Y3Nwd2h5NDN4dTZSbHRQSjVqbWROQmtwOEFhK2dBaWtYbGFhZncycFpIZWpZNWZ5Rys1dzIrQUp0Q0hzM3Nta0JXbXQ2a1RMSGVxbDBoRzhKczVwLzNqSVZPS2NkNVJScjBHbE11UTh0L3poRW5lMUx1UFlOQXN0cWJESEJMbklCQVE1SVRBQTNZUHJyZVZHU09vc2wxZGlmeW5FQXljdXF1UnFVV0cwUmo5MEMzbW5qeXpFME5ZeEFtQ1ZqNkVTcDZxbkRZTXVEYkFIQmVrU2pIcENjbEhBaGNNQ2ROcUVNU2ZxeXVoNFRScGlGVGRnc0Z5a0EzVURqTnRBZ0hxdHNLMjhKZlZSQ09VcXl3YnlMWTVOcUhFL2xlQkdBL2lBcURZdXVRTlo1clp5bmRJbFdNcTJYR2M2SUV4SyswYkpGUnF4eHdwMlZUQ2p4YXFIY2x2OExYa0J5MHVXbXhBNGZMTVFKdzRTUEV3NC95MjltdTM3dTRWbDBMR1A4UUVNcGVPWE9qQlN1ZitXOEhjQkJaRGdqVGlnbTdJbUVhY0tPcURBVHh6aG9xYXErT29HcS93VVVwTmJlTFFQSU82SGNYa3FPSy9HR3k2Ty93VXdjTVU3WVRqaE1XQ2Fjc0xlbDl6WmVLUlB2V0FlRnZmVU9LTlNPZWwxNENZVXJoWU02SC83MlpCaUU2TkRWS3REcGlXQ3dLZ2dZMUdVMDZHMVcxRlhoQ01GS29YZ2puOVJUQkpjWCtLNW5Nd1dVMFpBK3lua0tJSXBPeUgwVjFkTlNhN3V1M0lyQjZjYWdMVjRRUFZodFBLNXRacWtyKzhaUUVhc1FkUVFHNGdVN3JwdGl0bkorMmZ5OXhYQ1hZMmQxZm5GL0wxUHlGNmJFRktTbU13UjNJampqOC8yVllwbUdhblJNS05FWnVwa2l5cUZzM3pvMlgwQnNlT21HRjJOTTBhdnpTa1ZseEJXSzNPSDlhZzhZZlpKNmdQT1NzYmovNFVVWlZGRWFlMitOeXlPNkk3aTRSVmRpSWNQWHl1a3pSblRoTzRxeDM5dlp4K0lGUk9SMFBWWmZTZ3dwTjJVc1Nzc3pLRWlXeGx3a2tGN0orcmNhYnJHbzhoUmJsTmRDU3B1SlQ4bDFMQmxxbHl4bXJjaG9uWkcydmVLaGtUQnJKczV0VGFUN3FtRDBpRXNZRXQrc0EzbFI4UGVYTS8reVlQRmxuMytNOC93d0pSL0R2ZXB4dlQwdVFWV1lHZWhVM1o2ZStLRVhTMFowN3Q0YTBReG9wcEFyTGdxV21lZlBpd3JEY215Wm5SbWFHMDNZQkh1UncrUDZhR0ViaDhmZmN3eGdCNWlLLzNZWnVmN3BBTjBOM2lWZnhRRFF3UkhhM1lvWkwwSGZpQ1pMaUpoN1cvelh2SmdaR1F1QjVzeC9HeEZVRm1TQ1ZUK2IwblJuaSt4NUZpSlNBZ2M1dUtPVVVRL0xoa0llUThNeXR6cVAvc3hwRERaei82RVpBY1lOU0hsNko0dHlTUUM1cFEwUUlBNUJHdmhLYnR3RFFTS2Q1aTdDdnZkcFZma0dlTUlXQVZKdHVlS1M2azZBVXN2a2dqYURNdFhkaUc4UlJwWFU3VHVERURsZERXdldlZVJGUkZ0cjcxRjN0WG12TDdYRHRxdnZNV1lvNmNHRkIwK25zRzVZdTJqSkhaNEk5dDVaNG1uRlhwaGVPQUYvNkNQQXVYTzVMUTB6UjdjTjdvRkZXd0p3dzNqWWdDMnJrWThyb25RT3ZtK0FWTGdobm1kVHdaSGlaVTlmNjA0bzBFMkZhbG0zRHhPT2lWaTlrODRkWTZJczFmYWxheUVXUzNsa3JjREpsY3pXbk8wdkNsNGhSVVZCanM4c21UVjJtYmFCeDlIUXNQQStDakx6UUYzQUNVU1BoQkYrd202cFFsTEFhVEtsUTFjTHVjb1l3L3pNTitLYUdEblVVVVVaVjhZSjBxWk5jeVZvSktjRWJtUHNkL3hQZ1lNdEJVeVVPUXZqeDQ4endzNEhEQ2ZoemdnL2dSYVlOcUx5YTdSWlF1RlJtRTg2UUpKQlF5bEVPSlRYNEc1Z0pTeVkzQURYOUlnQ1ZORTlyNUpNdVFpa2ZDRk9RcWwxaGE0SENkRlJYVVlNaGkxS0VXSDB0WWhmUUkyUWdLY1VzMGxCRU5pd29qZTRZOUl0NXhsRFRYV3lhSkhwcFMxMm9Hd0JTcG5Va2VESVB4WlRUZlgvS3R4b0FBUUFzL2kybVB2aGovTnZGdEV2QUFCUC9zcTdQWUMzbFBwcmM2UDg4RS85VlFBb0JoUUFFRURtcXc4SWdPS1l2ejZGRno4TENKU1BKaEttQkYzbEZuWnU4TCsxNFpuS0hmQ0VqV0tUdWNmQ0Q0WW1NK21FWFoyUzdYeUpWQmpvRmtrS2t5VWZKNDRYenFmbW5IZDBocFM3c2FQZmRLVzliN28vMk90R0FuYnBndVFLWjN2dTBudk1qY1pCSWx1NGVMTEZEVWZKcVhMTVZ6MzVvNlVzUk1qSlYyUW9qL3RFaWVYekdUY3QvN0ZHdkg3ZkNkN3ljSUtJTGNVNXloa0RpY2RiZmR5aG1uNGg5QXlGTkp3NVdxNEM0TXdrVGU3Qko3K3JKc01FUlp5b2FTbEg0a0tuYlhWOGdpS1JzMTl3OWNNMklnRlh2OEFlQmh4a2NGS0JlR05Ma0ZvRXFyUDJ3dWxpQis2VE5tNGc5QnFCVmFLUFg2VkZUZjNacHpZaWViWXJ5c0VzRnNZUVdlQy94MW9JUHVibUFZM0RHUWFKY0N1M1d4aEpzejRvR2s4NTBoZGJSQnJXZXkxNnIwRmZXb2JweGcrMVNwNjdQNW5YZTBzZXR1UjF4dHdqSDF1aWNUVGxjOXBPZmc5UW9VNHBLM3h2YU9XWUZnTndyZEdzRXlhQ0h1ZDBJZE1scVRmZDhxTWJrcVFyVkhxKzhZSUNwMmN6OC9FMDNMODlTejZkZUozbEh3WmFFR25pNUpVRE1XTjM0bVhFbXppWGNybkdrVE5zOWdzdTFWbVVrUkxMTGV1M0lVVmFLK2pKTHNqYkZ2UmdDdklHQlQwWGdQeGRBOE5YaUdCR0N0ejh5SnR0VXBMSEZGY2wvTVNlUlQ0cXRXZEZmMnBvRW1pR1NqU3Jua0dnZ0hJVVdIcjBUTUIwU3BrbHRmc1F2cEZsRXdPYkJFOG1RZkpkSnBnUUUrMDRXeW5UaFp4MlN3eGF4TDBURTYwbi8zaVV5NWEvWnNWZk0rOWthUWpmZlVUd1lpaVVuSGdKVmd6dnpQZG10OEpzZy80eEljMXRuK1lQRnlmZi9UbnBmcVJDeDhnWEZsNW1IdmV4OFZYazFLUVlwc1dkcDdyaHFvSkJpd0pLUlIrV1ZDeWI1R1haSGV1eC82YTVSMjQwcTU2VlpUTFQ1R0ZuZzFQZVNaNXdkMHdLbTRDZWFpK2VwNURyWFNOaFk4L0ptZmw5WjJIL2FqUWMvcGVQNG1DVENaMDZEcjdLZTlkY2tjdHBJVHdSL0pDSzRQdTV6SjErRno4S1g1N0xickVnOGwxOW9URlJoOGdCaU1ZTkNscGlyamtnWU1mU211NmVjYk1BQXMwZjh3VTlINVBzT1c5T0ZQNWZmT0xWZEFkNGVSSXl3eWVNRVErRm5NejF3aFZPdWNrTEM2ZG5pNFJoaTBvMUg0ZXhFY0JML25FekpkcFNyaUZPT0hxeDV5SlA5anY5WE4zUGE2ZDVhb2FySnFLb212MEU1NkN5WkVuSnZ5NVl3WlIwbDJiWVhuNDRMaG9STnRlbEtXa3pxcEJsZWVua3RjcStJOFV4Z2oxSnVBbDBkd04vaWdsbUpsZzRyc1k4dFRtc21oZ0NISlREcHA2bjZBbFZrUU9LSVpNZ0FvdG5ROXRrYXp4YnVObnNoTGVzcURIa3FJeWdkWVRrWWdnVVlwTm50Q2xrUVpFZEtBOW1SNEFKQVRRTmhIK0JxWUcyQUFIQWF3Q0FlY2o2N0prWUx5YklpYmNMd3RXb1k0djZmeks1MzBGZFk5WmRkUkxMNUMwZE5GSnFEdU4yanpQRjQvNkg1RXhwVTd4eDBxczlyRmJMS3B4anljTyszWVJJbVIrOS9YN2h5V01wYzRDVGY1QzVJd1dNUnhSS1RTSmRNRkt5WU1rWG1UK29GMEV3UmNIVldKUE5UZlJjb2g4S05ZMUcwNEJqajNaYWVPalErT0dOU0h3c1J4WkRqRHlOcmdhTzJJVVBRcDN4aGNwTkNneGFQcXZqaGhTK1VUY2prc3ZTa1ZPRExJQWlkOFJuUyt1aFpnbEh4Q0dRZy9LM0lBbXpISUlORkdVTjRPb3g5ZWpveEZnUVRaYzlYb3E1SnBLUHphTXZGN1JXVUJpYXFjSFZFb3E5K2lIa2VuOEQ2VXk5U05ndlhUNjVxS1gzZVhuanQxYmtCa0hNbnZCLzhrN3FKRmRvb0Q4V1A5T1lhNmdveE5rL1dVaUdiRDVHSGJpY2s0ekpUM0xSblB1ZGpJbWxnZ0ZDQ3RFNmVZTWhrWU1XT1FSSVR3aUdEUFZEdzB3dGpyR0g3QXRLbk1TZmVpY245czRuUWxvQUZ5V0ZEemdpeVBONHlVZ1BpbGhCZEpmc1ljdldDRm5PcEExS3p4Z2FKVFBMR3M2Y2xrKzdzMFp1VElXSkNoQlFvQWFEOTlGdGptTWQ4TVQzTVBoS1JvS09IMjhzK2RCemxnQ1Q5aUQvWVZadEFNdmRja1gwSzArOXpXWkJEOFhQVFBwekRaQUVpL2ZETzRQeFJwdmVJR2ZkMGRoSktiT1dZN0t0Zk9uemUreFo4M1hQeUxMTkpDSDBvZ1p5R1REVDR4SGJYY2swSXloNHR2cHpxL2hYTFpoREJteXdvaEpySURGZDhSY0UwOWlkb29uKzVMYXhQeUVyTEF2QTVXaXE1WWpGYnJTMElxZ1AyMGNENis1Y2grQVJZWkVibUU3SkRTWXZnTlFIenJ5M1ZxcklSc0p5d21hRFlmSDdETks4VG5ob1VIVU5qTFVqRWU3S3A3NFdDVGwxTHRjOWQvMnFjWHFZdDZyQVdoMEFuaHBLTUpaVk9uS3JmN2IxbW92cjdaMnVaYXNxY0ZVSEFPYW5XNjFXTW1vb3dacjdNVVN1YW9aZUJZODZ3VkJpUDNqeE5UbTF1aitXcUxhckxXdTNtb0Y3eExhMXY5N2tacVd2ZklPTGF6RlNZTnN4U1g4MTBmTit3ZTJXdTZDOHEzeHNjejdvTnhsVjdKUFJ1bFBZVVZXd01UNU5jbGs2cnVjVHpOcExvbjIraEtPUk9iVVRISW5nY1V3TWtMa2NHMWNyUnNXa0VIaDB2YlJmUC96VjNROGx2SUdIZE9SV1AyakROVWZYMjdaVnp1RE4xTUMvTytEdlZkMnVuQzRkVWNEUHU1allHeitHcGMxckdOZGg0d2NSc01DNVNCamIwaFVHQ2pxemlaUWtvcUlET3lrdzkyRVFVOVloSWI0U3dxMzh5N2M5SDM0djZGQVZVMWtWdHdya2F0ZTFzZy96V2ZRRXA4bVo3QnVoV1l3dG5GVHU0aG4rY0RqMnhrdVlHMWZMRTJ3cHQ4aEtjdEpndnRHNUp4VnpHNGYzMlpEUWN5OWlBWEIxbWMwM0V5V3puUGJPTkxhNGE4VnVYajZjY3M5ODdocFBHNVh5WDhwcTQ0TG53TjdyS21UaFNUS2dvcDl0WEdyTjFySnp5TlRySnA3ZE5zWXlqK3lZdlNuUG1XZVFXMlNOeU04L0dPdis5QkEvSk92YTJEOTdGbjJaeGk3a0RObkFYOVg3OHYwVTcxcXZwc3RpUHZsTjBUV0Q4YWtXLzRoTVgwUkdrU1BzM0lyVkt0dklIektOM0NGUGw1a09yMStVMFI0NWVucjN0ZEozRmU3Wm00dzc0aGN2KzRYZHRROUIwL2xkWGV1VjdOdEhxcDZZc25JL0taNVp4V1NEUDRjTW1IYnZEbGczNXhlUnRCOTI3TTNQeU56dy90RGZ1ZHR2WEdpamxkd0UyNGM3WFU4Um5oSHF2M1ZlclhMRkRqdHU2ZFA3c2Rka3BITzAxUzA1SnFCaFcvcjh1cC8zU3pHVGE3RzMxMzRzcFBVemNyZHVUeFN6U3FrcFNuTXNaa21ZMmJ1bE5MYjR6OHpmTVhmbVZuemxYMFA4SnRkeXR5bDJEckwxa2ZINnY4WFVKQnIxbFdVRDZlZ3dDeXZPZjkzQlpBcDRaL1QyZVpjKy92a1F6eDdEd1l0VFRoQTcva0pFTkhzVWJ6emxHTURtUlh0cWovNVpJNXJ0eGNscEhLelFEY3c5dWZjLy9jRGlreU5hSVMrc0h4ZStsYnpvclpGaUlIOThXNzBqNDBOc252L1RUUkJJS3FDY3ZuU3NrTDhwTmhYbkdtUlRPQkJnd3dzRWQxczdnUGNrbXhjY0x2TUdEODl4N3hvUFpENUJqLzk4aW9TaytRd3EwK2VMNGZoN3ZoUWgyYkxzWExiMGRqbk9OdG40L2UxZHdJQkIwT25uZlRHUGlEVmhuaURSbkhHbWE1eVNlUmJyKzI2ZVEza3I1bmtFTnljRjFPekxlUkd5RzUwWFl6M3B2QmJUNW5CYlF2clkyWGtJczlhUFpVejN4cTg3cDB0b3JsdVNmTFgxUHgybm1aRG9Hem5GeXVjUDI0QWRVWWNud094NWh2enpGYXZVWVpWcklXdjRJQ01JbVFvUFBmRVByeU1aMmd3MzR6T3JlTGxsNkxOQ2NTaGIrdFppcGlBQnp4YnNJUk44TXAvVElIdkx0RUJCODdMTVU2bWFMZnpIS01iblh3RklNSmdHbXFyS0t0b2dPNEpPRlNqRElLV3lTdm4yT1RvSmtyRWRWbXMzSExwVmtjclNWelIxcFpSSi9Sc0c4WXJieEdLbDM2RVNtdmloMHRSUzFibytqRzQ3ZUFTMFQzcDRqem5mSkx2YlVIWFJGMEJ0YUFsazBCcE5xdzdDY1NWSEpsQWxyUk5MZXpVSkZVMlpzaDIxWUNIVEIxYURzMEQ2ckNySnp1aGFMYWp6eGpKdXR0c3FxUFZqVElKaWxSUjZmRFlTQ1Uwd0phcHY4c09UMFh0ZFJKQWpFWmROaVhGQzNrZHF3Vmc1Q1NrWGJxTi9UbW9qYzdBRHkrbGw5ZTNwbk9hNGV0R2luZXFsSm42R3o5cmVaSDl0RVV4ZStWUTJnTFpYWDlQdThTbnJQVnBxM1NTQ1phTW5yd25HK0RzYksybENkbGUxbFE1cHdyUm9ieXNWVGFRNUZ3ZlYwVVNMRTdDT3lwcFlzSmVkdnF4MklDZk8xMDV0K0dBNUNVMmppZDh1Q3pkeDFpUmtlY1RGbURSSlo1bkRxdExhSVppTm9acHN0NVE2M0tJVlFKa011OGlWRXVBVzdrNmRjeE1EWmM3RlBxZ1NNaS9MbXNPb2ROV29adFEvMGlqTG5uTlRzYXFrNDVBNmVFNkllazhhQWVURnFndFJsOVEvY2dzZ2xVNzZ6VStCTXArZG1xQk1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9hc3NldHMvUm9ib3RvLVJlZ3VsYXIud29mZjJcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzQ5OWM4ODFcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzdHlsdXMtbG9hZGVyIS4vZ2xvYmFsLnN0eWxcIilcbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTM0OTljODgxXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzdHlsdXMtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0xIS4vQXBwLnZ1ZVwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vQXBwLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzQ5OWM4ODFcXFwiLFxcXCJoYXNTY29wZWRcXFwiOnRydWUsXFxcInByZXNlcnZlV2hpdGVzcGFjZVxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRhcmdldFxcXCI6e1xcXCJjaHJvbWVcXFwiOjUyLFxcXCJmaXJlZm94XFxcIjo0OH0sXFxcIm9iamVjdEFzc2lnblxcXCI6XFxcIk9iamVjdC5hc3NpZ25cXFwifX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0FwcC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi0zNDk5Yzg4MVwiLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJHOlxcXFxsdW9iYXRhXFxcXGxpYlxcXFxtYXRjaC1kZXZ0b29sc1xcXFxzcmNcXFxcQXBwLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gQXBwLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0zNDk5Yzg4MVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTM0OTljODgxXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL0FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFidWJsZS1sb2FkZXI/e1xcXCJ0YXJnZXRcXFwiOntcXFwiY2hyb21lXFxcIjo1MixcXFwiZmlyZWZveFxcXCI6NDh9LFxcXCJvYmplY3RBc3NpZ25cXFwiOlxcXCJPYmplY3QuYXNzaWduXFxcIn0hLi9tYXRjaENvbnRlbnQuanNcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTgyZDI2NmI0XFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwicHJlc2VydmVXaGl0ZXNwYWNlXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9fSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vbWF0Y2hDb250ZW50LnZ1ZVwiKSxcbiAgLyogc3R5bGVzICovXG4gIG51bGwsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRzpcXFxcbHVvYmF0YVxcXFxsaWJcXFxcbWF0Y2gtZGV2dG9vbHNcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcbWF0Y2hDb250ZW50XFxcXG1hdGNoQ29udGVudC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIG1hdGNoQ29udGVudC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtODJkMjY2YjRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi04MmQyNjZiNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL21hdGNoQ29udGVudC9tYXRjaENvbnRlbnQudnVlXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWE4NzIwYWY4XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzdHlsdXMtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vYWN0aW9uVGFiLnZ1ZVwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgbnVsbCxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYTg3MjBhZjhcXFwiLFxcXCJoYXNTY29wZWRcXFwiOnRydWUsXFxcInByZXNlcnZlV2hpdGVzcGFjZVxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRhcmdldFxcXCI6e1xcXCJjaHJvbWVcXFwiOjUyLFxcXCJmaXJlZm94XFxcIjo0OH0sXFxcIm9iamVjdEFzc2lnblxcXCI6XFxcIk9iamVjdC5hc3NpZ25cXFwifX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2FjdGlvblRhYi52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi1hODcyMGFmOFwiLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJHOlxcXFxsdW9iYXRhXFxcXGxpYlxcXFxtYXRjaC1kZXZ0b29sc1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxtYXRjaEZpbHRlclxcXFxhY3Rpb25UYWIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBhY3Rpb25UYWIudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWE4NzIwYWY4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtYTg3MjBhZjhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zcmMvY29tcG9uZW50cy9tYXRjaEZpbHRlci9hY3Rpb25UYWIudnVlXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWRhZDA2ZjNjXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzdHlsdXMtbG9hZGVyIS4vbWF0Y2guc3R5bFwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4vbWF0Y2guanNcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWRhZDA2ZjNjXFxcIixcXFwiaGFzU2NvcGVkXFxcIjp0cnVlLFxcXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0YXJnZXRcXFwiOntcXFwiY2hyb21lXFxcIjo1MixcXFwiZmlyZWZveFxcXCI6NDh9LFxcXCJvYmplY3RBc3NpZ25cXFwiOlxcXCJPYmplY3QuYXNzaWduXFxcIn19IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9tYXRjaEZpbHRlci52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi1kYWQwNmYzY1wiLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJHOlxcXFxsdW9iYXRhXFxcXGxpYlxcXFxtYXRjaC1kZXZ0b29sc1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxtYXRjaEZpbHRlclxcXFxtYXRjaEZpbHRlci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIG1hdGNoRmlsdGVyLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1kYWQwNmYzY1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWRhZDA2ZjNjXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvbWF0Y2hGaWx0ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWVjYWFmNWE4XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzdHlsdXMtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vZGF0YUZpZWxkLnZ1ZVwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vZGF0YUZpZWxkLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZWNhYWY1YThcXFwiLFxcXCJoYXNTY29wZWRcXFwiOnRydWUsXFxcInByZXNlcnZlV2hpdGVzcGFjZVxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRhcmdldFxcXCI6e1xcXCJjaHJvbWVcXFwiOjUyLFxcXCJmaXJlZm94XFxcIjo0OH0sXFxcIm9iamVjdEFzc2lnblxcXCI6XFxcIk9iamVjdC5hc3NpZ25cXFwifX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2RhdGFGaWVsZC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi1lY2FhZjVhOFwiLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJHOlxcXFxsdW9iYXRhXFxcXGxpYlxcXFxtYXRjaC1kZXZ0b29sc1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxtYXRjaE9ialxcXFxkYXRhRmllbGQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBkYXRhRmllbGQudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWVjYWFmNWE4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtZWNhYWY1YThcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWUxY2NhMjM0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc3R5bHVzLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL21hdGNoT2JqLnZ1ZVwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4vbWF0Y2hPYmouanNcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWUxY2NhMjM0XFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwicHJlc2VydmVXaGl0ZXNwYWNlXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9fSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vbWF0Y2hPYmoudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRzpcXFxcbHVvYmF0YVxcXFxsaWJcXFxcbWF0Y2gtZGV2dG9vbHNcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcbWF0Y2hPYmpcXFxcbWF0Y2hPYmoudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBtYXRjaE9iai52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZTFjY2EyMzRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1lMWNjYTIzNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL21hdGNoT2JqLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zZDBiMWMyY1xcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc3R5bHVzLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NwbGl0UGFuZS52dWVcIilcbn1cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJ1YmxlLWxvYWRlcj97XFxcInRhcmdldFxcXCI6e1xcXCJjaHJvbWVcXFwiOjUyLFxcXCJmaXJlZm94XFxcIjo0OH0sXFxcIm9iamVjdEFzc2lnblxcXCI6XFxcIk9iamVjdC5hc3NpZ25cXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3NwbGl0UGFuZS52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTNkMGIxYzJjXFxcIixcXFwiaGFzU2NvcGVkXFxcIjp0cnVlLFxcXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0YXJnZXRcXFwiOntcXFwiY2hyb21lXFxcIjo1MixcXFwiZmlyZWZveFxcXCI6NDh9LFxcXCJvYmplY3RBc3NpZ25cXFwiOlxcXCJPYmplY3QuYXNzaWduXFxcIn19IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcGxpdFBhbmUudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgXCJkYXRhLXYtM2QwYjFjMmNcIixcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRzpcXFxcbHVvYmF0YVxcXFxsaWJcXFxcbWF0Y2gtZGV2dG9vbHNcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcc3BsaXRQYW5lXFxcXHNwbGl0UGFuZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHNwbGl0UGFuZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtM2QwYjFjMmNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0zZDBiMWMyY1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL3NwbGl0UGFuZS9zcGxpdFBhbmUudnVlXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBjbGFzczoge1xuICAgICAgYXBwOiB0cnVlLCBkYXJrOiBfdm0uaXNEYXJrXG4gICAgfSxcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcImFwcFwiXG4gICAgfVxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJoZWFkZXJcIlxuICB9LCBbX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibWVzc2FnZS1jb250YWluZXJcIlxuICB9LCBbX2MoJ3RyYW5zaXRpb24nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwibmFtZVwiOiBcInNsaWRlLXVwXCJcbiAgICB9XG4gIH0sIFtfYygnc3BhbicsIHtcbiAgICBrZXk6IF92bS5tZXNzYWdlLFxuICAgIHN0YXRpY0NsYXNzOiBcIm1lc3NhZ2VcIlxuICB9LCBbX3ZtLl92KF92bS5fcyhfdm0ubWVzc2FnZSkpXSldKV0sIDEpLCBfYygnYScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidXR0b24gY29tcG9uZW50c1wiLFxuICAgIGNsYXNzOiB7XG4gICAgICBhY3RpdmU6IF92bS50YWIgPT09ICdtYXRjaCdcbiAgICB9LFxuICAgIGF0dHJzOiB7XG4gICAgICBcInRpdGxlXCI6IFwiU3dpdGNoIHRvIENvbXBvbmVudHNcIlxuICAgIH1cbiAgfSwgW19jKCdpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1hdGVyaWFsLWljb25zXCJcbiAgfSwgW192bS5fdihcImRldmljZV9odWJcIildKSwgX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwicGFuZS1uYW1lXCJcbiAgfSwgW192bS5fdihcIkNvbXBvbmVudHNcIildKV0pLCBfYygnYScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidXR0b24gcmVmcmVzaFwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInRpdGxlXCI6IFwiRm9yY2UgUmVmcmVzaFwiXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0ucmVmcmVzaFxuICAgIH1cbiAgfSwgW19jKCdpJywge1xuICAgIHJlZjogXCJyZWZyZXNoXCIsXG4gICAgc3RhdGljQ2xhc3M6IFwibWF0ZXJpYWwtaWNvbnNcIlxuICB9LCBbX3ZtLl92KFwicmVmcmVzaFwiKV0pLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJwYW5lLW5hbWVcIlxuICB9LCBbX3ZtLl92KFwiUmVmcmVzaFwiKV0pXSksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImFjdGl2ZS1iYXJcIlxuICB9KV0pLCBfYygnbWF0Y2gnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udGFpbmVyXCJcbiAgfSldLCAxKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi0zNDk5Yzg4MVwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zNDk5Yzg4MVwiLFwiaGFzU2NvcGVkXCI6dHJ1ZSxcInByZXNlcnZlV2hpdGVzcGFjZVwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0YXJnZXRcIjp7XCJjaHJvbWVcIjo1MixcImZpcmVmb3hcIjo0OH0sXCJvYmplY3RBc3NpZ25cIjpcIk9iamVjdC5hc3NpZ25cIn19IS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4uL3NyYy9BcHAudnVlXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzcGxpdC1wYW5lXCIsXG4gICAgY2xhc3M6IHtcbiAgICAgIGRyYWdnaW5nOiBfdm0uZHJhZ2dpbmdcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcIm1vdXNlbW92ZVwiOiBfdm0uZHJhZ01vdmUsXG4gICAgICBcIm1vdXNldXBcIjogX3ZtLmRyYWdFbmQsXG4gICAgICBcIm1vdXNlbGVhdmVcIjogX3ZtLmRyYWdFbmRcbiAgICB9XG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImxlZnRcIixcbiAgICBzdHlsZTogKHtcbiAgICAgIHdpZHRoOiBfdm0uc3BsaXQgKyAnJSdcbiAgICB9KVxuICB9LCBbX3ZtLl90KFwibGVmdFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJkcmFnZ2VyXCIsXG4gICAgb246IHtcbiAgICAgIFwibW91c2Vkb3duXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3ZtLmRyYWdTdGFydCgkZXZlbnQpXG4gICAgICB9XG4gICAgfVxuICB9KV0sIDIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInJpZ2h0XCIsXG4gICAgc3R5bGU6ICh7XG4gICAgICB3aWR0aDogKDEwMCAtIF92bS5zcGxpdCkgKyAnJSdcbiAgICB9KVxuICB9LCBbX3ZtLl90KFwicmlnaHRcIildLCAyKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTNkMGIxYzJjXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTNkMGIxYzJjXCIsXCJoYXNTY29wZWRcIjp0cnVlLFwicHJlc2VydmVXaGl0ZXNwYWNlXCI6ZmFsc2UsXCJidWJsZVwiOntcInRhcmdldFwiOntcImNocm9tZVwiOjUyLFwiZmlyZWZveFwiOjQ4fSxcIm9iamVjdEFzc2lnblwiOlwiT2JqZWN0LmFzc2lnblwifX0hLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvc3BsaXRQYW5lL3NwbGl0UGFuZS52dWVcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2JywgW19jKCdzcGxpdC1wYW5lJywgW19jKCdtYXRjaC1maWx0ZXInLCB7XG4gICAgc2xvdDogXCJsZWZ0XCJcbiAgfSksIF9jKCdtYXRjaC1vYmonLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwic3RhY2tzXCI6IF92bS5tYXRjaEFyclxuICAgIH0sXG4gICAgc2xvdDogXCJyaWdodFwiXG4gIH0pXSwgMSldLCAxKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi04MmQyNjZiNFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi04MmQyNjZiNFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIjpmYWxzZSxcImJ1YmxlXCI6e1widGFyZ2V0XCI6e1wiY2hyb21lXCI6NTIsXCJmaXJlZm94XCI6NDh9LFwib2JqZWN0QXNzaWduXCI6XCJPYmplY3QuYXNzaWduXCJ9fSEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9tYXRjaENvbnRlbnQvbWF0Y2hDb250ZW50LnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYWN0aW9uLWhlYWRlclwiXG4gIH0sIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwgMilcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtYTg3MjBhZjhcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYTg3MjBhZjhcIixcImhhc1Njb3BlZFwiOnRydWUsXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIjpmYWxzZSxcImJ1YmxlXCI6e1widGFyZ2V0XCI6e1wiY2hyb21lXCI6NTIsXCJmaXJlZm94XCI6NDh9LFwib2JqZWN0QXNzaWduXCI6XCJPYmplY3QuYXNzaWduXCJ9fSEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9tYXRjaEZpbHRlci9hY3Rpb25UYWIudnVlXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtYXRjaFwiXG4gIH0sIFtfYygnYWN0aW9uLWhlYWRlcicsIHtcbiAgICBzbG90OiBcImhlYWRlclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInNlYXJjaFwiXG4gIH0sIFtfYygnaScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtYXRlcmlhbC1pY29uc1wiXG4gIH0sIFtfdm0uX3YoXCJzZWFyY2hcIildKSwgX2MoJ2lucHV0Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInBsYWNlaG9sZGVyXCI6IFwiRmlsdGVyIGNvbXBvbmVudHNcIlxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiaW5wdXRcIjogX3ZtLmZpbHRlclN0YWNrc1xuICAgIH1cbiAgfSldKV0pLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1hdGNoQXJyc1wiXG4gIH0sIFtfYygndWwnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYXJyLWNvbnRlbnRcIlxuICB9LCBfdm0uX2woKF92bS5tYXRjaEFyciksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gX2MoJ2xpJywge1xuICAgICAgY2xhc3M6IFsnYXJyLWl0ZW1zJywge1xuICAgICAgICAnYWN0aXZlJzogX3ZtLmFjdGl2ZUl0ZW0gPT09IGl0ZW1cbiAgICAgIH1dLFxuICAgICAgb246IHtcbiAgICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICBfdm0uY2hvb3NlSXRlbShpdGVtKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW192bS5fdihcIlxcbiAgICAgICAgICAgICAgICBcIiArIF92bS5fcyhpdGVtLnVybCkgKyBcIlxcbiAgICAgICAgICAgIFwiKV0pXG4gIH0pKV0pXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtZGFkMDZmM2NcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZGFkMDZmM2NcIixcImhhc1Njb3BlZFwiOnRydWUsXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIjpmYWxzZSxcImJ1YmxlXCI6e1widGFyZ2V0XCI6e1wiY2hyb21lXCI6NTIsXCJmaXJlZm94XCI6NDh9LFwib2JqZWN0QXNzaWduXCI6XCJPYmplY3QuYXNzaWduXCJ9fSEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9tYXRjaEZpbHRlci9tYXRjaEZpbHRlci52dWVcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImRhdGEtd3JhcGVyXCJcbiAgfSwgX3ZtLl9sKChfdm0uc3RhY2tzKSwgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZGF0YS1maWVsZHNcIlxuICAgIH0sIFtfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZGF0YS10eXBlXCJcbiAgICB9LCBbX3ZtLl92KFwiYmVmb3JlUGFyYW1zXCIpXSksIChBcnJheS5pc0FycmF5KGl0ZW0uYmVmb3JlUGFyYW1zKSkgPyBfdm0uX2woKGl0ZW0uYmVmb3JlUGFyYW1zKSwgZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgIHJldHVybiBfYygnZGF0YS1maWVsZCcsIHtcbiAgICAgICAga2V5OiBmaWVsZCxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBcImZpZWxkXCI6IGZpZWxkLFxuICAgICAgICAgIFwiZGVwdGhcIjogMFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pIDogX3ZtLl9sKChpdGVtLmJlZm9yZVBhcmFtcyksIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJldHVybiBfYygnZGF0YS1maWVsZCcsIHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgXCJmaWVsZFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZXB0aFwiOiAwXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSksIF9jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJkYXRhLXR5cGVcIlxuICAgIH0sIFtfdm0uX3YoXCJhZnRlclBhcmFtc1wiKV0pLCAoQXJyYXkuaXNBcnJheShpdGVtLmFmdGVyUGFyYW1zKSkgPyBfdm0uX2woKGl0ZW0uYWZ0ZXJQYXJhbXMpLCBmdW5jdGlvbihmaWVsZCkge1xuICAgICAgcmV0dXJuIF9jKCdkYXRhLWZpZWxkJywge1xuICAgICAgICBrZXk6IGZpZWxkLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIFwiZmllbGRcIjogZmllbGQsXG4gICAgICAgICAgXCJkZXB0aFwiOiAwXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSkgOiBfdm0uX2woKGl0ZW0uYWZ0ZXJQYXJhbXMpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXR1cm4gX2MoJ2RhdGEtZmllbGQnLCB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIFwiZmllbGRcIjoge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVwdGhcIjogMFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXSwgMilcbiAgfSkpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LWUxY2NhMjM0XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWUxY2NhMjM0XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcInByZXNlcnZlV2hpdGVzcGFjZVwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0YXJnZXRcIjp7XCJjaHJvbWVcIjo1MixcImZpcmVmb3hcIjo0OH0sXCJvYmplY3RBc3NpZ25cIjpcIk9iamVjdC5hc3NpZ25cIn19IS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL21hdGNoT2JqLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZGF0YS1maWVsZFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInNlbGZcIixcbiAgICBzdHlsZTogKHtcbiAgICAgIG1hcmdpbkxlZnQ6IF92bS5kZXB0aCAqIDE0ICsgJ3B4J1xuICAgIH0pLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS50b2dnbGVcbiAgICB9XG4gIH0sIFtfYygnc3BhbicsIHtcbiAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgbmFtZTogXCJzaG93XCIsXG4gICAgICByYXdOYW1lOiBcInYtc2hvd1wiLFxuICAgICAgdmFsdWU6IChfdm0uaXNFeHBhbmRhYmxlVHlwZSksXG4gICAgICBleHByZXNzaW9uOiBcImlzRXhwYW5kYWJsZVR5cGVcIlxuICAgIH1dLFxuICAgIHN0YXRpY0NsYXNzOiBcImFycm93IHJpZ2h0XCIsXG4gICAgY2xhc3M6IHtcbiAgICAgIHJvdGF0ZWQ6IF92bS5leHBhbmRlZFxuICAgIH1cbiAgfSksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImtleVwiXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5maWVsZC5rZXkpKV0pLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb2xvblwiXG4gIH0sIFtfdm0uX3YoXCI6XCIpLCAoX3ZtLmZpZWxkLm1ldGEpID8gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtZXRhXCJcbiAgfSwgX3ZtLl9sKChfdm0uZmllbGQubWV0YSksIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJtZXRhLWZpZWxkXCJcbiAgICB9LCBbX2MoJ3NwYW4nLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJrZXlcIlxuICAgIH0sIFtfdm0uX3YoX3ZtLl9zKGtleSkpXSksIF9jKCdzcGFuJywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwidmFsdWVcIlxuICAgIH0sIFtfdm0uX3YoX3ZtLl9zKHZhbCkpXSldKVxuICB9KSkgOiBfdm0uX2UoKV0pLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJ2YWx1ZVwiLFxuICAgIGNsYXNzOiBfdm0udmFsdWVUeXBlXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5mb3JtYXR0ZWRWYWx1ZSkpXSldKSwgKF92bS5leHBhbmRlZCAmJiBfdm0uaXNFeHBhbmRhYmxlVHlwZSkgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNoaWxkcmVuXCJcbiAgfSwgW192bS5fbCgoX3ZtLmxpbWl0ZWRTdWJGaWVsZHMpLCBmdW5jdGlvbihzdWJGaWVsZCkge1xuICAgIHJldHVybiBfYygnZGF0YS1maWVsZCcsIHtcbiAgICAgIGtleTogc3ViRmllbGQua2V5LFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJmaWVsZFwiOiBzdWJGaWVsZCxcbiAgICAgICAgXCJkZXB0aFwiOiBfdm0uZGVwdGggKyAxXG4gICAgICB9XG4gICAgfSlcbiAgfSksIChfdm0uZm9ybWF0dGVkU3ViRmllbGRzLmxlbmd0aCA+IF92bS5saW1pdCkgPyBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb3JlXCIsXG4gICAgc3R5bGU6ICh7XG4gICAgICBtYXJnaW5MZWZ0OiAoX3ZtLmRlcHRoICsgMSkgKiAxNCArIDEwICsgJ3B4J1xuICAgIH0pLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0ubGltaXQgKz0gMTBcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJcXG4gICAgICAuLi5cXG4gICAgXCIpXSkgOiBfdm0uX2UoKV0sIDIpIDogX3ZtLl9lKCldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi1lY2FhZjVhOFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1lY2FhZjVhOFwiLFwiaGFzU2NvcGVkXCI6dHJ1ZSxcInByZXNlcnZlV2hpdGVzcGFjZVwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0YXJnZXRcIjp7XCJjaHJvbWVcIjo1MixcImZpcmVmb3hcIjo0OH0sXCJvYmplY3RBc3NpZ25cIjpcIk9iamVjdC5hc3NpZ25cIn19IS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL2RhdGFGaWVsZC52dWVcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zNDk5Yzg4MVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4vZ2xvYmFsLnN0eWxcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcImRiYWM2MTY4XCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTM0OTljODgxXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi9nbG9iYWwuc3R5bFwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zNDk5Yzg4MVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4vZ2xvYmFsLnN0eWxcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlciEuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMzQ5OWM4ODFcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc3R5bHVzLWxvYWRlciEuLi9zcmMvZ2xvYmFsLnN0eWxcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zNDk5Yzg4MVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTEhLi9BcHAudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI1MTllZjEzMVwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zNDk5Yzg4MVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTEhLi9BcHAudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTM0OTljODgxXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MSEuL0FwcC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlciEuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMzQ5OWM4ODFcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zdHlsdXMtbG9hZGVyIS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MSEuLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNkMGIxYzJjXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NwbGl0UGFuZS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjNkZWFiY2IwXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNkMGIxYzJjXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NwbGl0UGFuZS52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2QwYjFjMmNcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3BsaXRQYW5lLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zZDBiMWMyY1wiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3N0eWx1cy1sb2FkZXIhLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL3NwbGl0UGFuZS9zcGxpdFBhbmUudnVlXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYTg3MjBhZjhcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vYWN0aW9uVGFiLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiNDliOGM5M2FcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYTg3MjBhZjhcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vYWN0aW9uVGFiLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1hODcyMGFmOFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9hY3Rpb25UYWIudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LWE4NzIwYWY4XCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc3R5bHVzLWxvYWRlciEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvYWN0aW9uVGFiLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWRhZDA2ZjNjXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuL21hdGNoLnN0eWxcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjc1NDM3MDE5XCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWRhZDA2ZjNjXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuL21hdGNoLnN0eWxcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZGFkMDZmM2NcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4vbWF0Y2guc3R5bFwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1kYWQwNmYzY1wiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3N0eWx1cy1sb2FkZXIhLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hGaWx0ZXIvbWF0Y2guc3R5bFxuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWUxY2NhMjM0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9tYXRjaE9iai52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjBlOThkZTAxXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWUxY2NhMjM0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9tYXRjaE9iai52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZTFjY2EyMzRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL21hdGNoT2JqLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1lMWNjYTIzNFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zdHlsdXMtbG9hZGVyIS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9tYXRjaE9iai52dWVcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lY2FhZjVhOFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9kYXRhRmllbGQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIzMDA0OWY1MFwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lY2FhZjVhOFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9kYXRhRmllbGQudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWVjYWFmNWE4XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2RhdGFGaWVsZC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlciEuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtZWNhYWY1YThcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zdHlsdXMtbG9hZGVyIS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiB2dWV4IHYyLjMuMFxuICogKGMpIDIwMTcgRXZhbiBZb3VcbiAqIEBsaWNlbnNlIE1JVFxuICovXG52YXIgYXBwbHlNaXhpbiA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgdmFyIHZlcnNpb24gPSBOdW1iZXIoVnVlLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG5cbiAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgIHZhciB1c2VzSW5pdCA9IFZ1ZS5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmluZGV4T2YoJ2luaXQnKSA+IC0xO1xuICAgIFZ1ZS5taXhpbih1c2VzSW5pdCA/IHsgaW5pdDogdnVleEluaXQgfSA6IHsgYmVmb3JlQ3JlYXRlOiB2dWV4SW5pdCB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdmVycmlkZSBpbml0IGFuZCBpbmplY3QgdnVleCBpbml0IHByb2NlZHVyZVxuICAgIC8vIGZvciAxLnggYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgdmFyIF9pbml0ID0gVnVlLnByb3RvdHlwZS5faW5pdDtcbiAgICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBvcHRpb25zLmluaXQgPSBvcHRpb25zLmluaXRcbiAgICAgICAgPyBbdnVleEluaXRdLmNvbmNhdChvcHRpb25zLmluaXQpXG4gICAgICAgIDogdnVleEluaXQ7XG4gICAgICBfaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVnVleCBpbml0IGhvb2ssIGluamVjdGVkIGludG8gZWFjaCBpbnN0YW5jZXMgaW5pdCBob29rcyBsaXN0LlxuICAgKi9cblxuICBmdW5jdGlvbiB2dWV4SW5pdCAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIC8vIHN0b3JlIGluamVjdGlvblxuICAgIGlmIChvcHRpb25zLnN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IG9wdGlvbnMuc3RvcmU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC4kc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldnRvb2xIb29rID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbmZ1bmN0aW9uIGRldnRvb2xQbHVnaW4gKHN0b3JlKSB7XG4gIGlmICghZGV2dG9vbEhvb2spIHsgcmV0dXJuIH1cblxuICBzdG9yZS5fZGV2dG9vbEhvb2sgPSBkZXZ0b29sSG9vaztcblxuICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgZGV2dG9vbEhvb2sub24oJ3Z1ZXg6dHJhdmVsLXRvLXN0YXRlJywgZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgfSk7XG5cbiAgc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4Om11dGF0aW9uJywgbXV0YXRpb24sIHN0YXRlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBpdGVtIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogYnkgc2Vjb25kIGFyZ3VtZW50IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHJldHVybiB7Kn1cbiAqL1xuLyoqXG4gKiBEZWVwIGNvcHkgdGhlIGdpdmVuIG9iamVjdCBjb25zaWRlcmluZyBjaXJjdWxhciBzdHJ1Y3R1cmUuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhY2hlcyBhbGwgbmVzdGVkIG9iamVjdHMgYW5kIGl0cyBjb3BpZXMuXG4gKiBJZiBpdCBkZXRlY3RzIGNpcmN1bGFyIHN0cnVjdHVyZSwgdXNlIGNhY2hlZCBjb3B5IHRvIGF2b2lkIGluZmluaXRlIGxvb3AuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY2FjaGVcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuXG4vKipcbiAqIGZvckVhY2ggZm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBmb3JFYWNoVmFsdWUgKG9iaiwgZm4pIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtc2cpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKChcIlt2dWV4XSBcIiArIG1zZykpIH1cbn1cblxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZSAocmF3TW9kdWxlLCBydW50aW1lKSB7XG4gIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fcmF3TW9kdWxlID0gcmF3TW9kdWxlO1xuICB2YXIgcmF3U3RhdGUgPSByYXdNb2R1bGUuc3RhdGU7XG4gIHRoaXMuc3RhdGUgPSAodHlwZW9mIHJhd1N0YXRlID09PSAnZnVuY3Rpb24nID8gcmF3U3RhdGUoKSA6IHJhd1N0YXRlKSB8fCB7fTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgbmFtZXNwYWNlZDoge30gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEubmFtZXNwYWNlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGtleSwgbW9kdWxlKSB7XG4gIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBtb2R1bGU7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5ba2V5XTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZCAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocmF3TW9kdWxlKSB7XG4gIHRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkID0gcmF3TW9kdWxlLm5hbWVzcGFjZWQ7XG4gIGlmIChyYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zID0gcmF3TW9kdWxlLmFjdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zID0gcmF3TW9kdWxlLm11dGF0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycyA9IHJhd01vZHVsZS5nZXR0ZXJzO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIGZvckVhY2hDaGlsZCAoZm4pIHtcbiAgZm9yRWFjaFZhbHVlKHRoaXMuX2NoaWxkcmVuLCBmbik7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hHZXR0ZXIgPSBmdW5jdGlvbiBmb3JFYWNoR2V0dGVyIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQWN0aW9uID0gZnVuY3Rpb24gZm9yRWFjaEFjdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaE11dGF0aW9uID0gZnVuY3Rpb24gZm9yRWFjaE11dGF0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zLCBmbik7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNb2R1bGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG52YXIgTW9kdWxlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIE1vZHVsZUNvbGxlY3Rpb24gKHJhd1Jvb3RNb2R1bGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gcmVnaXN0ZXIgcm9vdCBtb2R1bGUgKFZ1ZXguU3RvcmUgb3B0aW9ucylcbiAgdGhpcy5yb290ID0gbmV3IE1vZHVsZShyYXdSb290TW9kdWxlLCBmYWxzZSk7XG5cbiAgLy8gcmVnaXN0ZXIgYWxsIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdSb290TW9kdWxlLm1vZHVsZXMpIHtcbiAgICBmb3JFYWNoVmFsdWUocmF3Um9vdE1vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3TW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3Rlcihba2V5XSwgcmF3TW9kdWxlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG1vZHVsZSwga2V5KSB7XG4gICAgcmV0dXJuIG1vZHVsZS5nZXRDaGlsZChrZXkpXG4gIH0sIHRoaXMucm9vdClcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE5hbWVzcGFjZSA9IGZ1bmN0aW9uIGdldE5hbWVzcGFjZSAocGF0aCkge1xuICB2YXIgbW9kdWxlID0gdGhpcy5yb290O1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwga2V5KSB7XG4gICAgbW9kdWxlID0gbW9kdWxlLmdldENoaWxkKGtleSk7XG4gICAgcmV0dXJuIG5hbWVzcGFjZSArIChtb2R1bGUubmFtZXNwYWNlZCA/IGtleSArICcvJyA6ICcnKVxuICB9LCAnJylcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSQxIChyYXdSb290TW9kdWxlKSB7XG4gIHVwZGF0ZSh0aGlzLnJvb3QsIHJhd1Jvb3RNb2R1bGUpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlciAocGF0aCwgcmF3TW9kdWxlLCBydW50aW1lKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgaWYgKCBydW50aW1lID09PSB2b2lkIDAgKSBydW50aW1lID0gdHJ1ZTtcblxuICB2YXIgcGFyZW50ID0gdGhpcy5nZXQocGF0aC5zbGljZSgwLCAtMSkpO1xuICB2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZShyYXdNb2R1bGUsIHJ1bnRpbWUpO1xuICBwYXJlbnQuYWRkQ2hpbGQocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBuZXdNb2R1bGUpO1xuXG4gIC8vIHJlZ2lzdGVyIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd0NoaWxkTW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3RlcihwYXRoLmNvbmNhdChrZXkpLCByYXdDaGlsZE1vZHVsZSwgcnVudGltZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghcGFyZW50LmdldENoaWxkKGtleSkucnVudGltZSkgeyByZXR1cm4gfVxuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChrZXkpO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlICh0YXJnZXRNb2R1bGUsIG5ld01vZHVsZSkge1xuICAvLyB1cGRhdGUgdGFyZ2V0IG1vZHVsZVxuICB0YXJnZXRNb2R1bGUudXBkYXRlKG5ld01vZHVsZSk7XG5cbiAgLy8gdXBkYXRlIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChuZXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvciAodmFyIGtleSBpbiBuZXdNb2R1bGUubW9kdWxlcykge1xuICAgICAgaWYgKCF0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJbdnVleF0gdHJ5aW5nIHRvIGFkZCBhIG5ldyBtb2R1bGUgJ1wiICsga2V5ICsgXCInIG9uIGhvdCByZWxvYWRpbmcsIFwiICtcbiAgICAgICAgICAnbWFudWFsIHJlbG9hZCBpcyBuZWVkZWQnXG4gICAgICAgICk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKHRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpLCBuZXdNb2R1bGUubW9kdWxlc1trZXldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFZ1ZTsgLy8gYmluZCBvbiBpbnN0YWxsXG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBhc3NlcnQoVnVlLCBcIm11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLlwiKTtcbiAgYXNzZXJ0KHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJywgXCJ2dWV4IHJlcXVpcmVzIGEgUHJvbWlzZSBwb2x5ZmlsbCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuXG4gIHZhciBzdGF0ZSA9IG9wdGlvbnMuc3RhdGU7IGlmICggc3RhdGUgPT09IHZvaWQgMCApIHN0YXRlID0ge307XG4gIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zOyBpZiAoIHBsdWdpbnMgPT09IHZvaWQgMCApIHBsdWdpbnMgPSBbXTtcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0OyBpZiAoIHN0cmljdCA9PT0gdm9pZCAwICkgc3RyaWN0ID0gZmFsc2U7XG5cbiAgLy8gc3RvcmUgaW50ZXJuYWwgc3RhdGVcbiAgdGhpcy5fY29tbWl0dGluZyA9IGZhbHNlO1xuICB0aGlzLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9tb2R1bGVzID0gbmV3IE1vZHVsZUNvbGxlY3Rpb24ob3B0aW9ucyk7XG4gIHRoaXMuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl93YXRjaGVyVk0gPSBuZXcgVnVlKCk7XG5cbiAgLy8gYmluZCBjb21taXQgYW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgdmFyIHN0b3JlID0gdGhpcztcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcbiAgdmFyIGNvbW1pdCA9IHJlZi5jb21taXQ7XG4gIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiBib3VuZERpc3BhdGNoICh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoLmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQpXG4gIH07XG4gIHRoaXMuY29tbWl0ID0gZnVuY3Rpb24gYm91bmRDb21taXQgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tbWl0LmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpXG4gIH07XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdCk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgdm0sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcmVhY3Rpdml0eVxuICAvLyAoYWxzbyByZWdpc3RlcnMgX3dyYXBwZWRHZXR0ZXJzIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMpXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCBzdGF0ZSk7XG5cbiAgLy8gYXBwbHkgcGx1Z2luc1xuICBwbHVnaW5zLmNvbmNhdChkZXZ0b29sUGx1Z2luKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHsgcmV0dXJuIHBsdWdpbih0aGlzJDEpOyB9KTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHN0YXRlOiB7fSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdm0uX2RhdGEuJCRzdGF0ZVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnN0YXRlLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gIGFzc2VydChmYWxzZSwgXCJVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS5cIik7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0IChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGNvbW1pdFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG4gICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcblxuICB2YXIgbXV0YXRpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICBlbnRyeS5mb3JFYWNoKGZ1bmN0aW9uIGNvbW1pdEl0ZXJhdG9yIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHBheWxvYWQpO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIobXV0YXRpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lsZW50KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbdnVleF0gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlICsgXCIuIFNpbGVudCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gXCIgK1xuICAgICAgJ1VzZSB0aGUgZmlsdGVyIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHZ1ZS1kZXZ0b29scydcbiAgICApO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAoX3R5cGUsIF9wYXlsb2FkKSB7XG4gIC8vIGNoZWNrIG9iamVjdC1zdHlsZSBkaXNwYXRjaFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcblxuICB2YXIgZW50cnkgPSB0aGlzLl9hY3Rpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGVudHJ5Lmxlbmd0aCA+IDFcbiAgICA/IFByb21pc2UuYWxsKGVudHJ5Lm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlcihwYXlsb2FkKTsgfSkpXG4gICAgOiBlbnRyeVswXShwYXlsb2FkKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZSAoZm4pIHtcbiAgdmFyIHN1YnMgPSB0aGlzLl9zdWJzY3JpYmVycztcbiAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgc3Vicy5wdXNoKGZuKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBzdWJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIHdhdGNoIChnZXR0ZXIsIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgYXNzZXJ0KHR5cGVvZiBnZXR0ZXIgPT09ICdmdW5jdGlvbicsIFwic3RvcmUud2F0Y2ggb25seSBhY2NlcHRzIGEgZnVuY3Rpb24uXCIpO1xuICByZXR1cm4gdGhpcy5fd2F0Y2hlclZNLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBnZXR0ZXIodGhpcyQxLnN0YXRlLCB0aGlzJDEuZ2V0dGVycyk7IH0sIGNiLCBvcHRpb25zKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEuX3ZtLl9kYXRhLiQkc3RhdGUgPSBzdGF0ZTtcbiAgfSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZSAocGF0aCwgcmF3TW9kdWxlKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXRoKSwgXCJtb2R1bGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIEFycmF5LlwiKTtcbiAgdGhpcy5fbW9kdWxlcy5yZWdpc3RlcihwYXRoLCByYXdNb2R1bGUpO1xuICBpbnN0YWxsTW9kdWxlKHRoaXMsIHRoaXMuc3RhdGUsIHBhdGgsIHRoaXMuX21vZHVsZXMuZ2V0KHBhdGgpKTtcbiAgLy8gcmVzZXQgc3RvcmUgdG8gdXBkYXRlIGdldHRlcnMuLi5cbiAgcmVzZXRTdG9yZVZNKHRoaXMsIHRoaXMuc3RhdGUpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnVucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTW9kdWxlIChwYXRoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG4gIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB0aGlzLl9tb2R1bGVzLnVucmVnaXN0ZXIocGF0aCk7XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHRoaXMkMS5zdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIFZ1ZS5kZWxldGUocGFyZW50U3RhdGUsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XG4gIH0pO1xuICByZXNldFN0b3JlKHRoaXMpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmhvdFVwZGF0ZSA9IGZ1bmN0aW9uIGhvdFVwZGF0ZSAobmV3T3B0aW9ucykge1xuICB0aGlzLl9tb2R1bGVzLnVwZGF0ZShuZXdPcHRpb25zKTtcbiAgcmVzZXRTdG9yZSh0aGlzLCB0cnVlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5fd2l0aENvbW1pdCA9IGZ1bmN0aW9uIF93aXRoQ29tbWl0IChmbikge1xuICB2YXIgY29tbWl0dGluZyA9IHRoaXMuX2NvbW1pdHRpbmc7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSB0cnVlO1xuICBmbigpO1xuICB0aGlzLl9jb21taXR0aW5nID0gY29tbWl0dGluZztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdG9yZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiByZXNldFN0b3JlIChzdG9yZSwgaG90KSB7XG4gIHN0b3JlLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHN0YXRlID0gc3RvcmUuc3RhdGU7XG4gIC8vIGluaXQgYWxsIG1vZHVsZXNcbiAgaW5zdGFsbE1vZHVsZShzdG9yZSwgc3RhdGUsIFtdLCBzdG9yZS5fbW9kdWxlcy5yb290LCB0cnVlKTtcbiAgLy8gcmVzZXQgdm1cbiAgcmVzZXRTdG9yZVZNKHN0b3JlLCBzdGF0ZSwgaG90KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZVZNIChzdG9yZSwgc3RhdGUsIGhvdCkge1xuICB2YXIgb2xkVm0gPSBzdG9yZS5fdm07XG5cbiAgLy8gYmluZCBzdG9yZSBwdWJsaWMgZ2V0dGVyc1xuICBzdG9yZS5nZXR0ZXJzID0ge307XG4gIHZhciB3cmFwcGVkR2V0dGVycyA9IHN0b3JlLl93cmFwcGVkR2V0dGVycztcbiAgdmFyIGNvbXB1dGVkID0ge307XG4gIGZvckVhY2hWYWx1ZSh3cmFwcGVkR2V0dGVycywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAvLyB1c2UgY29tcHV0ZWQgdG8gbGV2ZXJhZ2UgaXRzIGxhenktY2FjaGluZyBtZWNoYW5pc21cbiAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4oc3RvcmUpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yZS5nZXR0ZXJzLCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuX3ZtW2tleV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlIC8vIGZvciBsb2NhbCBnZXR0ZXJzXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHVzZSBhIFZ1ZSBpbnN0YW5jZSB0byBzdG9yZSB0aGUgc3RhdGUgdHJlZVxuICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBqdXN0IGluIGNhc2UgdGhlIHVzZXIgaGFzIGFkZGVkXG4gIC8vIHNvbWUgZnVua3kgZ2xvYmFsIG1peGluc1xuICB2YXIgc2lsZW50ID0gVnVlLmNvbmZpZy5zaWxlbnQ7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gdHJ1ZTtcbiAgc3RvcmUuX3ZtID0gbmV3IFZ1ZSh7XG4gICAgZGF0YToge1xuICAgICAgJCRzdGF0ZTogc3RhdGVcbiAgICB9LFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZFxuICB9KTtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSBzaWxlbnQ7XG5cbiAgLy8gZW5hYmxlIHN0cmljdCBtb2RlIGZvciBuZXcgdm1cbiAgaWYgKHN0b3JlLnN0cmljdCkge1xuICAgIGVuYWJsZVN0cmljdE1vZGUoc3RvcmUpO1xuICB9XG5cbiAgaWYgKG9sZFZtKSB7XG4gICAgaWYgKGhvdCkge1xuICAgICAgLy8gZGlzcGF0Y2ggY2hhbmdlcyBpbiBhbGwgc3Vic2NyaWJlZCB3YXRjaGVyc1xuICAgICAgLy8gdG8gZm9yY2UgZ2V0dGVyIHJlLWV2YWx1YXRpb24gZm9yIGhvdCByZWxvYWRpbmcuXG4gICAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9sZFZtLl9kYXRhLiQkc3RhdGUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFZ1ZS5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiBvbGRWbS4kZGVzdHJveSgpOyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsTW9kdWxlIChzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLCBtb2R1bGUsIGhvdCkge1xuICB2YXIgaXNSb290ID0gIXBhdGgubGVuZ3RoO1xuICB2YXIgbmFtZXNwYWNlID0gc3RvcmUuX21vZHVsZXMuZ2V0TmFtZXNwYWNlKHBhdGgpO1xuXG4gIC8vIHJlZ2lzdGVyIGluIG5hbWVzcGFjZSBtYXBcbiAgaWYgKG1vZHVsZS5uYW1lc3BhY2VkKSB7XG4gICAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSA9IG1vZHVsZTtcbiAgfVxuXG4gIC8vIHNldCBzdGF0ZVxuICBpZiAoIWlzUm9vdCAmJiAhaG90KSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUocm9vdFN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgdmFyIG1vZHVsZU5hbWUgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgVnVlLnNldChwYXJlbnRTdGF0ZSwgbW9kdWxlTmFtZSwgbW9kdWxlLnN0YXRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsb2NhbCA9IG1vZHVsZS5jb250ZXh0ID0gbWFrZUxvY2FsQ29udGV4dChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKTtcblxuICBtb2R1bGUuZm9yRWFjaE11dGF0aW9uKGZ1bmN0aW9uIChtdXRhdGlvbiwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyTXV0YXRpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBtdXRhdGlvbiwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJBY3Rpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBhY3Rpb24sIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hHZXR0ZXIoZnVuY3Rpb24gKGdldHRlciwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyR2V0dGVyKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgZ2V0dGVyLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBrZXkpIHtcbiAgICBpbnN0YWxsTW9kdWxlKHN0b3JlLCByb290U3RhdGUsIHBhdGguY29uY2F0KGtleSksIGNoaWxkLCBob3QpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBtYWtlIGxvY2FsaXplZCBkaXNwYXRjaCwgY29tbWl0LCBnZXR0ZXJzIGFuZCBzdGF0ZVxuICogaWYgdGhlcmUgaXMgbm8gbmFtZXNwYWNlLCBqdXN0IHVzZSByb290IG9uZXNcbiAqL1xuZnVuY3Rpb24gbWFrZUxvY2FsQ29udGV4dCAoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCkge1xuICB2YXIgbm9OYW1lc3BhY2UgPSBuYW1lc3BhY2UgPT09ICcnO1xuXG4gIHZhciBsb2NhbCA9IHtcbiAgICBkaXNwYXRjaDogbm9OYW1lc3BhY2UgPyBzdG9yZS5kaXNwYXRjaCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAoIXN0b3JlLl9hY3Rpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBhY3Rpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKHR5cGUsIHBheWxvYWQpXG4gICAgfSxcblxuICAgIGNvbW1pdDogbm9OYW1lc3BhY2UgPyBzdG9yZS5jb21taXQgOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKCFzdG9yZS5fbXV0YXRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBtdXRhdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9yZS5jb21taXQodHlwZSwgcGF5bG9hZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHRlcnMgYW5kIHN0YXRlIG9iamVjdCBtdXN0IGJlIGdvdHRlbiBsYXppbHlcbiAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgY2hhbmdlZCBieSB2bSB1cGRhdGVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobG9jYWwsIHtcbiAgICBnZXR0ZXJzOiB7XG4gICAgICBnZXQ6IG5vTmFtZXNwYWNlXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyczsgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VMb2NhbEdldHRlcnMoc3RvcmUsIG5hbWVzcGFjZSk7IH1cbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldE5lc3RlZFN0YXRlKHN0b3JlLnN0YXRlLCBwYXRoKTsgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxvY2FsXG59XG5cbmZ1bmN0aW9uIG1ha2VMb2NhbEdldHRlcnMgKHN0b3JlLCBuYW1lc3BhY2UpIHtcbiAgdmFyIGdldHRlcnNQcm94eSA9IHt9O1xuXG4gIHZhciBzcGxpdFBvcyA9IG5hbWVzcGFjZS5sZW5ndGg7XG4gIE9iamVjdC5rZXlzKHN0b3JlLmdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvLyBza2lwIGlmIHRoZSB0YXJnZXQgZ2V0dGVyIGlzIG5vdCBtYXRjaCB0aGlzIG5hbWVzcGFjZVxuICAgIGlmICh0eXBlLnNsaWNlKDAsIHNwbGl0UG9zKSAhPT0gbmFtZXNwYWNlKSB7IHJldHVybiB9XG5cbiAgICAvLyBleHRyYWN0IGxvY2FsIGdldHRlciB0eXBlXG4gICAgdmFyIGxvY2FsVHlwZSA9IHR5cGUuc2xpY2Uoc3BsaXRQb3MpO1xuXG4gICAgLy8gQWRkIGEgcG9ydCB0byB0aGUgZ2V0dGVycyBwcm94eS5cbiAgICAvLyBEZWZpbmUgYXMgZ2V0dGVyIHByb3BlcnR5IGJlY2F1c2VcbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBldmFsdWF0ZSB0aGUgZ2V0dGVycyBpbiB0aGlzIHRpbWUuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldHRlcnNQcm94eSwgbG9jYWxUeXBlLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLmdldHRlcnNbdHlwZV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBnZXR0ZXJzUHJveHlcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gfHwgKHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZE11dGF0aW9uSGFuZGxlciAocGF5bG9hZCkge1xuICAgIGhhbmRsZXIobG9jYWwuc3RhdGUsIHBheWxvYWQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24gKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fYWN0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX2FjdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZEFjdGlvbkhhbmRsZXIgKHBheWxvYWQsIGNiKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIoe1xuICAgICAgZGlzcGF0Y2g6IGxvY2FsLmRpc3BhdGNoLFxuICAgICAgY29tbWl0OiBsb2NhbC5jb21taXQsXG4gICAgICBnZXR0ZXJzOiBsb2NhbC5nZXR0ZXJzLFxuICAgICAgc3RhdGU6IGxvY2FsLnN0YXRlLFxuICAgICAgcm9vdEdldHRlcnM6IHN0b3JlLmdldHRlcnMsXG4gICAgICByb290U3RhdGU6IHN0b3JlLnN0YXRlXG4gICAgfSwgcGF5bG9hZCwgY2IpO1xuICAgIGlmICghaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcyA9IFByb21pc2UucmVzb2x2ZShyZXMpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuX2RldnRvb2xIb29rKSB7XG4gICAgICByZXR1cm4gcmVzLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc3RvcmUuX2RldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6ZXJyb3InLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckdldHRlciAoc3RvcmUsIHR5cGUsIHJhd0dldHRlciwgbG9jYWwpIHtcbiAgaWYgKHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSkge1xuICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBnZXR0ZXIga2V5OiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICBzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0gPSBmdW5jdGlvbiB3cmFwcGVkR2V0dGVyIChzdG9yZSkge1xuICAgIHJldHVybiByYXdHZXR0ZXIoXG4gICAgICBsb2NhbC5zdGF0ZSwgLy8gbG9jYWwgc3RhdGVcbiAgICAgIGxvY2FsLmdldHRlcnMsIC8vIGxvY2FsIGdldHRlcnNcbiAgICAgIHN0b3JlLnN0YXRlLCAvLyByb290IHN0YXRlXG4gICAgICBzdG9yZS5nZXR0ZXJzIC8vIHJvb3QgZ2V0dGVyc1xuICAgIClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlU3RyaWN0TW9kZSAoc3RvcmUpIHtcbiAgc3RvcmUuX3ZtLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhLiQkc3RhdGUgfSwgZnVuY3Rpb24gKCkge1xuICAgIGFzc2VydChzdG9yZS5fY29tbWl0dGluZywgXCJEbyBub3QgbXV0YXRlIHZ1ZXggc3RvcmUgc3RhdGUgb3V0c2lkZSBtdXRhdGlvbiBoYW5kbGVycy5cIik7XG4gIH0sIHsgZGVlcDogdHJ1ZSwgc3luYzogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmVzdGVkU3RhdGUgKHN0YXRlLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aFxuICAgID8gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCBrZXkpIHsgcmV0dXJuIHN0YXRlW2tleV07IH0sIHN0YXRlKVxuICAgIDogc3RhdGVcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycsIChcIkV4cGVjdHMgc3RyaW5nIGFzIHRoZSB0eXBlLCBidXQgZm91bmQgXCIgKyAodHlwZW9mIHR5cGUpICsgXCIuXCIpKTtcblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkLCBvcHRpb25zOiBvcHRpb25zIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbCAoX1Z1ZSkge1xuICBpZiAoVnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgICdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgVnVlID0gX1Z1ZTtcbiAgYXBwbHlNaXhpbihWdWUpO1xufVxuXG4vLyBhdXRvIGluc3RhbGwgaW4gZGlzdCBtb2RlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xufVxuXG52YXIgbWFwU3RhdGUgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgc3RhdGVzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKHN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZFN0YXRlICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHN0b3JlLnN0YXRlO1xuICAgICAgdmFyIGdldHRlcnMgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBTdGF0ZScsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBtb2R1bGUuY29udGV4dC5zdGF0ZTtcbiAgICAgICAgZ2V0dGVycyA9IG1vZHVsZS5jb250ZXh0LmdldHRlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5jYWxsKHRoaXMsIHN0YXRlLCBnZXR0ZXJzKVxuICAgICAgICA6IHN0YXRlW3ZhbF1cbiAgICB9O1xuICAgIC8vIG1hcmsgdnVleCBnZXR0ZXIgZm9yIGRldnRvb2xzXG4gICAgcmVzW2tleV0udnVleCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIG1hcE11dGF0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBtdXRhdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAobXV0YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHZhbCA9IG5hbWVzcGFjZSArIHZhbDtcbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZE11dGF0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcE11dGF0aW9ucycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuY29tbWl0LmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwR2V0dGVycyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBnZXR0ZXJzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkR2V0dGVyICgpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwR2V0dGVycycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoISh2YWwgaW4gdGhpcy4kc3RvcmUuZ2V0dGVycykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBnZXR0ZXI6IFwiICsgdmFsKSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwQWN0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBhY3Rpb25zKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkQWN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEFjdGlvbnMnLCBuYW1lc3BhY2UpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmRpc3BhdGNoLmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG5mdW5jdGlvbiBub3JtYWxpemVNYXAgKG1hcCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXApXG4gICAgPyBtYXAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IGtleSB9KTsgfSlcbiAgICA6IE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IG1hcFtrZXldIH0pOyB9KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lc3BhY2UgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZXNwYWNlLCBtYXApIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcCA9IG5hbWVzcGFjZTtcbiAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGZuKG5hbWVzcGFjZSwgbWFwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZUJ5TmFtZXNwYWNlIChzdG9yZSwgaGVscGVyLCBuYW1lc3BhY2UpIHtcbiAgdmFyIG1vZHVsZSA9IHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV07XG4gIGlmICghbW9kdWxlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gbW9kdWxlIG5hbWVzcGFjZSBub3QgZm91bmQgaW4gXCIgKyBoZWxwZXIgKyBcIigpOiBcIiArIG5hbWVzcGFjZSkpO1xuICB9XG4gIHJldHVybiBtb2R1bGVcbn1cblxudmFyIGluZGV4X2VzbSA9IHtcbiAgU3RvcmU6IFN0b3JlLFxuICBpbnN0YWxsOiBpbnN0YWxsLFxuICB2ZXJzaW9uOiAnMi4zLjAnLFxuICBtYXBTdGF0ZTogbWFwU3RhdGUsXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLFxuICBtYXBHZXR0ZXJzOiBtYXBHZXR0ZXJzLFxuICBtYXBBY3Rpb25zOiBtYXBBY3Rpb25zXG59O1xuXG5leHBvcnQgeyBTdG9yZSwgbWFwU3RhdGUsIG1hcE11dGF0aW9ucywgbWFwR2V0dGVycywgbWFwQWN0aW9ucyB9O2V4cG9ydCBkZWZhdWx0IGluZGV4X2VzbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVleC9kaXN0L3Z1ZXguZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=