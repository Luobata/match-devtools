/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 12);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function() {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		var result = [];
		for(var i = 0; i < this.length; i++) {
			var item = this[i];
			if(item[2]) {
				result.push("@media " + item[2] + "{" + item[1] + "}");
			} else {
				result.push(item[1]);
			}
		}
		return result.join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate
    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(53)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_events__);


class Bridge extends __WEBPACK_IMPORTED_MODULE_0_events__["EventEmitter"] {
  constructor (wall) {
    super()
    // Setting `this` to `self` here to fix an error in the Safari build:
    // ReferenceError: Cannot access uninitialized variable.
    // The error might be related to the webkit bug here:
    // https://bugs.webkit.org/show_bug.cgi?id=171543
    const self = this
    self.setMaxListeners(Infinity)
    self.wall = wall
    wall.listen(message => {
      if (typeof message === 'string') {
        self.emit(message)
      } else {
        self.emit(message.event, message.payload)
      }
    })
  }

  /**
   * Send an event.
   *
   * @param {String} event
   * @param {*} payload
   */

  send (event, payload) {
    this.wall.send({
      event,
      payload
    })
  }

  /**
   * Log a message to the devtools background page.
   *
   * @param {String} message
   */

  log (message) {
    this.send('log', message)
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Bridge;



/***/ }),
/* 4 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(49)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(20),
  /* template */
  __webpack_require__(42),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-d6fa3eb4",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\matchTab\\matchTab.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] matchTab.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-d6fa3eb4", Component.options)
  } else {
    hotAPI.reload("data-v-d6fa3eb4", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 6 */,
/* 7 */,
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = initDevTools;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__App_vue__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__App_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__App_vue__);




function initDevTools (shell) {
    initUi(shell);
};

function initUi (shell) {
    let app = null;

    shell.connect(bridge => {
        window.MATCHBRIDGE = bridge;
    });

    app = new __WEBPACK_IMPORTED_MODULE_0_vue__["a" /* default */]({
        render (h) {
            return h(__WEBPACK_IMPORTED_MODULE_1__App_vue___default.a);
        }
    }).$mount('#app');
};


/***/ }),
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_SRC_index__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_SRC_bridge__ = __webpack_require__(3);



/*
 * Inject backend.js connec to background, and send back the bridge.
 *
 * @param {Function} cb
 */

__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_SRC_index__["a" /* initDevTools */])({
    connect (cb) {
        // inject backend.js
        injectScript(chrome.runtime.getURL('build/backend.js'), () => {
            // connect to background
            const port = chrome.runtime.connect({
                name: '' + chrome.devtools.inspectedWindow.tabId
            });

            const bridge = new __WEBPACK_IMPORTED_MODULE_1_SRC_bridge__["a" /* default */]({
                listen (fn) {
                    port.onMessage.addListener(fn);
                },
                send (data) {
                    console.log(port);
                    port.postMessage(data);
                }
            });

            // send back bridge
            cb(bridge);
        });
    }
});

function injectScript (scriptName, cb) {
  const src = `
        var script = document.constructor.prototype.createElement.call(document, 'script');
        script.src = "${scriptName}";
        document.documentElement.appendChild(script);
        script.parentNode.removeChild(script);
  `;

  chrome.devtools.inspectedWindow.eval(src, function (res, err) {
      if (err) {
          console.log(err);
      }
      cb();
  });
};


/***/ }),
/* 13 */,
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export inDoc */
/* unused harmony export stringify */
/* unused harmony export parse */
/* harmony export (immutable) */ __webpack_exports__["d"] = isPlainObject;
/* unused harmony export searchDeepInObject */
/* harmony export (immutable) */ __webpack_exports__["e"] = sortByKey;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_circular_json_es6__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_circular_json_es6___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_circular_json_es6__);


function cached (fn) {
  const cache = Object.create(null)
  return function cachedFn (str) {
    const hit = cache[str]
    return hit || (cache[str] = fn(str))
  }
}

var classifyRE = /(?:^|[-_/])(\w)/g
const classify = cached((str) => {
  return str.replace(classifyRE, toUpper)
})
/* unused harmony export classify */


const camelizeRE = /-(\w)/g
const camelize = cached((str) => {
  return str.replace(camelizeRE, toUpper)
})
/* unused harmony export camelize */


function toUpper (_, c) {
  return c ? c.toUpperCase() : ''
}

function inDoc (node) {
  if (!node) { return false }
  var doc = node.ownerDocument.documentElement
  var parent = node.parentNode
  return doc === node ||
    doc === parent ||
    !!(parent && parent.nodeType === 1 && (doc.contains(parent)))
}

/**
 * Stringify/parse data using CircularJSON.
 */

const UNDEFINED = '__vue_devtool_undefined__'
/* harmony export (immutable) */ __webpack_exports__["a"] = UNDEFINED;

const INFINITY = '__vue_devtool_infinity__'
/* harmony export (immutable) */ __webpack_exports__["b"] = INFINITY;

const NAN = '__vue_devtool_nan__'
/* harmony export (immutable) */ __webpack_exports__["c"] = NAN;


function stringify (data) {
  return __WEBPACK_IMPORTED_MODULE_0_circular_json_es6___default.a.stringify(data, replacer)
}

function replacer (key, val) {
  if (val === undefined) {
    return UNDEFINED
  } else if (val === Infinity) {
    return INFINITY
  } else if (Number.isNaN(val)) {
    return NAN
  } else if (val instanceof RegExp) {
    // special handling of native type
    return `[native RegExp ${val.toString()}]`
  } else {
    return sanitize(val)
  }
}

function parse (data, revive) {
  return revive
    ? __WEBPACK_IMPORTED_MODULE_0_circular_json_es6___default.a.parse(data, reviver)
    : __WEBPACK_IMPORTED_MODULE_0_circular_json_es6___default.a.parse(data)
}

function reviver (key, val) {
  if (val === UNDEFINED) {
    return undefined
  } else if (val === INFINITY) {
    return Infinity
  } else if (val === NAN) {
    return NaN
  } else {
    return val
  }
}

/**
 * Sanitize data to be posted to the other side.
 * Since the message posted is sent with structured clone,
 * we need to filter out any types that might cause an error.
 *
 * @param {*} data
 * @return {*}
 */

function sanitize (data) {
  if (
    !isPrimitive(data) &&
    !Array.isArray(data) &&
    !isPlainObject(data)
  ) {
    // handle types that will probably cause issues in
    // the structured clone
    return Object.prototype.toString.call(data)
  } else {
    return data
  }
}

function isPlainObject (obj) {
  return Object.prototype.toString.call(obj) === '[object Object]'
}

function isPrimitive (data) {
  if (data == null) {
    return true
  }
  const type = typeof data
  return (
    type === 'string' ||
    type === 'number' ||
    type === 'boolean'
  )
}

function searchDeepInObject (obj, searchTerm) {
  var match = false
  const keys = Object.keys(obj)
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i]
    const value = obj[key]
    if (compare(key, searchTerm) || compare(value, searchTerm)) {
      match = true
      break
    }
    if (isPlainObject(value)) {
      match = searchDeepInObject(value, searchTerm)
      if (match) {
        break
      }
    }
  }
  return match
}

function compare (mixedValue, stringValue) {
  if (Array.isArray(mixedValue) && searchInArray(mixedValue, stringValue.toLowerCase())) {
    return true
  }
  if (('' + mixedValue).toLowerCase().indexOf(stringValue.toLowerCase()) !== -1) {
    return true
  }
  return false
}

function searchInArray (arr, searchTerm) {
  let found = false
  for (let i = 0; i < arr.length; i++) {
    if (('' + arr[i]).toLowerCase().indexOf(searchTerm) !== -1) {
      found = true
      break
    }
  }
  return found
}

function sortByKey (state) {
  return state && state.slice().sort((a, b) => {
    if (a.key < b.key) { return -1 }
    if (a.key > b.key) { return 1 }
    return 0
  })
}


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_COMPONENTS_matchTab_matchTab_vue__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_COMPONENTS_matchTab_matchTab_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_COMPONENTS_matchTab_matchTab_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_COMPONENTS_matchContent_matchContent_vue__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_COMPONENTS_matchContent_matchContent_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_COMPONENTS_matchContent_matchContent_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
    name: 'app',
    data () {
        return {
            message: 'match',
            tab: 'match',
            isDark: typeof chrome !== 'undefined' &&
            typeof chrome.devtools !== 'undefined' &&
            chrome.devtools.panels.themeName === 'dark'
        }
    },
    components: {
        match: __WEBPACK_IMPORTED_MODULE_1_COMPONENTS_matchContent_matchContent_vue___default.a
    },
    //computed: mapState({
        //  message: state => state.message,
        //  tab: state => state.tab,
        //  newEventCount: state => state.events.newEventCount
    //}),
    methods: {
        refresh () {
            const refreshIcon = this.$refs.refresh;
            refreshIcon.style.animation = 'none';
            MATCHBRIDGE.send('refresh');
            MATCHBRIDGE.once('flush', () => {
                refreshIcon.style.animation = 'rotate 1s'
            })
        },
        updateActiveBar () {
            const activeButton = this.$el.querySelector('.button.active');
            const activeBar = this.$el.querySelector('.active-bar');
            activeBar.style.left = activeButton.offsetLeft + 'px';
            activeBar.style.width = activeButton.offsetWidth + 'px';
        }
    },
    mounted () {
        this.updateActiveBar()
        window.addEventListener('resize', this.updateActiveBar)
    },
    destroyed () {
        window.removeEventListener('resize', this.updateActiveBar)
    },
    watch: {
        tab () {
            this.$nextTick(this.updateActiveBar)
        }
    }
});


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(14);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



const rawTypeRE = /^\[object (\w+)]$/
const specialTypeRE = /^\[native \w+ (.*)\]$/

function subFieldCount (value) {
  if (Array.isArray(value)) {
    return value.length
  } else if (value && typeof value === 'object') {
    return Object.keys(value).length
  } else {
    return 0
  }
}

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'DataField',
  props: {
    field: Object,
    depth: Number
  },
  data () {
    return {
      limit: Array.isArray(this.field.value) ? 10 : Infinity,
      expanded: this.depth === 0 && this.field.key !== '$route' && (subFieldCount(this.field.value) < 5)
    }
  },
  computed: {
    valueType () {
      const value = this.field.value
      const type = typeof value
      if (value == null || value === __WEBPACK_IMPORTED_MODULE_0__util__["a" /* UNDEFINED */]) {
        return 'null'
      } else if (
        type === 'boolean' ||
        type === 'number' ||
        value === __WEBPACK_IMPORTED_MODULE_0__util__["b" /* INFINITY */] ||
        value === __WEBPACK_IMPORTED_MODULE_0__util__["c" /* NAN */]
      ) {
        return 'literal'
      } else if (specialTypeRE.test(value)) {
        return 'native'
      } else if (type === 'string' && !rawTypeRE.test(value)) {
        return 'string'
      }
    },
    isExpandableType () {
      const value = this.field.value
      return Array.isArray(value) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["d" /* isPlainObject */])(value)
    },
    formattedValue () {
      const value = this.field.value
      if (value === null) {
        return 'null'
      } else if (value === __WEBPACK_IMPORTED_MODULE_0__util__["a" /* UNDEFINED */]) {
        return 'undefined'
      } else if (value === __WEBPACK_IMPORTED_MODULE_0__util__["c" /* NAN */]) {
        return 'NaN'
      } else if (value === __WEBPACK_IMPORTED_MODULE_0__util__["b" /* INFINITY */]) {
        return 'Infinity'
      } else if (Array.isArray(value)) {
        return 'Array[' + value.length + ']'
      } else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["d" /* isPlainObject */])(value)) {
        return 'Object' + (Object.keys(value).length ? '' : ' (empty)')
      } else if (this.valueType === 'native') {
        return specialTypeRE.exec(value)[1]
      } else if (typeof value === 'string') {
        var typeMatch = value.match(rawTypeRE)
        if (typeMatch) {
          return typeMatch[1]
        } else {
          return JSON.stringify(value)
        }
      } else {
        return value
      }
    },
    formattedSubFields () {
      let value = this.field.value
      if (Array.isArray(value)) {
        value = value.map((item, i) => ({
          key: i,
          value: item
        }))
      } else if (typeof value === 'object') {
        value = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* sortByKey */])(Object.keys(value).map(key => ({
          key,
          value: value[key]
        })))
      }
      return value
    },
    limitedSubFields () {
      return this.formattedSubFields.slice(0, this.limit)
    }
  },
  methods: {
    toggle () {
      if (this.isExpandableType) {
        this.expanded = !this.expanded
      }
    },
    hyphen: v => v.replace(/\s/g, '-')
  }
});


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  data () {
    return {
      split: 50,
      dragging: false
    }
  },
  methods: {
    dragStart (e) {
      this.dragging = true
      this.startX = e.pageX
      this.startSplit = this.split
    },
    dragMove (e) {
      if (this.dragging) {
        const dx = e.pageX - this.startX
        const totalWidth = this.$el.offsetWidth
        this.split = this.startSplit + ~~(dx / totalWidth * 100)
      }
    },
    dragEnd () {
      this.dragging = false
    }
  }
});


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__splitPane_splitPane_vue__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__splitPane_splitPane_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__splitPane_splitPane_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__matchTab_matchTab_vue__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__matchTab_matchTab_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__matchTab_matchTab_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_COMPONENTS_matchObj_matchObj_vue__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_COMPONENTS_matchObj_matchObj_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_COMPONENTS_matchObj_matchObj_vue__);




/* harmony default export */ __webpack_exports__["default"] = ({
    data () {
        return {
            matchArr: []
        }
    },
    components: {
        ComponentTree: __WEBPACK_IMPORTED_MODULE_1__matchTab_matchTab_vue___default.a,
        matchObj: __WEBPACK_IMPORTED_MODULE_2_COMPONENTS_matchObj_matchObj_vue___default.a,
        SplitPane: __WEBPACK_IMPORTED_MODULE_0__splitPane_splitPane_vue___default.a
    },
    beforeMount () {
        this.matchArr = window.MATCH_STACK;
        this.matchArr = [
            {
                beforeParams: {
                    id: 1,
                    pid: {
                        id:1
                    }
                },
                afterParams: {
                    pid: 2,
                    data: {
                        type: 1,
                        id: 'sdf'
                    }
                }
            }
        ];
        console.log(this.matchArr);
    },
    methods: {
        filter (e) {
            bridge.send('filter-instances', e.target.value)
        }
    }
});


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dataField_vue__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dataField_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__dataField_vue__);


/* harmony default export */ __webpack_exports__["default"] = ({
    props: {
        stacks: Array
    },
    components: {
        DataField: __WEBPACK_IMPORTED_MODULE_0__dataField_vue___default.a
    }
});


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__actionTab_vue__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__actionTab_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__actionTab_vue__);


/* harmony default export */ __webpack_exports__["default"] = ({
    components: {
        ActionHeader: __WEBPACK_IMPORTED_MODULE_0__actionTab_vue___default.a
    },
    methods: {
        filterStacks () {
        }
    }
});


/***/ }),
/* 21 */
/***/ (function(module, exports) {

function encode (data, replacer, list, seen) {
  var stored, key, value, i, l
  var seenIndex = seen.get(data)
  if (seenIndex != null) {
    return seenIndex
  }
  var index = list.length
  if (isPlainObject(data)) {
    stored = {}
    seen.set(data, index)
    list.push(stored)
    var keys = Object.keys(data)
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i]
      value = data[key]
      if (replacer) {
        value = replacer.call(data, key, value)
      }
      stored[key] = encode(value, replacer, list, seen)
    }
  } else if (Array.isArray(data)) {
    stored = []
    seen.set(data, index)
    list.push(stored)
    for (i = 0, l = data.length; i < l; i++) {
      value = data[i]
      if (replacer) {
       value = replacer.call(data, i, value)
      }
      stored[i] = encode(value, replacer, list, seen)
    }
  } else {
    index = list.length
    list.push(data)
  }
  return index
}

function decode (list, reviver) {
  var i = list.length
  var j, k, data, key, value
  while (i--) {
    var data = list[i]
    if (isPlainObject(data)) {
      var keys = Object.keys(data)
      for (j = 0, k = keys.length; j < k; j++) {
        key = keys[j]
        value = list[data[key]]
        if (reviver) value = reviver.call(data, key, value)
        data[key] = value
      }
    } else if (Array.isArray(data)) {
      for (j = 0, k = data.length; j < k; j++) {
        value = list[data[j]]
        if (reviver) value = reviver.call(data, j, value)
        data[j] = value
      }
    }
  }
}

function isPlainObject (obj) {
  return Object.prototype.toString.call(obj) === '[object Object]'
}

exports.stringify = function stringify (data, replacer, space) {
  try {
    return arguments.length === 1
      ? JSON.stringify(data)
      : JSON.stringify(data, replacer, space)
  } catch (e) {
    return exports.stringifyStrict(data, replacer, space)
  }
}

exports.parse = function parse (data, reviver) {
  var hasCircular = /^\s/.test(data)
  if (!hasCircular) {
    return arguments.length === 1
      ? JSON.parse(data)
      : JSON.parse(data, reviver)
  } else {
    var list = JSON.parse(data)
    decode(list, reviver)
    return list[0]
  }
}

exports.stringifyStrict = function (data, replacer, space) {
  var list = []
  encode(data, replacer, list, new Map())
  return space
    ? ' ' + JSON.stringify(list, null, space)
    : ' ' + JSON.stringify(list)
}


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.slide-up-enter {\n  opacity: 0;\n  transform: translate(0, 50%);\n}\n.slide-up-leave-to {\n  opacity: 0;\n  transform: translate(0, -50%);\n}\n.slide-down-enter,\n.slide-down-leave-to {\n  opacity: 0;\n  transform: translate(0, -20px);\n}\n@-moz-keyframes rotate {\n0% {\n    transform: rotate(0deg);\n}\n100% {\n    transform: rotate(360deg);\n}\n}\n@-webkit-keyframes rotate {\n0% {\n    transform: rotate(0deg);\n}\n100% {\n    transform: rotate(360deg);\n}\n}\n@-o-keyframes rotate {\n0% {\n    transform: rotate(0deg);\n}\n100% {\n    transform: rotate(360deg);\n}\n}\n@keyframes rotate {\n0% {\n    transform: rotate(0deg);\n}\n100% {\n    transform: rotate(360deg);\n}\n}\n@font-face {\n  font-family: 'Material Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: url(" + __webpack_require__(30) + ") format('woff2');\n}\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Roboto'), local('Roboto-Regular'), url(" + __webpack_require__(31) + ") format('woff2');\n}\n.material-icons {\n  font-family: 'Material Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 22px;\n  display: inline-block;\n  width: 1em;\n  height: 1em;\n  color: #999;\n  line-height: 1;\n  text-transform: none;\n  letter-spacing: normal;\n  word-wrap: normal;\n  white-space: nowrap;\n  direction: ltr;\n/* Support for all WebKit browsers. */\n  -webkit-font-smoothing: antialiased;\n/* Support for Safari and Chrome. */\n  text-rendering: optimizeLegibility;\n/* Support for Firefox. */\n  -moz-osx-font-smoothing: grayscale;\n}\n.material-icons.medium {\n  transform: scale(0.9);\n}\n.material-icons.small {\n  transform: scale(0.8);\n}\n.toggle-recording .material-icons {\n  color: #999 !important;\n}\n.toggle-recording .material-icons.enabled {\n  color: #f00 !important;\n  text-shadow: 0 0 3px rgba(255,0,0,0.4);\n}\nhtml,\nbody {\n  margin: 0;\n  padding: 0;\n  font-family: Roboto;\n  font-size: 16px;\n  color: #444;\n}\n* {\n  box-sizing: border-box;\n}\n.arrow {\n  display: inline-block;\n  width: 0;\n  height: 0;\n}\n.arrow.up {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-bottom: 6px solid #444;\n}\n.arrow.down {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 6px solid #444;\n}\n.arrow.right {\n  border-top: 4px solid transparent;\n  border-bottom: 4px solid transparent;\n  border-left: 6px solid #444;\n}\n.arrow.left {\n  border-top: 4px solid transparent;\n  border-bottom: 4px solid transparent;\n  border-right: 6px solid #444;\n}\n.notice {\n  display: flex;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n  color: #aaa;\n}\n.notice div {\n  text-align: center;\n  padding: 0.5em;\n  margin: 0 auto;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/transitions.styl","G:/luobata/lib/match-devtools/src/global.styl"],"names":[],"mappings":";AAAA;EACE,WAAA;EACA,6BAAA;CCCD;ADCD;EACE,WAAA;EACA,8BAAA;CCCD;ADCD;;EACE,WAAA;EACA,+BAAA;CCED;ADAU;AACT;IACE,wBAAA;CCED;ADDD;IACE,0BAAA;CCGD;CACF;ADRU;AACT;IACE,wBAAA;CCUD;ADTD;IACE,0BAAA;CCWD;CACF;ADhBU;AACT;IACE,wBAAA;CCkBD;ADjBD;IACE,0BAAA;CCmBD;CACF;ADxBU;AACT;IACE,wBAAA;CC0BD;ADzBD;IACE,0BAAA;CC2BD;CACF;AAzCD;EACE,8BAAA;EACA,mBAAA;EACA,iBAAA;EACA,mDAAA;CA2CD;AAzCD;EACE,sBAAA;EACA,mBAAA;EACA,iBAAA;EACA,6FAAA;CA2CD;AAzCD;EACE,8BAAA;EACA,oBAAA;EACA,mBAAA;EACA,gBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,YAAA;EACA,eAAA;EACA,qBAAA;EACA,uBAAA;EACA,kBAAA;EACA,oBAAA;EACA,eAAA;AACA,sCAAA;EACA,oCAAA;AACA,oCAAA;EACA,mCAAA;AACA,0BAAA;EACA,mCAAA;CA2CD;AA1CC;EACE,sBAAA;CA4CH;AA3CC;EACE,sBAAA;CA6CH;AA3CD;EACE,uBAAA;CA6CD;AA5CC;EACE,uBAAA;EACA,uCAAA;CA8CH;AA5CD;;EACE,UAAA;EACA,WAAA;EACA,oBAAA;EACA,gBAAA;EACA,YAAA;CA+CD;AA7CD;EACE,uBAAA;CA+CD;AA3CD;EACE,sBAAA;EACA,SAAA;EACA,UAAA;CA6CD;AA5CC;EACE,mCAAA;EACA,oCAAA;EACA,8BAAA;CA8CH;AA7CC;EACE,mCAAA;EACA,oCAAA;EACA,2BAAA;CA+CH;AA9CC;EACE,kCAAA;EACA,qCAAA;EACA,4BAAA;CAgDH;AA/CC;EACE,kCAAA;EACA,qCAAA;EACA,6BAAA;CAiDH;AA/CD;EACE,cAAA;EACA,oBAAA;EACA,aAAA;EACA,YAAA;EACA,YAAA;CAiDD;AAhDC;EACE,mBAAA;EACA,eAAA;EACA,eAAA;CAkDH","file":"global.styl","sourcesContent":[".slide-up-enter\r\n  opacity 0\r\n  transform translate(0, 50%)\r\n\r\n.slide-up-leave-to\r\n  opacity 0\r\n  transform translate(0, -50%)\r\n\r\n.slide-down-enter, .slide-down-leave-to\r\n  opacity 0\r\n  transform translate(0, -20px)\r\n\r\n@keyframes rotate\r\n  0%\r\n    transform rotate(0deg)\r\n  100%\r\n    transform rotate(360deg)\r\n","@import \"./variables\"\r\n@import \"./transitions\"\r\n\r\n@font-face\r\n  font-family 'Material Icons'\r\n  font-style normal\r\n  font-weight 400\r\n  src url(./assets/MaterialIcons-Regular.woff2) format('woff2')\r\n\r\n@font-face\r\n  font-family 'Roboto'\r\n  font-style normal\r\n  font-weight 400\r\n  src local('Roboto'), local('Roboto-Regular'), url(./assets/Roboto-Regular.woff2) format('woff2')\r\n\r\n.material-icons\r\n  font-family 'Material Icons'\r\n  font-weight normal\r\n  font-style normal\r\n  font-size 22px\r\n  display inline-block\r\n  width 1em\r\n  height 1em\r\n  color #999\r\n  line-height 1\r\n  text-transform none\r\n  letter-spacing normal\r\n  word-wrap normal\r\n  white-space nowrap\r\n  direction ltr\r\n  /* Support for all WebKit browsers. */\r\n  -webkit-font-smoothing: antialiased\r\n  /* Support for Safari and Chrome. */\r\n  text-rendering: optimizeLegibility\r\n  /* Support for Firefox. */\r\n  -moz-osx-font-smoothing: grayscale\r\n  &.medium\r\n    transform scale(0.9)\r\n  &.small\r\n    transform scale(0.8)\r\n\r\n.toggle-recording .material-icons\r\n  color #999 !important\r\n  &.enabled\r\n    color red !important\r\n    text-shadow 0 0 3px rgba(255, 0, 0, .4)\r\n\r\nhtml, body\r\n  margin 0\r\n  padding 0\r\n  font-family Roboto\r\n  font-size 16px\r\n  color #444\r\n\r\n*\r\n  box-sizing border-box\r\n\r\n$arrow-color = #444\r\n\r\n.arrow\r\n  display inline-block\r\n  width 0\r\n  height 0\r\n  &.up\r\n    border-left 4px solid transparent\r\n    border-right 4px solid transparent\r\n    border-bottom 6px solid $arrow-color\r\n  &.down\r\n    border-left 4px solid transparent\r\n    border-right 4px solid transparent\r\n    border-top 6px solid $arrow-color\r\n  &.right\r\n    border-top 4px solid transparent\r\n    border-bottom 4px solid transparent\r\n    border-left 6px solid $arrow-color\r\n  &.left\r\n    border-top 4px solid transparent\r\n    border-bottom 4px solid transparent\r\n    border-right 6px solid $arrow-color\r\n\r\n.notice\r\n  display flex\r\n  align-items center\r\n  height 100%\r\n  width 100%\r\n  color #aaa\r\n  div\r\n    text-align center\r\n    padding 0.5em\r\n    margin 0 auto\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.app[data-v-3499c881] {\n  width: 100%;\n  height: 100%;\n  user-select: none;\n  background-color: #fff;\n  display: flex;\n  flex-direction: column;\n}\n.app h1[data-v-3499c881] {\n  color: #42b983;\n}\n.app.dark[data-v-3499c881] {\n  background-color: #242424;\n}\n.header[data-v-3499c881] {\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid #ddd;\n  box-shadow: 0 0 8px rgba(0,0,0,0.15);\n  font-size: 14px;\n  position: relative;\n}\n.app.dark .header[data-v-3499c881] {\n  border-bottom: 1px solid #3a3a3a;\n}\n.logo[data-v-3499c881] {\n  width: 30px;\n  height: 30px;\n  margin: 0 15px;\n}\n.message-container[data-v-3499c881] {\n  height: 1em;\n  cursor: default;\n}\n.message[data-v-3499c881] {\n  color: #3ba776;\n  transition: all 0.3s ease;\n  position: absolute;\n}\n.button[data-v-3499c881] {\n  padding: 10px;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  position: relative;\n  border-bottom-color: transparent;\n  background-color: #fff;\n  color: #888;\n  transition: color 0.35s ease;\n}\n.app.dark .button[data-v-3499c881] {\n  background-color: #242424;\n}\n.button[data-v-3499c881]:hover {\n  color: #555;\n}\n.button.active[data-v-3499c881] {\n  color: #3ba776;\n}\n.button[data-v-3499c881]:first-of-type {\n  margin-left: auto;\n}\n.button .material-icons[data-v-3499c881] {\n  font-size: 20px;\n  margin-right: 5px;\n  color: inherit;\n}\n.button .pane-name[data-v-3499c881] {\n  display: none;\n}\n@media (min-width: 820px) {\n.button[data-v-3499c881] {\n    padding-right: 20px;\n    padding-left: 20px;\n}\n.button .pane-name[data-v-3499c881] {\n    display: block;\n}\n}\n@media (min-height: 300px) {\n.button[data-v-3499c881] {\n    padding-top: 20px;\n    padding-bottom: 20px;\n}\n}\n.container[data-v-3499c881] {\n  overflow: hidden;\n  flex: 1;\n}\n.event-count[data-v-3499c881] {\n  background-color: #3ba776;\n  color: #fff;\n  border-radius: 50%;\n  width: 18px;\n  height: 18px;\n  text-align: center;\n  padding-top: 4px;\n  font-size: 9px;\n  position: absolute;\n  right: 0;\n  top: 12px;\n}\n.app.dark .event-count[data-v-3499c881] {\n  background-color: #242424;\n}\n.active-bar[data-v-3499c881] {\n  position: absolute;\n  bottom: 0;\n  width: 0px;\n  height: 3px;\n  background-color: #3ba776;\n  transition: all 0.32s cubic-bezier(0, 0.9, 0.6, 1);\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/App.vue"],"names":[],"mappings":";AAqFA;EACE,YAAA;EACA,aAAA;EACA,kBAAA;EACA,uBAAA;EACA,cAAA;EACA,uBAAA;CApFD;AAqFC;EACE,eAAA;CAnFH;AAoFC;EACE,0BAAA;CAlFH;AAmFD;EACE,cAAA;EACA,oBAAA;EACA,8BAAA;EACA,qCAAA;EACA,gBAAA;EACA,mBAAA;CAjFD;AAkFC;EACE,iCAAA;CAhFH;AAiFD;EACE,YAAA;EACA,aAAA;EACA,eAAA;CA/ED;AAgFD;EACE,YAAA;EACA,gBAAA;CA9ED;AA+ED;EACE,eAAA;EACA,0BAAA;EACA,mBAAA;CA7ED;AA8ED;EACE,cAAA;EACA,cAAA;EACA,oBAAA;EACA,gBAAA;EACA,mBAAA;EACA,iCAAA;EACA,uBAAA;EACA,YAAA;EACA,6BAAA;CA5ED;AA6EC;EACE,0BAAA;CA3EH;AA4EC;EACE,YAAA;CA1EH;AA2EC;EACE,eAAA;CAzEH;AA0EC;EACE,kBAAA;CAxEH;AAyEC;EACE,gBAAA;EACA,kBAAA;EACA,eAAA;CAvEH;AAwEC;EACE,cAAA;CAtEH;AAuEyB;AAAA;IACtB,oBAAA;IACA,mBAAA;CApED;AAqEC;IACE,eAAA;CAnEH;CACF;AAmE0B;AAAA;IACvB,kBAAA;IACA,qBAAA;CAhED;CACF;AAgED;EACE,iBAAA;EACA,QAAA;CA9DD;AAgED;EACE,0BAAA;EACA,YAAA;EACA,mBAAA;EACA,YAAA;EACA,aAAA;EACA,mBAAA;EACA,iBAAA;EACA,eAAA;EACA,mBAAA;EACA,SAAA;EACA,UAAA;CA9DD;AA+DC;EACE,0BAAA;CA7DH;AA8DD;EACE,mBAAA;EACA,UAAA;EACA,WAAA;EACA,YAAA;EACA,0BAAA;EACA,mDAAA;CA5DD","file":"App.vue","sourcesContent":[".app {\n  width: 100%;\n  height: 100%;\n  user-select: none;\n  background-color: #fff;\n  display: flex;\n  flex-direction: column;\n}\n.app h1 {\n  color: #42b983;\n}\n.app.dark {\n  background-color: #242424;\n}\n.header {\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid #ddd;\n  box-shadow: 0 0 8px rgba(0,0,0,0.15);\n  font-size: 14px;\n  position: relative;\n}\n.app.dark .header {\n  border-bottom: 1px solid #3a3a3a;\n}\n.logo {\n  width: 30px;\n  height: 30px;\n  margin: 0 15px;\n}\n.message-container {\n  height: 1em;\n  cursor: default;\n}\n.message {\n  color: #3ba776;\n  transition: all 0.3s ease;\n  position: absolute;\n}\n.button {\n  padding: 10px;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  position: relative;\n  border-bottom-color: transparent;\n  background-color: #fff;\n  color: #888;\n  transition: color 0.35s ease;\n}\n.app.dark .button {\n  background-color: #242424;\n}\n.button:hover {\n  color: #555;\n}\n.button.active {\n  color: #3ba776;\n}\n.button:first-of-type {\n  margin-left: auto;\n}\n.button .material-icons {\n  font-size: 20px;\n  margin-right: 5px;\n  color: inherit;\n}\n.button .pane-name {\n  display: none;\n}\n@media (min-width: 820px) {\n  .button {\n    padding-right: 20px;\n    padding-left: 20px;\n  }\n  .button .pane-name {\n    display: block;\n  }\n}\n@media (min-height: 300px) {\n  .button {\n    padding-top: 20px;\n    padding-bottom: 20px;\n  }\n}\n.container {\n  overflow: hidden;\n  flex: 1;\n}\n.event-count {\n  background-color: #3ba776;\n  color: #fff;\n  border-radius: 50%;\n  width: 18px;\n  height: 18px;\n  text-align: center;\n  padding-top: 4px;\n  font-size: 9px;\n  position: absolute;\n  right: 0;\n  top: 12px;\n}\n.app.dark .event-count {\n  background-color: #242424;\n}\n.active-bar {\n  position: absolute;\n  bottom: 0;\n  width: 0px;\n  height: 3px;\n  background-color: #3ba776;\n  transition: all 0.32s cubic-bezier(0, 0.9, 0.6, 1);\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.split-pane[data-v-3d0b1c2c] {\n  display: flex;\n  height: 100%;\n}\n.split-pane.dragging[data-v-3d0b1c2c] {\n  cursor: ew-resize;\n}\n.left[data-v-3d0b1c2c],\n.right[data-v-3d0b1c2c] {\n  position: relative;\n}\n.left[data-v-3d0b1c2c] {\n  border-right: 1px solid #ddd;\n}\n.app.dark .left[data-v-3d0b1c2c] {\n  border-right: 1px solid #3a3a3a;\n}\n.dragger[data-v-3d0b1c2c] {\n  position: absolute;\n  z-index: 99;\n  top: 0;\n  bottom: 0;\n  right: -5px;\n  width: 10px;\n  cursor: ew-resize;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/components/src/components/splitPane/splitPane.vue","G:/luobata/lib/match-devtools/src/components/splitPane/splitPane.vue"],"names":[],"mappings":";AAgDA;EACE,cAAA;EACA,aAAA;CC/CD;ADgDC;EACE,kBAAA;CC9CH;ADgDD;;EACE,mBAAA;CC7CD;AD+CD;EACE,6BAAA;CC7CD;AD8CC;EACE,gCAAA;CC5CH;AD8CD;EACE,mBAAA;EACA,YAAA;EACA,OAAA;EACA,UAAA;EACA,YAAA;EACA,YAAA;EACA,kBAAA;CC5CD","file":"splitPane.vue","sourcesContent":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@import \"../../variables\"\n\n.split-pane\n  display flex\n  height 100%\n  &.dragging\n    cursor ew-resize\n\n.left, .right\n  position relative\n\n.left\n  border-right 1px solid $border-color\n  .app.dark &\n    border-right 1px solid $dark-border-color\n\n.dragger\n  position absolute\n  z-index 99\n  top 0\n  bottom 0\n  right -5px\n  width 10px\n  cursor ew-resize\n",".split-pane {\n  display: flex;\n  height: 100%;\n}\n.split-pane.dragging {\n  cursor: ew-resize;\n}\n.left,\n.right {\n  position: relative;\n}\n.left {\n  border-right: 1px solid #ddd;\n}\n.app.dark .left {\n  border-right: 1px solid #3a3a3a;\n}\n.dragger {\n  position: absolute;\n  z-index: 99;\n  top: 0;\n  bottom: 0;\n  right: -5px;\n  width: 10px;\n  cursor: ew-resize;\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "", "", {"version":3,"sources":[],"names":[],"mappings":"","file":"match.css","sourceRoot":""}]);

// exports


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.data-wrapper {\n  display: flex;\n  flex-wrap: wrap;\n  padding-top: 20px;\n}\n.data-fields {\n  padding: 20px 20px 40px;\n}\n.data-el {\n  padding: 0px 10px;\n  flex: 1 0 33.33%;\n  font-size: 14px;\n}\n.data-el .data-type {\n  color: #486887;\n  padding-left: 20px;\n  margin-bottom: -10px;\n}\n.app.dark .data-el .data-type {\n  color: #7595b5;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/components/src/components/matchObj/matchObj.vue","G:/luobata/lib/match-devtools/src/components/matchObj/matchObj.vue"],"names":[],"mappings":";AA4CA;EACE,cAAA;EACA,gBAAA;EACA,kBAAA;CC3CD;AD6CD;EACE,wBAAA;CC3CD;AD6CD;EACE,kBAAA;EACA,iBAAA;EACA,gBAAA;CC3CD;AD6CC;EACE,eAAA;EACA,mBAAA;EACA,qBAAA;CC3CH;AD6CG;EACE,eAAA;CC3CL","file":"matchObj.vue","sourcesContent":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.data-wrapper\n  display flex\n  flex-wrap wrap\n  padding-top 20px\n\n.data-fields\n  padding 20px 20px 40px\n\n.data-el\n  padding 0px 10px\n  flex 1 0 33.33%\n  font-size 14px\n\n  .data-type\n    color #486887\n    padding-left 20px\n    margin-bottom -10px\n\n    .app.dark &\n      color lighten(#486887, 30%)\n",".data-wrapper {\n  display: flex;\n  flex-wrap: wrap;\n  padding-top: 20px;\n}\n.data-fields {\n  padding: 20px 20px 40px;\n}\n.data-el {\n  padding: 0px 10px;\n  flex: 1 0 33.33%;\n  font-size: 14px;\n}\n.data-el .data-type {\n  color: #486887;\n  padding-left: 20px;\n  margin-bottom: -10px;\n}\n.app.dark .data-el .data-type {\n  color: #7595b5;\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.data-field[data-v-ecaaf5a8] {\n  user-select: text;\n  font-size: 12px;\n  font-family: Menlo, Consolas, monospace;\n  cursor: default;\n}\n.self[data-v-ecaaf5a8] {\n  height: 20px;\n  line-height: 20px;\n  position: relative;\n  white-space: nowrap;\n  padding-left: 14px;\n}\n.self span[data-v-ecaaf5a8],\n.self div[data-v-ecaaf5a8] {\n  display: inline-block;\n  vertical-align: middle;\n}\n.self .arrow[data-v-ecaaf5a8] {\n  position: absolute;\n  top: 7px;\n  left: 0px;\n  transition: transform 0.1s ease;\n}\n.self .arrow.rotated[data-v-ecaaf5a8] {\n  transform: rotate(90deg);\n}\n.self .key[data-v-ecaaf5a8] {\n  color: #881391;\n}\n.self .colon[data-v-ecaaf5a8] {\n  margin-right: 0.5em;\n  position: relative;\n}\n.self .value[data-v-ecaaf5a8] {\n  color: #444;\n}\n.self .value.string[data-v-ecaaf5a8],\n.self .value.native[data-v-ecaaf5a8] {\n  color: #c41a16;\n}\n.self .value.null[data-v-ecaaf5a8] {\n  color: #999;\n}\n.self .value.literal[data-v-ecaaf5a8] {\n  color: #03c;\n}\n.self .type[data-v-ecaaf5a8] {\n  color: #fff;\n  padding: 3px 6px;\n  font-size: 10px;\n  line-height: 10px;\n  height: 16px;\n  border-radius: 3px;\n  margin: 2px 6px;\n  position: relative;\n  background-color: #eee;\n}\n.self .type.prop[data-v-ecaaf5a8] {\n  background-color: #96afdd;\n}\n.self .type.computed[data-v-ecaaf5a8] {\n  background-color: #af90d5;\n}\n.self .type.vuex-getter[data-v-ecaaf5a8] {\n  background-color: #5dd5d5;\n}\n.self .type.firebase-binding[data-v-ecaaf5a8] {\n  background-color: #fc0;\n}\n.self .type.observable[data-v-ecaaf5a8] {\n  background-color: #f99;\n}\n.self .meta[data-v-ecaaf5a8] {\n  display: none;\n  position: absolute;\n  z-index: 999;\n  font-size: 11px;\n  color: #444;\n  top: 0;\n  left: calc(100% + 5px);\n  width: 150px;\n  border: 1px solid #e3e3e3;\n  border-radius: 3px;\n  padding: 8px 12px;\n  background-color: #fff;\n  line-height: 16px;\n  box-shadow: 0 2px 12px rgba(0,0,0,0.1);\n}\n.self .meta .key[data-v-ecaaf5a8] {\n  width: 65px;\n}\n.self .meta-field[data-v-ecaaf5a8] {\n  display: block;\n}\n.self[data-v-ecaaf5a8]:hover {\n  cursor: pointer;\n}\n.self:hover .meta[data-v-ecaaf5a8] {\n  display: block;\n}\n.app.dark .self .key[data-v-ecaaf5a8] {\n  color: #e36eec;\n}\n.app.dark .self .value[data-v-ecaaf5a8] {\n  color: #bdc6cf;\n}\n.app.dark .self .value.string[data-v-ecaaf5a8],\n.app.dark .self .value.native[data-v-ecaaf5a8] {\n  color: #e33e3a;\n}\n.app.dark .self .value.null[data-v-ecaaf5a8] {\n  color: #999;\n}\n.app.dark .self .value.literal[data-v-ecaaf5a8] {\n  color: #997fff;\n}\n.app.dark .self .type[data-v-ecaaf5a8] {\n  color: #242424;\n}\n.app.dark .self .type .meta[data-v-ecaaf5a8] {\n  border: 1px solid #3a3a3a;\n  background-color: #242424;\n}\n.more[data-v-ecaaf5a8] {\n  cursor: pointer;\n  display: inline-block;\n  border-radius: 4px;\n  padding: 0 4px 4px;\n}\n.more[data-v-ecaaf5a8]:hover {\n  background-color: #eee;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/components/src/components/matchObj/dataField.vue","G:/luobata/lib/match-devtools/src/components/matchObj/dataField.vue"],"names":[],"mappings":";AAyJA;EACE,kBAAA;EACA,gBAAA;EACA,wCAAA;EACA,gBAAA;CCxJD;AD0JD;EACE,aAAA;EACA,kBAAA;EACA,mBAAA;EACA,oBAAA;EACA,mBAAA;CCxJD;ADyJC;;EACE,sBAAA;EACA,uBAAA;CCtJH;ADuJC;EACE,mBAAA;EACA,SAAA;EACA,UAAA;EACA,gCAAA;CCrJH;ADsJG;EACE,yBAAA;CCpJL;ADqJC;EACE,eAAA;CCnJH;ADoJC;EACE,oBAAA;EACA,mBAAA;CClJH;ADmJC;EACE,YAAA;CCjJH;ADkJG;;EACE,eAAA;CC/IL;ADgJG;EACE,YAAA;CC9IL;AD+IG;EACE,YAAA;CC7IL;AD+IC;EACE,YAAA;EACA,iBAAA;EACA,gBAAA;EACA,kBAAA;EACA,aAAA;EACA,mBAAA;EACA,gBAAA;EACA,mBAAA;EACA,uBAAA;CC7IH;AD8IG;EACE,0BAAA;CC5IL;AD6IG;EACE,0BAAA;CC3IL;AD4IG;EACE,0BAAA;CC1IL;AD2IG;EACE,uBAAA;CCzIL;AD0IG;EACE,uBAAA;CCxIL;AD0IC;EACE,cAAA;EACA,mBAAA;EACA,aAAA;EACA,gBAAA;EACA,YAAA;EACA,OAAA;EACA,uBAAA;EACA,aAAA;EACA,0BAAA;EACA,mBAAA;EACA,kBAAA;EACA,uBAAA;EACA,kBAAA;EACA,uCAAA;CCxIH;ADyIG;EACE,YAAA;CCvIL;ADwIC;EACE,eAAA;CCtIH;ADuIC;EACE,gBAAA;CCrIH;ADsIG;EACE,eAAA;CCpIL;ADuIG;EACE,eAAA;CCrIL;ADsIG;EACE,eAAA;CCpIL;ADqIK;;EACE,eAAA;CClIP;ADmIK;EACE,YAAA;CCjIP;ADkIK;EACE,eAAA;CChIP;ADiIG;EACE,eAAA;CC/HL;ADgIK;EACE,0BAAA;EACA,0BAAA;CC9HP;ADiID;EACE,gBAAA;EACA,sBAAA;EACA,mBAAA;EACA,mBAAA;CC/HD;ADgIC;EACE,uBAAA;CC9HH","file":"dataField.vue","sourcesContent":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@import \"../../variables\"\n\n.data-field\n  user-select text\n  font-size 12px\n  font-family Menlo, Consolas, monospace\n  cursor default\n\n.self\n  height 20px\n  line-height 20px\n  position relative\n  white-space nowrap\n  padding-left 14px\n  span, div\n    display inline-block\n    vertical-align middle\n  .arrow\n    position absolute\n    top 7px\n    left 0px\n    transition transform .1s ease\n    &.rotated\n      transform rotate(90deg)\n  .key\n    color #881391\n  .colon\n    margin-right .5em\n    position relative\n  .value\n    color #444\n    &.string, &.native\n      color #c41a16\n    &.null\n      color #999\n    &.literal\n      color #0033cc\n\n  .type\n    color $background-color\n    padding 3px 6px\n    font-size 10px\n    line-height 10px\n    height 16px\n    border-radius 3px\n    margin 2px 6px\n    position relative\n    background-color #eee\n    &.prop\n      background-color #96afdd\n    &.computed\n      background-color #af90d5\n    &.vuex-getter\n      background-color #5dd5d5\n    &.firebase-binding\n      background-color #ffcc00\n    &.observable\n      background-color #ff9999\n\n  .meta\n    display none\n    position absolute\n    z-index 999\n    font-size 11px\n    color #444\n    top 0\n    left calc(100% + 5px)\n    width 150px\n    border 1px solid #e3e3e3\n    border-radius 3px\n    padding 8px 12px\n    background-color $background-color\n    line-height 16px\n    box-shadow 0 2px 12px rgba(0,0,0,.1)\n    .key\n      width 65px\n  .meta-field\n    display block\n  &:hover\n    cursor pointer\n    .meta\n      display block\n\n  .app.dark &\n    .key\n      color: #e36eec\n    .value\n      color #bdc6cf\n      &.string, &.native\n        color #e33e3a\n      &.null\n        color #999\n      &.literal\n        color #997fff\n    .type\n      color: #242424\n      .meta\n        border 1px solid $dark-border-color\n        background-color $dark-background-color\n\n\n.more\n  cursor pointer\n  display inline-block\n  border-radius 4px\n  padding 0 4px 4px\n  &:hover\n    background-color #eee\n",".data-field {\n  user-select: text;\n  font-size: 12px;\n  font-family: Menlo, Consolas, monospace;\n  cursor: default;\n}\n.self {\n  height: 20px;\n  line-height: 20px;\n  position: relative;\n  white-space: nowrap;\n  padding-left: 14px;\n}\n.self span,\n.self div {\n  display: inline-block;\n  vertical-align: middle;\n}\n.self .arrow {\n  position: absolute;\n  top: 7px;\n  left: 0px;\n  transition: transform 0.1s ease;\n}\n.self .arrow.rotated {\n  transform: rotate(90deg);\n}\n.self .key {\n  color: #881391;\n}\n.self .colon {\n  margin-right: 0.5em;\n  position: relative;\n}\n.self .value {\n  color: #444;\n}\n.self .value.string,\n.self .value.native {\n  color: #c41a16;\n}\n.self .value.null {\n  color: #999;\n}\n.self .value.literal {\n  color: #03c;\n}\n.self .type {\n  color: #fff;\n  padding: 3px 6px;\n  font-size: 10px;\n  line-height: 10px;\n  height: 16px;\n  border-radius: 3px;\n  margin: 2px 6px;\n  position: relative;\n  background-color: #eee;\n}\n.self .type.prop {\n  background-color: #96afdd;\n}\n.self .type.computed {\n  background-color: #af90d5;\n}\n.self .type.vuex-getter {\n  background-color: #5dd5d5;\n}\n.self .type.firebase-binding {\n  background-color: #fc0;\n}\n.self .type.observable {\n  background-color: #f99;\n}\n.self .meta {\n  display: none;\n  position: absolute;\n  z-index: 999;\n  font-size: 11px;\n  color: #444;\n  top: 0;\n  left: calc(100% + 5px);\n  width: 150px;\n  border: 1px solid #e3e3e3;\n  border-radius: 3px;\n  padding: 8px 12px;\n  background-color: #fff;\n  line-height: 16px;\n  box-shadow: 0 2px 12px rgba(0,0,0,0.1);\n}\n.self .meta .key {\n  width: 65px;\n}\n.self .meta-field {\n  display: block;\n}\n.self:hover {\n  cursor: pointer;\n}\n.self:hover .meta {\n  display: block;\n}\n.app.dark .self .key {\n  color: #e36eec;\n}\n.app.dark .self .value {\n  color: #bdc6cf;\n}\n.app.dark .self .value.string,\n.app.dark .self .value.native {\n  color: #e33e3a;\n}\n.app.dark .self .value.null {\n  color: #999;\n}\n.app.dark .self .value.literal {\n  color: #997fff;\n}\n.app.dark .self .type {\n  color: #242424;\n}\n.app.dark .self .type .meta {\n  border: 1px solid #3a3a3a;\n  background-color: #242424;\n}\n.more {\n  cursor: pointer;\n  display: inline-block;\n  border-radius: 4px;\n  padding: 0 4px 4px;\n}\n.more:hover {\n  background-color: #eee;\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)();
// imports


// module
exports.push([module.i, "\n.action-header[data-v-fa36b44e] {\n  display: flex;\n  align-items: stretch;\n  padding: 0 10px;\n  font-size: 12px;\n  border-bottom: 1px solid #ddd;\n  color: #666;\n  height: 35px;\n}\n@media (min-height: 300px) {\n.action-header[data-v-fa36b44e] {\n    height: 50px;\n}\n}\n.app.dark .action-header[data-v-fa36b44e] {\n  border-bottom: 1px solid #3a3a3a;\n}\n.title[data-v-fa36b44e] {\n  display: flex;\n  align-items: center;\n  font-size: 18px;\n  color: #3ba776;\n}\n.button[data-v-fa36b44e] {\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0 10px;\n  transition: opacity 0.25s;\n  white-space: nowrap;\n  opacity: 0.8;\n  overflow: hidden;\n}\n.button[data-v-fa36b44e]:first-of-type {\n  margin-left: auto;\n}\n.button[data-v-fa36b44e]:not(.disabled):hover {\n  opacity: 1;\n  color: #3ba776;\n}\n.button.disabled[data-v-fa36b44e] {\n  opacity: 0.45;\n  cursor: not-allowed;\n}\n.button span[data-v-fa36b44e] {\n  display: none;\n}\n@media (min-width: 820px) {\n.button span[data-v-fa36b44e] {\n    display: inline;\n}\n}\n.material-icons[data-v-fa36b44e] {\n  font-size: 18px;\n  margin-right: 0;\n  color: inherit;\n}\n@media (min-width: 820px) {\n.material-icons[data-v-fa36b44e] {\n    margin-right: 5px;\n}\n}\n.search[data-v-fa36b44e] {\n  display: flex;\n  align-items: center;\n  flex: 1;\n}\n.search input[data-v-fa36b44e] {\n  flex: 1;\n  height: 100%;\n  background-color: transparent;\n  border: 0;\n  margin-left: 5px;\n  font-size: inherit;\n  color: inherit;\n  outline: 0;\n  transition: color 0.25s;\n}\n.search input[data-v-fa36b44e]:focus {\n  color: #3ba776;\n}\n.search input[data-v-fa36b44e]::placeholder {\n  opacity: 0.8;\n}\n.search input.invalid[data-v-fa36b44e] {\n  color: #4d0a09;\n}\n", "", {"version":3,"sources":["G:/luobata/lib/match-devtools/src/components/src/components/matchTab/actionTab.vue","G:/luobata/lib/match-devtools/src/components/matchTab/actionTab.vue"],"names":[],"mappings":";AASA;EACE,cAAA;EACA,qBAAA;EACA,gBAAA;EACA,gBAAA;EACA,8BAAA;EACA,YAAA;EACA,aAAA;CCRD;ADS0B;AAAA;IACvB,aAAA;CCND;CACF;ADMC;EACE,iCAAA;CCJH;ADMD;EACE,cAAA;EACA,oBAAA;EACA,gBAAA;EACA,eAAA;CCJD;ADMD;EACE,gBAAA;EACA,cAAA;EACA,oBAAA;EACA,wBAAA;EACA,gBAAA;EACA,0BAAA;EACA,oBAAA;EACA,aAAA;EACA,iBAAA;CCJD;ADMC;EACE,kBAAA;CCJH;ADMC;EACE,WAAA;EACA,eAAA;CCJH;ADMC;EACE,cAAA;EACA,oBAAA;CCJH;ADMC;EACE,cAAA;CCJH;ADK2B;AAAA;IACtB,gBAAA;CCFH;CACF;ADGD;EACE,gBAAA;EACA,gBAAA;EACA,eAAA;CCDD;ADEyB;AAAA;IACtB,kBAAA;CCCD;CACF;ADAD;EACE,cAAA;EACA,oBAAA;EACA,QAAA;CCED;ADDC;EACE,QAAA;EACA,aAAA;EACA,8BAAA;EACA,UAAA;EACA,iBAAA;EACA,mBAAA;EACA,eAAA;EACA,WAAA;EACA,wBAAA;CCGH;ADFG;EACE,eAAA;CCIL;ADFG;EACE,aAAA;CCIL;ADFG;EACE,eAAA;CCIL","file":"actionTab.vue","sourcesContent":["\n\n\n\n\n\n\n@import \"../../variables\"\n\n.action-header\n  display flex\n  align-items stretch\n  padding 0 10px\n  font-size 12px\n  border-bottom 1px solid $border-color\n  color #666\n  height 35px\n  @media (min-height: $tall)\n    height 50px\n  .app.dark &\n    border-bottom 1px solid $dark-border-color\n\n.title\n  display flex\n  align-items center\n  font-size 18px\n  color $component-color\n\n.button\n  cursor pointer\n  display flex\n  align-items center\n  justify-content center\n  padding 0 10px\n  transition opacity 0.25s\n  white-space nowrap\n  opacity 0.8\n  overflow hidden\n\n  &:first-of-type\n    margin-left auto\n\n  &:not(.disabled):hover\n    opacity 1\n    color $active-color\n\n  &.disabled\n    opacity 0.45\n    cursor not-allowed\n\n  span\n    display none\n    @media (min-width: $wide)\n      display inline\n\n.material-icons\n  font-size 18px\n  margin-right 0\n  color inherit\n  @media (min-width: $wide)\n    margin-right 5px\n\n.search\n  display flex\n  align-items center\n  flex 1\n  input\n    flex 1\n    height 100%\n    background-color transparent\n    border 0\n    margin-left 5px\n    font-size inherit\n    color inherit\n    outline 0\n    transition color 0.25s\n    &:focus\n      color $active-color\n\n    &::placeholder\n      opacity 0.8\n\n    &.invalid\n      color rgba(77, 10, 9, 1)\n",".action-header {\n  display: flex;\n  align-items: stretch;\n  padding: 0 10px;\n  font-size: 12px;\n  border-bottom: 1px solid #ddd;\n  color: #666;\n  height: 35px;\n}\n@media (min-height: 300px) {\n  .action-header {\n    height: 50px;\n  }\n}\n.app.dark .action-header {\n  border-bottom: 1px solid #3a3a3a;\n}\n.title {\n  display: flex;\n  align-items: center;\n  font-size: 18px;\n  color: #3ba776;\n}\n.button {\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0 10px;\n  transition: opacity 0.25s;\n  white-space: nowrap;\n  opacity: 0.8;\n  overflow: hidden;\n}\n.button:first-of-type {\n  margin-left: auto;\n}\n.button:not(.disabled):hover {\n  opacity: 1;\n  color: #3ba776;\n}\n.button.disabled {\n  opacity: 0.45;\n  cursor: not-allowed;\n}\n.button span {\n  display: none;\n}\n@media (min-width: 820px) {\n  .button span {\n    display: inline;\n  }\n}\n.material-icons {\n  font-size: 18px;\n  margin-right: 0;\n  color: inherit;\n}\n@media (min-width: 820px) {\n  .material-icons {\n    margin-right: 5px;\n  }\n}\n.search {\n  display: flex;\n  align-items: center;\n  flex: 1;\n}\n.search input {\n  flex: 1;\n  height: 100%;\n  background-color: transparent;\n  border: 0;\n  margin-left: 5px;\n  font-size: inherit;\n  color: inherit;\n  outline: 0;\n  transition: color 0.25s;\n}\n.search input:focus {\n  color: #3ba776;\n}\n.search input::placeholder {\n  opacity: 0.8;\n}\n.search input.invalid {\n  color: #4d0a09;\n}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 29 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff2;base64,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"

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff2;base64,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"

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDE0IDc5LjE1Njc5NywgMjAxNC8wOC8yMC0wOTo1MzowMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OTk2QkI4RkE3NjE2MTFFNUE4NEU4RkIxNjQ5MTYyRDgiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OTk2QkI4Rjk3NjE2MTFFNUE4NEU4RkIxNjQ5MTYyRDgiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NjU2QTEyNzk3NjkyMTFFMzkxODk4RDkwQkY4Q0U0NzYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NjU2QTEyN0E3NjkyMTFFMzkxODk4RDkwQkY4Q0U0NzYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5WHowqAAAXNElEQVR42uxda4xd1XVe53XvvD2eGQ/lXQcKuDwc2eFlCAGnUn7kT6T86J/+aNTgsWPchJJYciEOCQ8hF+G0hFCIHRSEqAuJBCqRaUEIEbmBppAIBGnESwZje8COZ+y587j3PLq+ffadGJix53HvPevcuz60xPjec89ZZ+39nf04+9vLSZKEFArFzHA1BAqFEkShUIIoFEoQhUIJolAoQRQKJYhCoQRRKJQgCoUSRKFQKEEUCiWIQrFo+Gv/8/YH+f/nsMWSHHMChyhxqPTTdyncWyJ3ScD/ztipiB3wXSqu6P17avN+TyFC5ggv4tRnmoxWTP1+5F+Mz17GPvPl49EKBWd3UsfXllPiso8VcYtmPba3fNuKrBVXrGFCbrdPwXndFL49ltI367roOpSUI4pGypv9s7q+ltj6JxqOQ07Bo/DgxGb2/a8cX0CnAWXJ5etz2TqdHiXHKlKj9w6i9XX8Ic41DmI8FVHhmmXk85MmRhCzJoiTWnig9LfJRHihgydxzAxJhBr7Bh/hK3yu+p9568FliTJF2aKMZfVd/kQOcKP6OBmS9+Rjm4zJ6faoeN0gOUn61MncLX4CJ+MRhe+P/dRxhfew2Df4CF/hs4jWg8vQYUKYMuWyRRkLjeHQ8YP0Z9mekVjA8Qj3VVcuoeDiXu63lkUE0ym6FA5PXBaNVr7qtPumGyPR4Bt8hK/wWUR5chn6XJYoU5StUHL8l+XEx2axhkS6yk+chJuP4rXLyOkIKJkS0B67adcqfL/0Y4pixxSysK6V8Yl9Mz7i3272NRFlhzJsu24Z5l9E9Ahmwfrpoj7uw3fZtktsRZKjIXnndlLxin7+W8ZTBwPf6I+Tg9HwxK2Ob8citbCoBoaxBxMCvsFH+CqjHCtUvLzflKWUcpwB91gupG5f9/Rtx39ZZBtmWyJtphKzHTQW0diP36b4aJmcLj/zGaSkHJPb4SWFi/tOJd8bTqd9s48VBRh4RKeUX/vjgXg8cpyCmz05xkJylxSoa8M5RF0eJaVIIkGOsg2yTc3UgpD94psiWxEOqDNYoOIXuHnGwE5AXUTFi46FTnRw4l/dwEm7/pSxcYnCF/gE3zInh52RRJkVP7/MlKFQcgCbjifHTAQBfsb2qsgBO3e1Cpf3UXBej3nRJKKrxU/rcH/pKzz4vNIQuRJTEmZklbg6EL4SPsE3GQPzinmfhbJDGQolB+r8w58abs5y8DqRt4ABeptLRR7koY9NleybEYw/MPisvF/ayT1/SvDewcnIcG32wfiCAbEvoCZyGaGsitdyz6XdTctQJq6fcT5mloNfYvu5yFZkpEz+RT0UrFoqpxVBV+vQxIrkaPnrbqdvXs6hcjbU+Jq4Nvvwd/BFRNeq2npwWfkX95iyE9p6PM72P/MhCPANTBSKu5WITHcC074Y9CUTkYglKBgcV/aVtlM5Kpp/RHFjDdfka7MP/2wG6m72661QNigjlBXKTGBtsjWKNs5atCf44Uds3xc5YD8Wknd2BxWuGjCzIxLWQzlFj+IjU108OL7bafM5sm5DDdfka/8T+9AJXyTMpqFsUEYoK5SZ0NbjVlvX500Q4Ha2A+JuCcEvhVS8qp/8MzspHhMSfO7mVPaP35BMRp9JsCQldbX+hmvxNfnamzJfqVvtWnGZoGxQRigroYs6UbfvOGHn4ORVkTaIbEWwtqg3MNO+Zql0JGCdVuCayhDuG9uJB7vp+oR17FbZc+NauCauLWLmKkqXr6NsUEYoK6GtxwY6CXXnEs0n2faIHLCPhhR8bikFKwRN+xZddHWu5a7Ol9yCZ2ZwHKdOxufGNeKRqS/hmnLWW1VMmQSrl5oyEkqOPbZu02IJAsic9sU7B+5uF9cOmqUfeLOdOaAZYb/CA+M/Ic9NxUoYMNfD/PT84f7xB807EAnrrbgMUBZt1w1SEpCIqfjF1Om5EuQNth0iu1r8tPLP76LCpX2yWpHDk2dGH018p6brtD5hOHf04cR3okOTZ0lqPVAW3gVdlMhdrfsTW6drRhDgRrYJcbeKZQxTkenvegNt6YBQwrQvOxG+P3ZHEia9TuClS9Br1XKge8XnxLlxjelzZ/2w4tijDMxyoHIsVQg1zvYPcy7KeZx4jG2zyFakFJF7Whu1XT2QvhfJeryeVNdplYPo4Pi9hKd7VVxVC8O5cH4+N65hXgoKuGfEHmWAskjGxI49Ntu6XHOCAD9ie1PcLSepjDNY00fB8m6KpSyJx/jgg9LfJEfLK40818w+LXY5e5zKaMfKl+DcIlSCZp0cd3U59igDI4+WOa2LunvfvDoD9RrcNLqAjDy3yzfrtKqbAkggSDIZmSlYxzz9a8BaJ101zF2rh3BuSTJaCKGMDEGujHbedXch0X2ebbdEkkDC6a9cQoWVguS53P0JP5xcHY1W/tppD9KxgrdAw5QxnwPn4nOukrPeqkzBJb0m9oJltLtt3a07QYD1IkMAeS7/hw0BXMhzJwXJc/eV7kuiyIN8OOGuUhLP06JUeoxz4FxiZLRouTsDM9WO2OdBRtsIgrzHtk3kgH00JO+cTipc2S9jqyCaluf2xwcnfuB6LndHuEsSzdP4N/gtzoFzSZHRIsaQQiPmidyXgttsnW0YQYDvsh2ROGBPxkMqXjNA/qlCFsnZ8UdlX+kfk0pymlnMWH2JOBfz0sWI+C3OMS1dzPphhPVWHOPC5wdMzIUOzFFHb1lwB2ARF+ZOPt0gshWBPLe/wCRZlu6CIkSei/cE0fD4g2ZbVWceyxH5WPwGvzXrrSTJaDnG7oBoGS3qaCULggCPsv1W5IAd8tzLllJwvpx1WthMIfyg9OVotHy1WVQ4V37wsfgNfkuSZLQcW8Q4lruU/RVbRykrggDXiwwN3uQWnXTa1xMkz2W/on2lndNajpNtAGePw2/MOicBMlqs+8K7GBNbjrFgGe2iX0nUgiAvs+0S2YpgndaFPVRc3SdmVanZlfGjifOiw5PrT/oGvPpG/vDkEH4jZ70Vt86rl5rYimmdP41/s3Uzc4Isup9XNxwvz+0tyNAlONPrtO6hctR+QnluKqNt52O3pxvtClhvxTH0egtmEwbBMlrUxU21OFGtCHKYbavIATv3j90z26kIea4QZRtahfhIuT0anrjH7O3rpjNVHzPIaLG3Lh8Tj5TbRQihjlNyehxTwTLarbZOiiEIcBfbPnGhMtroChXW9JN/VqeYdyPEY4nwwPj6ZCL8C1T+T61JhDqRv8MxZgwlJG2BxzEsrBmgeEzseqt9ti6SNIIA8t6wm901eFDZ66d7M4UkQ56LVgTTvvtKaRqFqoTWymjxGb6LpUzrImYcuzaOIWKJmAptPWpaB2sd+V+yvSB1wB6s7qXgwiUyBpbJdBqFq6MjU18mKCKhRsTyEbx558/wnRmYJzLiV+DYBat6JQ/MX7B1UCxBAKHy3IQrH6W7MhY9MWkUMNAN948/8Mm35/jMDIKlpC3gmBWQtsAjifkE61b36kGQP7DdL7KrVZXnXiYpjYKZxj09Gh7f4kB4yIa/8ZmU1brIIYiYIXaJ3Nbjflv3xBME+DZbSVwIzfIIK89dJkSea18Ihu+XflD9yPztCJnW5Ri5VRntpNh8giVb5ygvBIHu9yaRrchYRO6fFU0CSTPQlDLte6zshx9O3g3D3yJajySd4EDaAsQMsRPaetxk61zty+YTCXRqjf9jO19cOLnyYV+p8QffpcreMXJ7BeRgh77Ds6SIYhGbMBgB2tld1DW0nGL4VxbZfKBbdUHdhol1dl7mOi0MOjttGgWT11lAwU9r1mMSsX0oxwSxgYyWOvKXtiAvBPkV239I7GqZdVqX9FDw2V5+UoYipn2nt/WRMK3LMQlW9poYCZ7WfcrWsdwSBNggMrRYdcLdhjas0+q28lzJOc8bOU7jWLh2AwzEyLxclYm6Z2ZuBEE+YLtTZEVA9tzPdBh5biJ3q5rGD8yRjXbNAPkcm0RuyjTUqf3NQBDge2yHJFaGeDyi4tUD5J3WIXmzs8Y9NDgG3un80OCYIDZCHxqHbJ2iZiEIGmnB8twgzYIkd7vMxiBON59GLJyBQLKMdiM1qOPXyMn2f2f7X5EDdshzkUbhAtED0oZMXCAGiIXgtAW/YXusURdr9NsoufLcgmP20zKy2ErrNSNGRuunMUAshL7zABq61q/RBPkd2yNSn57+X3ZTQZA8t7H3H5p7RwwEt6KP2DrUtAQBIIUsiwt99Kf+tydFntuocVhVRltNWyBTRlumGslopRNkhO1mkRVlLCT3jHYzqyU48WSN+1ZWRou0BZDRyp3Ju9nWnaYnCHA3216JlQWy0gKy557dJSaNQn0nKNL1VrhnwTLavbbOUKsQBBApzzVpFHqsPFdIGoW6AfeG7cMwrcv3TC0io80LQZ5me07kU3WkYqSlhYvkpFGoz8C8bO7RyGjlpi14ztaVliMIIFOeizQKbpI+WdsDGfLcWvcmsaK53b4gdUW3lENZXjxrgrzNdq/IAftohbzzOql4eV/zjUUcu96K7w33KFhGi7rxVisTBEBSxWPiiqYqz71mGfmDQuS5tSIHstHyPZnd7+XKaI+RgKSxEggySWmKaXkVaSwi5xSbRmGiSdZpxVZGy/eEexMso73R1o2WJwiwk+11kQNZrNO6oo+Cc7vz39Wy07q4l+CKfnNvQu/ndVsnSAkifcCOAXq7R8W1y9JdRvI87QvfnTRtgdPeujLavBLkv9meEPnUHS2Tf1EPFT67lOKRnE77munrsrkH/+IeydPXqAO/VoLMDMhz5T2irTzXpFHoKeRPnluV0XYX0mlduTLamIRJtKUR5CDbbSIrGPfX/eUdVFyTQ3luku6OaNIW/HmH5LQFt9k6oAQ5Ab7PNiyxkmGndUhRvTNyJM9F1wrZaM9IZbQmG63MocewxIejRIKg+DaKbEXGI3KWBtT2hUFKyonUZeEfB3xkX4vsM3wXvIx/IwmMqCu0WH/B9qLIpzG6Wp/rpWBFj/x1WnaCAb4G7LPgad0XbZmTEmTukDnti0yzgZvKcwNPtDzXyGjZR5ONFincVEbbVAR5je0hkU/lkTL5F3TZzQ2EvjysJr1hH/0LuiVPTz9ky1oJsgB8iwQsN5hplISns5Hn9hXl9eurMlr2zUzrVsQuk5m0ZUxKkIXhKNsWkQN2yHNPhzx3WbqQMRZGYCOjXWZ8FDzjtsWWsRJkEfgh2zvyOvhWnovsucu75GTPtdlo4RN8i+W+s3nHli0pQRaPIXEeVeW53V46YJciz2Uf4IvxiX0juW/9h/JQ8fJCkGfZnpE5YK9QsHIJBZcIkOdW141d3Gt8EiyjfcaWqRKk6Z84kOc6duODjmzluUZGyz4g6Q18UhltaxHkXbbtIgfsRyvknQt5bobZc6dltP3Gl0SudmW7LUslSJ1mPUbFeWVUepDnDpB3SgazRtW0BXxt+ABfhE7rypyVbCKCTLF9U2QrgjQKg3b7zskGv3eI0+XsuDZ8EJy2YJMtQyVIHfEztldFDtghz728j4LzGphGoZq2gK9ZMDuwiH3ngTJ7OG+VLY8EAeTKc9ts9lwk42zEOi2st+JrYZIA1xYso12Xx4qWV4K8xPZzka3ISCrPDVY1YJ1WtfVYZWW0ctdbPW7LTAnSQHyDJCoykEYhTNdpuUsK6YDZqQ85cG5cw6y3CsWmLYBXG/NayfJMkI8oVR/KG7AfC8k7u4MKVw2kM1r1eB2RpDNXuAauJVhGe6stKyVIBrid7YA4r6o5N5BG4cxOI3mtaeWtymj53LiG4FwmKJs78lzB8k4QVIsN4ryqynN7AzP1ShXIc2tYg3GuSpJO6/aKltHK3KWmhQgCPMm2R+SAfTSkANlzV9Rw2rc6MDcyWtHZaPfYsiElSPaQOYVYiSnxiIprB8kpeGn+v8U2mZD8FjxzTpybKjqtqwQ5Od5g2yGyq4Xsued3UeHSvsW3IlUZLZ8L5xSctmCHLRMliCBgN/AJcV7F6SpbjBe8gUWkUaimLeBzmOUsU2JltOMkcbd+JQiNkYB8ErNVbPe0Nmq72i4kXMiwNUnfe+AcOJfgfCWbbVkoQQTiR2xvivPKynODNX0ULF9AGoVq2gL+Lc4hWEaL2N/XTBWq2Qgic3BYled2+ekeVfOV51az0WKNF59DsIx2XbNVpmYkyPNsuyWSBBJYf+USKsxHnlvNRsu/8WXLaHfb2CtBcoD1Ir2CPJf/wxSt2xmkupGT9c6QtoCPNdO66FfJldGub8aK1KwEeY9tm8gB+2hI3jmdVLii/+RbBdktfHAsfpPIfSm4zcZcCZIjfJftiMQBO1IQQBrrn3qCRYZ20SOOMTLacbHrrRDjW5q1EjUzQbiTTzeIbEUgz+232XNne59RfX+CbLT9omW0iHFFCZJPPMr2W5EDdshzL1tKwfkzrNOqrrfi73CMYBntKzbGpATJL64X6RXWZRVtxlnP+VgaBZO2wEu/wzGatkAJUk+8zLZLZCuCdVoXciux+rhVuXYVMD7Dd7Hc9Va7bGyVIE0Amf3kaXnuIHm9qTwXhr/xmWAZbUXk+E4JsmAcZtsqcsAOee6Z7VS08lwY/sZngmW0W21MlSBNhLvY9onzCqtIxipUuKqf3L6iMfyNz4RO6+6zsWwJ+NRawNvep8S1IhMxucie+8VT0o+6PIqPiB17rG+lCtNqBPkl2wts14gbsCONwqVLzT8Fr7d6wcawZeBS60Hm1GSSTu+a6d5EY6cEyQ5/YLtf4oCd4iQ1ma3H/TZ2SpAWwLfZSqSYK0o2ZqQEaQ1AN32T1vs54yYbMyVIC+GBVuwyLLBL+kCr3rzb4oV/vdZ/jZESZHb8iqS9F5GFp2yMlCAtjCENgcZGCTI79rPdqWH4FO60sVGCKOh7bIc0DNM4ZGNCShAFEFKOsyDVARttTJQgGoJpPMb2Gw2DicFjGgYlyExYpyHQGChBZsfv2B5p4ft/xMZAoQSZFZso3TKo1VC2965QgpwQI2w3t+B932zvXaEEOSnuZtvbQve7196zQgkyZ6zXe1UoQWbH02zPtcB9PmfvVaEEmTeG9B6VIIrZ8RbbvU18f/fae1QoQRYMJKU81oT3dYwkJj1VguQOk9REaY2Pw4323hRKkEVjJ9vrTXQ/r9t7UihBaobr9V6UIIrZ8Wu2J5rgPp6w96JQgtQcG2jmhGl5QWzvQaEEqQsOst2WY/9vs/egUILUtZIN59Dv4ZyTWwmSEyDnUx7luRtJar4qJUjT4RdsL+bI3xetzwolSMOwTn1Vgihmx2tsD+XAz4esrwolSMPxLZK9XGPS+qhQgmSCo2xbBPu3xfqoUIJkhh+yvSPQr3esbwolSOYYUp+UIIrZ8SzbM4L8ecb6pFCC6BNbWw8lSB7wLtt2AX5st74olCDikPWskfRZNSVIi2OKst2+c5P1QaEEEYuH2V7N4Lqv2msrlCDisa5FrqkEUSwIL7E93sDrPW6vqVCC5AaN0l/kVZ+iBGlxfMR2awOuc6u9lkIJkjvcwXagjuc/YK+hUILkEgnVdxeRDfYaCiVIbvEk2546nHePPbdCCZJ7rMvJORVKkEzwBtuOGp5vhz2nQgnSNMBu6uM1OM84Nedu80qQFscY1SYfx2Z7LoUSpOlwH9ubi/j9m/YcCiWIDth1YK4EaUU8z7Z7Ab/bbX+rUII0PdY36DcKJUgu8R7btnkcv83+RqEEaRncwnZkDscdsccqlCAthQrbDXM47gZ7rEIJ0nJ4lO2VE3z/ij1GoQRpWaxb4HcKJUhL4GW2XTN8vst+p1CCtDw+Oc6Y6/hEoQRpCRxm23rcv7fazxRKEIXFXZRuwBDZvxUC4GsIREHflguDkyQqaVYotIulUChBFAoliEKhBFEolCAKhRJEoVCCKBRKEIVCCaJQKJQgCoUSRKFQgigUShCFIhP8vwADACog5YM65zugAAAAAElFTkSuQmCC"

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(46)
  __webpack_require__(47)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(15),
  /* template */
  __webpack_require__(39),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-3499c881",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\App.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] App.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3499c881", Component.options)
  } else {
    hotAPI.reload("data-v-3499c881", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(18),
  /* template */
  __webpack_require__(41),
  /* styles */
  null,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\matchContent\\matchContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] matchContent.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-82d266b4", Component.options)
  } else {
    hotAPI.reload("data-v-82d266b4", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(51)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(16),
  /* template */
  __webpack_require__(44),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-ecaaf5a8",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\matchObj\\dataField.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] dataField.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-ecaaf5a8", Component.options)
  } else {
    hotAPI.reload("data-v-ecaaf5a8", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(50)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(19),
  /* template */
  __webpack_require__(43),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\matchObj\\matchObj.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] matchObj.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-e1cca234", Component.options)
  } else {
    hotAPI.reload("data-v-e1cca234", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(52)
}
var Component = __webpack_require__(1)(
  /* script */
  null,
  /* template */
  __webpack_require__(45),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-fa36b44e",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\matchTab\\actionTab.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] actionTab.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-fa36b44e", Component.options)
  } else {
    hotAPI.reload("data-v-fa36b44e", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(48)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(17),
  /* template */
  __webpack_require__(40),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-3d0b1c2c",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "G:\\luobata\\lib\\match-devtools\\src\\components\\splitPane\\splitPane.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] splitPane.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3d0b1c2c", Component.options)
  } else {
    hotAPI.reload("data-v-3d0b1c2c", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    class: {
      app: true, dark: _vm.isDark
    },
    attrs: {
      "id": "app"
    }
  }, [_c('div', {
    staticClass: "header"
  }, [_c('img', {
    staticClass: "logo",
    attrs: {
      "src": __webpack_require__(32),
      "alt": "Vue"
    }
  }), _c('span', {
    staticClass: "message-container"
  }, [_c('transition', {
    attrs: {
      "name": "slide-up"
    }
  }, [_c('span', {
    key: _vm.message,
    staticClass: "message"
  }, [_vm._v(_vm._s(_vm.message))])])], 1), _c('a', {
    staticClass: "button components",
    class: {
      active: _vm.tab === 'match'
    },
    attrs: {
      "title": "Switch to Components"
    }
  }, [_c('i', {
    staticClass: "material-icons"
  }, [_vm._v("device_hub")]), _c('span', {
    staticClass: "pane-name"
  }, [_vm._v("Components")])]), _c('a', {
    staticClass: "button refresh",
    attrs: {
      "title": "Force Refresh"
    },
    on: {
      "click": _vm.refresh
    }
  }, [_c('i', {
    ref: "refresh",
    staticClass: "material-icons"
  }, [_vm._v("refresh")]), _c('span', {
    staticClass: "pane-name"
  }, [_vm._v("Refresh")])]), _c('span', {
    staticClass: "active-bar"
  })]), _c('match', {
    staticClass: "container"
  })], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-3499c881", module.exports)
  }
}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "split-pane",
    class: {
      dragging: _vm.dragging
    },
    on: {
      "mousemove": _vm.dragMove,
      "mouseup": _vm.dragEnd,
      "mouseleave": _vm.dragEnd
    }
  }, [_c('div', {
    staticClass: "left",
    style: ({
      width: _vm.split + '%'
    })
  }, [_vm._t("left"), _c('div', {
    staticClass: "dragger",
    on: {
      "mousedown": function($event) {
        $event.preventDefault();
        _vm.dragStart($event)
      }
    }
  })], 2), _c('div', {
    staticClass: "right",
    style: ({
      width: (100 - _vm.split) + '%'
    })
  }, [_vm._t("right")], 2)])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-3d0b1c2c", module.exports)
  }
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('split-pane', [_c('component-tree', {
    slot: "left"
  }), _c('match-obj', {
    attrs: {
      "stacks": _vm.matchArr
    },
    slot: "right"
  })], 1)], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-82d266b4", module.exports)
  }
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "match"
  }, [_c('action-header', {
    slot: "header"
  }, [_c('div', {
    staticClass: "search"
  }, [_c('i', {
    staticClass: "material-icons"
  }, [_vm._v("search")]), _c('input', {
    attrs: {
      "placeholder": "Filter components"
    },
    on: {
      "input": _vm.filterStacks
    }
  })])])], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-d6fa3eb4", module.exports)
  }
}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "data-wraper"
  }, _vm._l((_vm.stacks), function(item) {
    return _c('div', {
      staticClass: "data-fields"
    }, [_c('div', {
      staticClass: "data-type"
    }, [_vm._v("beforeParams")]), (Array.isArray(item.beforeParams)) ? _vm._l((item.beforeParams), function(field) {
      return _c('data-field', {
        key: field,
        attrs: {
          "field": field,
          "depth": 0
        }
      })
    }) : _vm._l((item.beforeParams), function(value, key) {
      return _c('data-field', {
        key: key,
        attrs: {
          "field": {
            value: value,
            key: key
          },
          "depth": 0
        }
      })
    }), _c('div', {
      staticClass: "data-type"
    }, [_vm._v("afterParams")]), (Array.isArray(item.afterParams)) ? _vm._l((item.afterParams), function(field) {
      return _c('data-field', {
        key: field,
        attrs: {
          "field": field,
          "depth": 0
        }
      })
    }) : _vm._l((item.afterParams), function(value, key) {
      return _c('data-field', {
        key: key,
        attrs: {
          "field": {
            value: value,
            key: key
          },
          "depth": 0
        }
      })
    })], 2)
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-e1cca234", module.exports)
  }
}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "data-field"
  }, [_c('div', {
    staticClass: "self",
    style: ({
      marginLeft: _vm.depth * 14 + 'px'
    }),
    on: {
      "click": _vm.toggle
    }
  }, [_c('span', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.isExpandableType),
      expression: "isExpandableType"
    }],
    staticClass: "arrow right",
    class: {
      rotated: _vm.expanded
    }
  }), _c('span', {
    staticClass: "key"
  }, [_vm._v(_vm._s(_vm.field.key))]), _c('span', {
    staticClass: "colon"
  }, [_vm._v(":"), (_vm.field.meta) ? _c('div', {
    staticClass: "meta"
  }, _vm._l((_vm.field.meta), function(val, key) {
    return _c('div', {
      staticClass: "meta-field"
    }, [_c('span', {
      staticClass: "key"
    }, [_vm._v(_vm._s(key))]), _c('span', {
      staticClass: "value"
    }, [_vm._v(_vm._s(val))])])
  })) : _vm._e()]), _c('span', {
    staticClass: "value",
    class: _vm.valueType
  }, [_vm._v(_vm._s(_vm.formattedValue))])]), (_vm.expanded && _vm.isExpandableType) ? _c('div', {
    staticClass: "children"
  }, [_vm._l((_vm.limitedSubFields), function(subField) {
    return _c('data-field', {
      key: subField.key,
      attrs: {
        "field": subField,
        "depth": _vm.depth + 1
      }
    })
  }), (_vm.formattedSubFields.length > _vm.limit) ? _c('span', {
    staticClass: "more",
    style: ({
      marginLeft: (_vm.depth + 1) * 14 + 10 + 'px'
    }),
    on: {
      "click": function($event) {
        _vm.limit += 10
      }
    }
  }, [_vm._v("\n      ...\n    ")]) : _vm._e()], 2) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-ecaaf5a8", module.exports)
  }
}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "action-header"
  }, [_vm._t("default")], 2)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-fa36b44e", module.exports)
  }
}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(22);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("dbac6168", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3499c881\",\"scoped\":false,\"hasInlineConfig\":false}!../node_modules/stylus-loader/index.js!./global.styl", function() {
     var newContent = require("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3499c881\",\"scoped\":false,\"hasInlineConfig\":false}!../node_modules/stylus-loader/index.js!./global.styl");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(23);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("519ef131", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3499c881\",\"scoped\":true,\"hasInlineConfig\":false}!../node_modules/stylus-loader/index.js!../node_modules/vue-loader/lib/selector.js?type=styles&index=1!./App.vue", function() {
     var newContent = require("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3499c881\",\"scoped\":true,\"hasInlineConfig\":false}!../node_modules/stylus-loader/index.js!../node_modules/vue-loader/lib/selector.js?type=styles&index=1!./App.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(24);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("3deabcb0", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3d0b1c2c\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./splitPane.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3d0b1c2c\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./splitPane.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(25);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("59a22f0b", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-d6fa3eb4\",\"scoped\":true,\"hasInlineConfig\":false}!./match.css", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-d6fa3eb4\",\"scoped\":true,\"hasInlineConfig\":false}!./match.css");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(26);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("0e98de01", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-e1cca234\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./matchObj.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-e1cca234\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./matchObj.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(27);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("30049f50", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-ecaaf5a8\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dataField.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-ecaaf5a8\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dataField.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(28);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("045cb374", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-fa36b44e\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./actionTab.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-fa36b44e\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/stylus-loader/index.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./actionTab.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 53 */
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {/*!
 * Vue.js v2.4.2
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

var _toString = Object.prototype.toString;

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(val);
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str
    .replace(hyphenateRE, '$1-$2')
    .replace(hyphenateRE, '$1-$2')
    .toLowerCase()
});

/**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */


/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

var warn = noop;
var tip = noop;
var formatComponentName = (null); // work around flow check

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var name = typeof vm === 'string'
      ? vm
      : typeof vm === 'function' && vm.options
        ? vm.options.name
        : vm._isVue
          ? vm.$options.name || vm.$options._componentTag
          : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  var generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

function handleError (err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (process.env.NODE_ENV !== 'production') {
      warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err
    }
  }
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefix has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = (function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function (err) { console.error(err); };
    timerFunc = function () {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) { setTimeout(noop); }
    };
  } else if (typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function () {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve, reject) {
        _resolve = resolve;
      })
    }
  }
})();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */


var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value)) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this) : parentVal
      )
    }
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm)
        : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn.call(this, parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal
    ? extend(res, childVal)
    : res
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (parentVal, childVal) {
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + key
      );
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options) {
  var inject = options.inject;
  if (Array.isArray(inject)) {
    var normalized = options.inject = {};
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = inject[i];
    }
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child);
  normalizeInject(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (process.env.NODE_ENV !== 'production') {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      'Invalid prop: type check failed for prop "' + name + '".' +
      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    valid = typeof value === expectedType.toLowerCase();
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isType (type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type)
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true
    }
  }
  /* istanbul ignore next */
  return false
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      "referenced during render. Make sure to declare reactive data " +
      "properties in the data option.",
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' &&
    Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  return cloned
}

function cloneVNodes (vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      process.env.NODE_ENV !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        (last).text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (comp.__esModule && comp.default) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      process.env.NODE_ENV !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && isDef(c.componentOptions)) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (process.env.NODE_ENV !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) &&
      child.data && child.data.slot != null
    ) {
      var name = child.data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots
}

function isWhitespace (node) {
  return node.isComment || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure((name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure((name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listensers hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs;
  vm.$listeners = listeners;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options
) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production'
    ? expOrFn.toString()
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse (val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function checkOptionType (vm, name) {
  var option = vm.$options[name];
  if (!isPlainObject(option)) {
    warn(
      ("component option \"" + name + "\" should be an object."),
      vm
    );
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      if (isReservedAttribute(key) || config.isReservedAttr(key)) {
        warn(
          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  observerState.shouldConvert = true;
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  try {
    return data.call(vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  if (process.env.NODE_ENV !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn(
          "method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
    }
  }
}

function initWatch (vm, watch) {
  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  keyOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
        ? Reflect.ownKeys(inject)
        : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (process.env.NODE_ENV !== 'production' && !source) {
        warn(("Injection \"" + key + "\" not found"), vm);
      }
    }
    return result
  }
}

/*  */

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  context,
  children
) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || {});
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
  var vnode = Ctor.options.render.call(null, h, {
    data: data,
    props: props,
    children: children,
    parent: context,
    listeners: data.on || {},
    injections: resolveInject(Ctor.options.inject, context),
    slots: function () { return resolveSlots(children, context); }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    vnode.functionalOptions = Ctor.options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options)
}

function mergeHooks (data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1 (one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    warn(
      'Avoid using non-primitive value as key, ' +
      'use string/number value instead.',
      context
    );
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) { applyNS(vnode, ns); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && isUndef(child.ns)) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      props = extend(extend({}, bindObject), props);
    }
    return scopedSlotFn(props) || fallback
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && process.env.NODE_ENV !== 'production') {
      slotNodes._rendered && warn(
        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
        "- this will likely cause render errors.",
        this
      );
      slotNodes._rendered = true;
    }
    return slotNodes || fallback
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias
) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1
  } else {
    return keyCodes !== eventKeyCode
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] =
    this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      process.env.NODE_ENV !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(ours, existing) : ours;
      }
    }
  }
  return data
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);
    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);
  }
}

function renderMixin (Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        vnode = vm.$options.renderError
          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
          : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
  Vue.prototype._g = bindObjectListeners;
}

/*  */

var uid = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = "vue-perf-init:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(((vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue$3 (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue$3)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn(
          'Invalid component name: "' + name + '". Component names ' +
          'can only contain alphanumeric characters and the hyphen, ' +
          'and must start with a letter.'
        );
      }
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && config.isReservedTag(id)) {
            warn(
              'Do not use built-in or reserved HTML elements as component ' +
              'id: ' + id
            );
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp, Array];

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (cache, current, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        if (cachedNode !== current) {
          pruneCacheEntry(cachedNode);
        }
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry (vnode) {
  if (vnode) {
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created () {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include (val) {
      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });
    },
    exclude: function exclude (val) {
      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });
    }
  },

  render: function render () {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (
        (this.include && !matches(this.include, name)) ||
        (this.exclude && matches(this.exclude, name))
      )) {
        return vnode
      }
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

Vue$3.version = '2.4.2';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);



var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setAttribute (node, key, val) {
  node.setAttribute(key, val);
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

// Some browsers do not support dynamically changing type for <input>
// so they need to be treated as different nodes
function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          inPre++;
        }
        if (
          !inPre &&
          !vnode.ns &&
          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
          config.isUnknownElement(tag)
        ) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
            warn(
              'It seems there are duplicate keys that is causing an update error. ' +
              'Make sure each v-for item has a unique key.'
            );
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true
    }
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode)) {
        return false
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (process.env.NODE_ENV !== 'production' &&
              typeof console !== 'undefined' &&
              !bailed
            ) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode) {
    if (isDef(vnode.tag)) {
      return (
        vnode.tag.indexOf('vue-component') === 0 ||
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, key);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;



function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + "," + args)
  }
}

/*  */

/*  */

/**
 * Cross-platform code generation for component v-model
 */


/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var str;
var index$1;

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  var event;
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
  if (once$$1) {
    var oldHandler = handler;
    var _target = target$1; // save current target element in closure
    handler = function (ev) {
      var res = arguments.length === 1
        ? oldHandler(ev)
        : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (
  elm,
  vnode,
  checkVal
) {
  return (!elm.composing && (
    vnode.tag === 'option' ||
    isDirty(elm, checkVal) ||
    isInputChanged(elm, checkVal)
  ))
}

function isDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isInputChanged (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number) {
    return toNumber(value) !== toNumber(newVal)
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim()
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likley wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame
  ? window.requestAnimationFrame.bind(window)
  : setTimeout;

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted (el, binding, vnode) {
    if (vnode.tag === 'select') {
      var cb = function () {
        setSelected(el, binding, vnode.context);
      };
      cb();
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(cb, 0);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        trigger(el, 'change');
      }
    }
  }
};

function setSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$options._renderChildren;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log'](
        'Download the Vue Devtools extension for a better development experience:\n' +
        'https://github.com/vuejs/vue-devtools'
      );
    }
  }
  if (process.env.NODE_ENV !== 'production' &&
    config.productionTip !== false &&
    inBrowser && typeof console !== 'undefined'
  ) {
    console[console.info ? 'info' : 'log'](
      "You are running Vue in development mode.\n" +
      "Make sure to turn on production mode when deploying for production.\n" +
      "See more tips at https://vuejs.org/guide/deployment.html"
    );
  }
}, 0);

/*  */

/* harmony default export */ __webpack_exports__["a"] = (Vue$3);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(29), __webpack_require__(55)))

/***/ }),
/* 55 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzkzNTlhODQzNjU5ZmNjOWZlMjciLCJ3ZWJwYWNrOi8vLy4uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzIiwid2VicGFjazovLy8uLy4uL3NyYy9icmlkZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hUYWIvbWF0Y2hUYWIudnVlIiwid2VicGFjazovLy8uLy4uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGV2dG9vbHMuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi8uLi9zcmMvQXBwLnZ1ZSIsIndlYnBhY2s6Ly8vLi8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlIiwid2VicGFjazovLy8uLy4uL3NyYy9jb21wb25lbnRzL3NwbGl0UGFuZS9zcGxpdFBhbmUudnVlIiwid2VicGFjazovLy8uLy4uL3NyYy9jb21wb25lbnRzL21hdGNoQ29udGVudC9tYXRjaENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovbWF0Y2hPYmouanMiLCJ3ZWJwYWNrOi8vLy4vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hUYWIvbWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4uL34vY2lyY3VsYXItanNvbi1lczYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nbG9iYWwuc3R5bCIsIndlYnBhY2s6Ly8vLi4vc3JjL0FwcC52dWU/NzhhZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc3BsaXRQYW5lL3NwbGl0UGFuZS52dWU/OTI4ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hUYWIvbWF0Y2guY3NzIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9tYXRjaE9iai52dWU/NDQ2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovZGF0YUZpZWxkLnZ1ZT8xOWJiIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaFRhYi9hY3Rpb25UYWIudnVlPzNlOTEiLCJ3ZWJwYWNrOi8vLy4uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9zcmMvYXNzZXRzL01hdGVyaWFsSWNvbnMtUmVndWxhci53b2ZmMiIsIndlYnBhY2s6Ly8vLi4vc3JjL2Fzc2V0cy9Sb2JvdG8tUmVndWxhci53b2ZmMiIsIndlYnBhY2s6Ly8vLi4vc3JjL2Fzc2V0cy9sb2dvLnBuZyIsIndlYnBhY2s6Ly8vLi4vc3JjL0FwcC52dWUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb21wb25lbnRzL21hdGNoQ29udGVudC9tYXRjaENvbnRlbnQudnVlIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9tYXRjaE9iai52dWUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb21wb25lbnRzL21hdGNoVGFiL2FjdGlvblRhYi52dWUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb21wb25lbnRzL3NwbGl0UGFuZS9zcGxpdFBhbmUudnVlIiwid2VicGFjazovLy8uLi9zcmMvQXBwLnZ1ZT8wMDMxIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9zcGxpdFBhbmUvc3BsaXRQYW5lLnZ1ZT9hMzYxIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaENvbnRlbnQvbWF0Y2hDb250ZW50LnZ1ZT81NTVlIiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaFRhYi9tYXRjaFRhYi52dWU/OGEzNiIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovbWF0Y2hPYmoudnVlPzIyYmIiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL2RhdGFGaWVsZC52dWU/M2ZjMyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hUYWIvYWN0aW9uVGFiLnZ1ZT9jZTc1Iiwid2VicGFjazovLy8uLi9zcmMvZ2xvYmFsLnN0eWw/OGZjMCIsIndlYnBhY2s6Ly8vLi4vc3JjL0FwcC52dWU/OTJhOCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvc3BsaXRQYW5lL3NwbGl0UGFuZS52dWU/YTZiZCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hUYWIvbWF0Y2guY3NzP2Y0YjQiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL21hdGNoT2JqLnZ1ZT80YjY4Iiwid2VicGFjazovLy8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlPzI2M2MiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb21wb25lbnRzL21hdGNoVGFiL2FjdGlvblRhYi52dWU/ZGIwZCIsIndlYnBhY2s6Ly8vLi4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLmpzIiwid2VicGFjazovLy8uLi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNB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LENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUM7R0FDMUI7Q0FDRjtBQUFBO0FBQUE7Ozs7Ozs7QUM1Q0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7O0FDOURBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7OztBQ3JDQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7O0FDaEJBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7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QUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlC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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsVUFBVTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDLEdBQUc7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdUZBQXVGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsK0JBQStCO0FBQy9GLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUM5RTtBQUNBO0FBQ0EsNkNBQTZDLDRDQUE0Qzs7QUFFekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDJEQUEyRCwyQkFBMkIsRUFBRTtBQUN4RixLQUFLO0FBQ0w7QUFDQSwyREFBMkQsNEJBQTRCLEVBQUU7QUFDekY7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw2Q0FBNkMsRUFBRTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCLEVBQUU7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0JBQStCLEVBQUU7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUNBQXVDLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qyx1Q0FBdUMsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsMEJBQTBCLEVBQUU7QUFDdEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixFQUFFO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOzs7Ozs7OztBQ2x3T0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiZGV2dG9vbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBjOTM1OWE4NDM2NTlmY2M5ZmUyNyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIHRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHJhd1NjcmlwdEV4cG9ydHMsXG4gIGNvbXBpbGVkVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciAvKiBzZXJ2ZXIgb25seSAqL1xuKSB7XG4gIHZhciBlc01vZHVsZVxuICB2YXIgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzIHx8IHt9XG5cbiAgLy8gRVM2IG1vZHVsZXMgaW50ZXJvcFxuICB2YXIgdHlwZSA9IHR5cGVvZiByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBlc01vZHVsZSA9IHJhd1NjcmlwdEV4cG9ydHNcbiAgICBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIH1cblxuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKGNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGNvbXBpbGVkVGVtcGxhdGUucmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZFRlbXBsYXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgdmFyIGZ1bmN0aW9uYWwgPSBvcHRpb25zLmZ1bmN0aW9uYWxcbiAgICB2YXIgZXhpc3RpbmcgPSBmdW5jdGlvbmFsXG4gICAgICA/IG9wdGlvbnMucmVuZGVyXG4gICAgICA6IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXG4gICAgaWYgKCFmdW5jdGlvbmFsKSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxuICAgICAgICByZXR1cm4gZXhpc3RpbmcoaCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVzTW9kdWxlOiBlc01vZHVsZSxcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbnZhciBsaXN0VG9TdHlsZXMgPSByZXF1aXJlKCcuL2xpc3RUb1N0eWxlcycpXG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbikge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyaWRnZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgY29uc3RydWN0b3IgKHdhbGwpIHtcclxuICAgIHN1cGVyKClcclxuICAgIC8vIFNldHRpbmcgYHRoaXNgIHRvIGBzZWxmYCBoZXJlIHRvIGZpeCBhbiBlcnJvciBpbiB0aGUgU2FmYXJpIGJ1aWxkOlxyXG4gICAgLy8gUmVmZXJlbmNlRXJyb3I6IENhbm5vdCBhY2Nlc3MgdW5pbml0aWFsaXplZCB2YXJpYWJsZS5cclxuICAgIC8vIFRoZSBlcnJvciBtaWdodCBiZSByZWxhdGVkIHRvIHRoZSB3ZWJraXQgYnVnIGhlcmU6XHJcbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTcxNTQzXHJcbiAgICBjb25zdCBzZWxmID0gdGhpc1xyXG4gICAgc2VsZi5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpXHJcbiAgICBzZWxmLndhbGwgPSB3YWxsXHJcbiAgICB3YWxsLmxpc3RlbihtZXNzYWdlID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHNlbGYuZW1pdChtZXNzYWdlKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGYuZW1pdChtZXNzYWdlLmV2ZW50LCBtZXNzYWdlLnBheWxvYWQpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kIGFuIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAgICovXHJcblxyXG4gIHNlbmQgKGV2ZW50LCBwYXlsb2FkKSB7XHJcbiAgICB0aGlzLndhbGwuc2VuZCh7XHJcbiAgICAgIGV2ZW50LFxyXG4gICAgICBwYXlsb2FkXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9nIGEgbWVzc2FnZSB0byB0aGUgZGV2dG9vbHMgYmFja2dyb3VuZCBwYWdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcclxuICAgKi9cclxuXHJcbiAgbG9nIChtZXNzYWdlKSB7XHJcbiAgICB0aGlzLnNlbmQoJ2xvZycsIG1lc3NhZ2UpXHJcbiAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLy4uL3NyYy9icmlkZ2UuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWQ2ZmEzZWI0XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuL21hdGNoLmNzc1wiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4vbWF0Y2guanNcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWQ2ZmEzZWI0XFxcIixcXFwiaGFzU2NvcGVkXFxcIjp0cnVlLFxcXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0YXJnZXRcXFwiOntcXFwiY2hyb21lXFxcIjo1MixcXFwiZmlyZWZveFxcXCI6NDh9LFxcXCJvYmplY3RBc3NpZ25cXFwiOlxcXCJPYmplY3QuYXNzaWduXFxcIn19IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9tYXRjaFRhYi52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi1kNmZhM2ViNFwiLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJHOlxcXFxsdW9iYXRhXFxcXGxpYlxcXFxtYXRjaC1kZXZ0b29sc1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxtYXRjaFRhYlxcXFxtYXRjaFRhYi52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIG1hdGNoVGFiLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1kNmZhM2ViNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWQ2ZmEzZWI0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hUYWIvbWF0Y2hUYWIudnVlXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAudnVlJztcblxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdERldlRvb2xzIChzaGVsbCkge1xuICAgIGluaXRVaShzaGVsbCk7XG59O1xuXG5mdW5jdGlvbiBpbml0VWkgKHNoZWxsKSB7XG4gICAgbGV0IGFwcCA9IG51bGw7XG5cbiAgICBzaGVsbC5jb25uZWN0KGJyaWRnZSA9PiB7XG4gICAgICAgIHdpbmRvdy5NQVRDSEJSSURHRSA9IGJyaWRnZTtcbiAgICB9KTtcblxuICAgIGFwcCA9IG5ldyBWdWUoe1xuICAgICAgICByZW5kZXIgKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKEFwcCk7XG4gICAgICAgIH1cbiAgICB9KS4kbW91bnQoJyNhcHAnKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi8uLi9zcmMvaW5kZXguanMiLCJpbXBvcnQgeyBpbml0RGV2VG9vbHMgfSBmcm9tICdTUkMvaW5kZXgnO1xuaW1wb3J0IEJyaWRnZSBmcm9tICdTUkMvYnJpZGdlJztcblxuLypcbiAqIEluamVjdCBiYWNrZW5kLmpzIGNvbm5lYyB0byBiYWNrZ3JvdW5kLCBhbmQgc2VuZCBiYWNrIHRoZSBicmlkZ2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5pbml0RGV2VG9vbHMoe1xuICAgIGNvbm5lY3QgKGNiKSB7XG4gICAgICAgIC8vIGluamVjdCBiYWNrZW5kLmpzXG4gICAgICAgIGluamVjdFNjcmlwdChjaHJvbWUucnVudGltZS5nZXRVUkwoJ2J1aWxkL2JhY2tlbmQuanMnKSwgKCkgPT4ge1xuICAgICAgICAgICAgLy8gY29ubmVjdCB0byBiYWNrZ3JvdW5kXG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gY2hyb21lLnJ1bnRpbWUuY29ubmVjdCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJycgKyBjaHJvbWUuZGV2dG9vbHMuaW5zcGVjdGVkV2luZG93LnRhYklkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgYnJpZGdlID0gbmV3IEJyaWRnZSh7XG4gICAgICAgICAgICAgICAgbGlzdGVuIChmbikge1xuICAgICAgICAgICAgICAgICAgICBwb3J0Lm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihmbik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZW5kIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBvcnQpO1xuICAgICAgICAgICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZW5kIGJhY2sgYnJpZGdlXG4gICAgICAgICAgICBjYihicmlkZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gaW5qZWN0U2NyaXB0IChzY3JpcHROYW1lLCBjYikge1xuICBjb25zdCBzcmMgPSBgXG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCAnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC5zcmMgPSBcIiR7c2NyaXB0TmFtZX1cIjtcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gIGA7XG5cbiAgY2hyb21lLmRldnRvb2xzLmluc3BlY3RlZFdpbmRvdy5ldmFsKHNyYywgZnVuY3Rpb24gKHJlcywgZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIH1cbiAgICAgIGNiKCk7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kZXZ0b29scy5qcyIsImltcG9ydCBDaXJjdWxhckpTT04gZnJvbSAnY2lyY3VsYXItanNvbi1lczYnXG5cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHJldHVybiBmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXVxuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9XG59XG5cbnZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fL10pKFxcdykvZ1xuZXhwb3J0IGNvbnN0IGNsYXNzaWZ5ID0gY2FjaGVkKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIHRvVXBwZXIpXG59KVxuXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nXG5leHBvcnQgY29uc3QgY2FtZWxpemUgPSBjYWNoZWQoKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgdG9VcHBlcilcbn0pXG5cbmZ1bmN0aW9uIHRvVXBwZXIgKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5Eb2MgKG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2VcbiAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZVxuICByZXR1cm4gZG9jID09PSBub2RlIHx8XG4gICAgZG9jID09PSBwYXJlbnQgfHxcbiAgICAhIShwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxICYmIChkb2MuY29udGFpbnMocGFyZW50KSkpXG59XG5cbi8qKlxuICogU3RyaW5naWZ5L3BhcnNlIGRhdGEgdXNpbmcgQ2lyY3VsYXJKU09OLlxuICovXG5cbmV4cG9ydCBjb25zdCBVTkRFRklORUQgPSAnX192dWVfZGV2dG9vbF91bmRlZmluZWRfXydcbmV4cG9ydCBjb25zdCBJTkZJTklUWSA9ICdfX3Z1ZV9kZXZ0b29sX2luZmluaXR5X18nXG5leHBvcnQgY29uc3QgTkFOID0gJ19fdnVlX2RldnRvb2xfbmFuX18nXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkgKGRhdGEpIHtcbiAgcmV0dXJuIENpcmN1bGFySlNPTi5zdHJpbmdpZnkoZGF0YSwgcmVwbGFjZXIpXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VyIChrZXksIHZhbCkge1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gVU5ERUZJTkVEXG4gIH0gZWxzZSBpZiAodmFsID09PSBJbmZpbml0eSkge1xuICAgIHJldHVybiBJTkZJTklUWVxuICB9IGVsc2UgaWYgKE51bWJlci5pc05hTih2YWwpKSB7XG4gICAgcmV0dXJuIE5BTlxuICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgb2YgbmF0aXZlIHR5cGVcbiAgICByZXR1cm4gYFtuYXRpdmUgUmVnRXhwICR7dmFsLnRvU3RyaW5nKCl9XWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2FuaXRpemUodmFsKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSAoZGF0YSwgcmV2aXZlKSB7XG4gIHJldHVybiByZXZpdmVcbiAgICA/IENpcmN1bGFySlNPTi5wYXJzZShkYXRhLCByZXZpdmVyKVxuICAgIDogQ2lyY3VsYXJKU09OLnBhcnNlKGRhdGEpXG59XG5cbmZ1bmN0aW9uIHJldml2ZXIgKGtleSwgdmFsKSB7XG4gIGlmICh2YWwgPT09IFVOREVGSU5FRCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfSBlbHNlIGlmICh2YWwgPT09IElORklOSVRZKSB7XG4gICAgcmV0dXJuIEluZmluaXR5XG4gIH0gZWxzZSBpZiAodmFsID09PSBOQU4pIHtcbiAgICByZXR1cm4gTmFOXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbFxuICB9XG59XG5cbi8qKlxuICogU2FuaXRpemUgZGF0YSB0byBiZSBwb3N0ZWQgdG8gdGhlIG90aGVyIHNpZGUuXG4gKiBTaW5jZSB0aGUgbWVzc2FnZSBwb3N0ZWQgaXMgc2VudCB3aXRoIHN0cnVjdHVyZWQgY2xvbmUsXG4gKiB3ZSBuZWVkIHRvIGZpbHRlciBvdXQgYW55IHR5cGVzIHRoYXQgbWlnaHQgY2F1c2UgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cbmZ1bmN0aW9uIHNhbml0aXplIChkYXRhKSB7XG4gIGlmIChcbiAgICAhaXNQcmltaXRpdmUoZGF0YSkgJiZcbiAgICAhQXJyYXkuaXNBcnJheShkYXRhKSAmJlxuICAgICFpc1BsYWluT2JqZWN0KGRhdGEpXG4gICkge1xuICAgIC8vIGhhbmRsZSB0eXBlcyB0aGF0IHdpbGwgcHJvYmFibHkgY2F1c2UgaXNzdWVzIGluXG4gICAgLy8gdGhlIHN0cnVjdHVyZWQgY2xvbmVcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNQcmltaXRpdmUgKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBkYXRhXG4gIHJldHVybiAoXG4gICAgdHlwZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAgIHR5cGUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hEZWVwSW5PYmplY3QgKG9iaiwgc2VhcmNoVGVybSkge1xuICB2YXIgbWF0Y2ggPSBmYWxzZVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XVxuICAgIGlmIChjb21wYXJlKGtleSwgc2VhcmNoVGVybSkgfHwgY29tcGFyZSh2YWx1ZSwgc2VhcmNoVGVybSkpIHtcbiAgICAgIG1hdGNoID0gdHJ1ZVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBtYXRjaCA9IHNlYXJjaERlZXBJbk9iamVjdCh2YWx1ZSwgc2VhcmNoVGVybSlcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hcbn1cblxuZnVuY3Rpb24gY29tcGFyZSAobWl4ZWRWYWx1ZSwgc3RyaW5nVmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWl4ZWRWYWx1ZSkgJiYgc2VhcmNoSW5BcnJheShtaXhlZFZhbHVlLCBzdHJpbmdWYWx1ZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKCgnJyArIG1peGVkVmFsdWUpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHJpbmdWYWx1ZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBzZWFyY2hJbkFycmF5IChhcnIsIHNlYXJjaFRlcm0pIHtcbiAgbGV0IGZvdW5kID0gZmFsc2VcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKCcnICsgYXJyW2ldKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoVGVybSkgIT09IC0xKSB7XG4gICAgICBmb3VuZCA9IHRydWVcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiBmb3VuZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc29ydEJ5S2V5IChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUgJiYgc3RhdGUuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEua2V5IDwgYi5rZXkpIHJldHVybiAtMVxuICAgIGlmIChhLmtleSA+IGIua2V5KSByZXR1cm4gMVxuICAgIHJldHVybiAwXG4gIH0pXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi8uLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai91dGlsLmpzIiwiLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmltcG9ydCBDb21wb25lbnRzVGFiIGZyb20gJ0NPTVBPTkVOVFMvbWF0Y2hUYWIvbWF0Y2hUYWIudnVlJ1xuaW1wb3J0IENvbXBvbmVudHNDb250ZW50IGZyb20gJ0NPTVBPTkVOVFMvbWF0Y2hDb250ZW50L21hdGNoQ29udGVudC52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAnYXBwJyxcbiAgICBkYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdtYXRjaCcsXG4gICAgICAgICAgICB0YWI6ICdtYXRjaCcsXG4gICAgICAgICAgICBpc0Rhcms6IHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YgY2hyb21lLmRldnRvb2xzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY2hyb21lLmRldnRvb2xzLnBhbmVscy50aGVtZU5hbWUgPT09ICdkYXJrJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIG1hdGNoOiBDb21wb25lbnRzQ29udGVudFxuICAgIH0sXG4gICAgLy9jb21wdXRlZDogbWFwU3RhdGUoe1xuICAgICAgICAvLyAgbWVzc2FnZTogc3RhdGUgPT4gc3RhdGUubWVzc2FnZSxcbiAgICAgICAgLy8gIHRhYjogc3RhdGUgPT4gc3RhdGUudGFiLFxuICAgICAgICAvLyAgbmV3RXZlbnRDb3VudDogc3RhdGUgPT4gc3RhdGUuZXZlbnRzLm5ld0V2ZW50Q291bnRcbiAgICAvL30pLFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgcmVmcmVzaCAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWZyZXNoSWNvbiA9IHRoaXMuJHJlZnMucmVmcmVzaDtcbiAgICAgICAgICAgIHJlZnJlc2hJY29uLnN0eWxlLmFuaW1hdGlvbiA9ICdub25lJztcbiAgICAgICAgICAgIE1BVENIQlJJREdFLnNlbmQoJ3JlZnJlc2gnKTtcbiAgICAgICAgICAgIE1BVENIQlJJREdFLm9uY2UoJ2ZsdXNoJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlZnJlc2hJY29uLnN0eWxlLmFuaW1hdGlvbiA9ICdyb3RhdGUgMXMnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVBY3RpdmVCYXIgKCkge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlQnV0dG9uID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmJ1dHRvbi5hY3RpdmUnKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUJhciA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5hY3RpdmUtYmFyJyk7XG4gICAgICAgICAgICBhY3RpdmVCYXIuc3R5bGUubGVmdCA9IGFjdGl2ZUJ1dHRvbi5vZmZzZXRMZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgIGFjdGl2ZUJhci5zdHlsZS53aWR0aCA9IGFjdGl2ZUJ1dHRvbi5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQgKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUJhcigpXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnVwZGF0ZUFjdGl2ZUJhcilcbiAgICB9LFxuICAgIGRlc3Ryb3llZCAoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnVwZGF0ZUFjdGl2ZUJhcilcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIHRhYiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnVwZGF0ZUFjdGl2ZUJhcilcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLy4uL3NyYy9BcHAudnVlIiwiLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5pbXBvcnQge1xuICBVTkRFRklORUQsXG4gIElORklOSVRZLFxuICBOQU4sXG4gIGlzUGxhaW5PYmplY3QsXG4gIHNvcnRCeUtleVxufSBmcm9tICcuL3V0aWwnXG5cbmNvbnN0IHJhd1R5cGVSRSA9IC9eXFxbb2JqZWN0IChcXHcrKV0kL1xuY29uc3Qgc3BlY2lhbFR5cGVSRSA9IC9eXFxbbmF0aXZlIFxcdysgKC4qKVxcXSQvXG5cbmZ1bmN0aW9uIHN1YkZpZWxkQ291bnQgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGhcbiAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ0RhdGFGaWVsZCcsXG4gIHByb3BzOiB7XG4gICAgZmllbGQ6IE9iamVjdCxcbiAgICBkZXB0aDogTnVtYmVyXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW1pdDogQXJyYXkuaXNBcnJheSh0aGlzLmZpZWxkLnZhbHVlKSA/IDEwIDogSW5maW5pdHksXG4gICAgICBleHBhbmRlZDogdGhpcy5kZXB0aCA9PT0gMCAmJiB0aGlzLmZpZWxkLmtleSAhPT0gJyRyb3V0ZScgJiYgKHN1YkZpZWxkQ291bnQodGhpcy5maWVsZC52YWx1ZSkgPCA1KVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICB2YWx1ZVR5cGUgKCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmZpZWxkLnZhbHVlXG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGUgPT09ICdib29sZWFuJyB8fFxuICAgICAgICB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB2YWx1ZSA9PT0gSU5GSU5JVFkgfHxcbiAgICAgICAgdmFsdWUgPT09IE5BTlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiAnbGl0ZXJhbCdcbiAgICAgIH0gZWxzZSBpZiAoc3BlY2lhbFR5cGVSRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ25hdGl2ZSdcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgIXJhd1R5cGVSRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ3N0cmluZydcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzRXhwYW5kYWJsZVR5cGUgKCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmZpZWxkLnZhbHVlXG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSlcbiAgICB9LFxuICAgIGZvcm1hdHRlZFZhbHVlICgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5maWVsZC52YWx1ZVxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFVOREVGSU5FRCkge1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCdcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IE5BTikge1xuICAgICAgICByZXR1cm4gJ05hTidcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IElORklOSVRZKSB7XG4gICAgICAgIHJldHVybiAnSW5maW5pdHknXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnQXJyYXlbJyArIHZhbHVlLmxlbmd0aCArICddJ1xuICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ09iamVjdCcgKyAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA/ICcnIDogJyAoZW1wdHkpJylcbiAgICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZVR5cGUgPT09ICduYXRpdmUnKSB7XG4gICAgICAgIHJldHVybiBzcGVjaWFsVHlwZVJFLmV4ZWModmFsdWUpWzFdXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHR5cGVNYXRjaCA9IHZhbHVlLm1hdGNoKHJhd1R5cGVSRSlcbiAgICAgICAgaWYgKHR5cGVNYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0eXBlTWF0Y2hbMV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgZm9ybWF0dGVkU3ViRmllbGRzICgpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZmllbGQudmFsdWVcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCgoaXRlbSwgaSkgPT4gKHtcbiAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgfSkpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsdWUgPSBzb3J0QnlLZXkoT2JqZWN0LmtleXModmFsdWUpLm1hcChrZXkgPT4gKHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdmFsdWU6IHZhbHVlW2tleV1cbiAgICAgICAgfSkpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBsaW1pdGVkU3ViRmllbGRzICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlZFN1YkZpZWxkcy5zbGljZSgwLCB0aGlzLmxpbWl0KVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHRvZ2dsZSAoKSB7XG4gICAgICBpZiAodGhpcy5pc0V4cGFuZGFibGVUeXBlKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZFxuICAgICAgfVxuICAgIH0sXG4gICAgaHlwaGVuOiB2ID0+IHYucmVwbGFjZSgvXFxzL2csICctJylcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovZGF0YUZpZWxkLnZ1ZSIsIi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzcGxpdDogNTAsXG4gICAgICBkcmFnZ2luZzogZmFsc2VcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBkcmFnU3RhcnQgKGUpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlXG4gICAgICB0aGlzLnN0YXJ0WCA9IGUucGFnZVhcbiAgICAgIHRoaXMuc3RhcnRTcGxpdCA9IHRoaXMuc3BsaXRcbiAgICB9LFxuICAgIGRyYWdNb3ZlIChlKSB7XG4gICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICBjb25zdCBkeCA9IGUucGFnZVggLSB0aGlzLnN0YXJ0WFxuICAgICAgICBjb25zdCB0b3RhbFdpZHRoID0gdGhpcy4kZWwub2Zmc2V0V2lkdGhcbiAgICAgICAgdGhpcy5zcGxpdCA9IHRoaXMuc3RhcnRTcGxpdCArIH5+KGR4IC8gdG90YWxXaWR0aCAqIDEwMClcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdFbmQgKCkge1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlXG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi8uLi9zcmMvY29tcG9uZW50cy9zcGxpdFBhbmUvc3BsaXRQYW5lLnZ1ZSIsImltcG9ydCBTcGxpdFBhbmUgZnJvbSAnLi4vc3BsaXRQYW5lL3NwbGl0UGFuZS52dWUnO1xuaW1wb3J0IENvbXBvbmVudFRyZWUgZnJvbSAnLi4vbWF0Y2hUYWIvbWF0Y2hUYWIudnVlJztcbmltcG9ydCBtYXRjaE9iaiBmcm9tICdDT01QT05FTlRTL21hdGNoT2JqL21hdGNoT2JqLnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoQXJyOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIENvbXBvbmVudFRyZWUsXG4gICAgICAgIG1hdGNoT2JqLFxuICAgICAgICBTcGxpdFBhbmVcbiAgICB9LFxuICAgIGJlZm9yZU1vdW50ICgpIHtcbiAgICAgICAgdGhpcy5tYXRjaEFyciA9IHdpbmRvdy5NQVRDSF9TVEFDSztcbiAgICAgICAgdGhpcy5tYXRjaEFyciA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIHBpZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6MVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhZnRlclBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBwaWQ6IDIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3NkZidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5tYXRjaEFycik7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGZpbHRlciAoZSkge1xuICAgICAgICAgICAgYnJpZGdlLnNlbmQoJ2ZpbHRlci1pbnN0YW5jZXMnLCBlLnRhcmdldC52YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi8uLi9zcmMvY29tcG9uZW50cy9tYXRjaENvbnRlbnQvbWF0Y2hDb250ZW50LmpzIiwiaW1wb3J0IERhdGFGaWVsZCBmcm9tICcuL2RhdGFGaWVsZC52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IHtcbiAgICAgICAgc3RhY2tzOiBBcnJheVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBEYXRhRmllbGRcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovbWF0Y2hPYmouanMiLCJpbXBvcnQgQWN0aW9uSGVhZGVyIGZyb20gJy4vYWN0aW9uVGFiLnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEFjdGlvbkhlYWRlclxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBmaWx0ZXJTdGFja3MgKCkge1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLy4uL3NyYy9jb21wb25lbnRzL21hdGNoVGFiL21hdGNoLmpzIiwiZnVuY3Rpb24gZW5jb2RlIChkYXRhLCByZXBsYWNlciwgbGlzdCwgc2Vlbikge1xuICB2YXIgc3RvcmVkLCBrZXksIHZhbHVlLCBpLCBsXG4gIHZhciBzZWVuSW5kZXggPSBzZWVuLmdldChkYXRhKVxuICBpZiAoc2VlbkluZGV4ICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2VlbkluZGV4XG4gIH1cbiAgdmFyIGluZGV4ID0gbGlzdC5sZW5ndGhcbiAgaWYgKGlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBzdG9yZWQgPSB7fVxuICAgIHNlZW4uc2V0KGRhdGEsIGluZGV4KVxuICAgIGxpc3QucHVzaChzdG9yZWQpXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKVxuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXVxuICAgICAgdmFsdWUgPSBkYXRhW2tleV1cbiAgICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoZGF0YSwga2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICAgIHN0b3JlZFtrZXldID0gZW5jb2RlKHZhbHVlLCByZXBsYWNlciwgbGlzdCwgc2VlbilcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHN0b3JlZCA9IFtdXG4gICAgc2Vlbi5zZXQoZGF0YSwgaW5kZXgpXG4gICAgbGlzdC5wdXNoKHN0b3JlZClcbiAgICBmb3IgKGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhbHVlID0gZGF0YVtpXVxuICAgICAgaWYgKHJlcGxhY2VyKSB7XG4gICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKGRhdGEsIGksIHZhbHVlKVxuICAgICAgfVxuICAgICAgc3RvcmVkW2ldID0gZW5jb2RlKHZhbHVlLCByZXBsYWNlciwgbGlzdCwgc2VlbilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5kZXggPSBsaXN0Lmxlbmd0aFxuICAgIGxpc3QucHVzaChkYXRhKVxuICB9XG4gIHJldHVybiBpbmRleFxufVxuXG5mdW5jdGlvbiBkZWNvZGUgKGxpc3QsIHJldml2ZXIpIHtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aFxuICB2YXIgaiwgaywgZGF0YSwga2V5LCB2YWx1ZVxuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRhdGEgPSBsaXN0W2ldXG4gICAgaWYgKGlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgICAgIGZvciAoaiA9IDAsIGsgPSBrZXlzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICBrZXkgPSBrZXlzW2pdXG4gICAgICAgIHZhbHVlID0gbGlzdFtkYXRhW2tleV1dXG4gICAgICAgIGlmIChyZXZpdmVyKSB2YWx1ZSA9IHJldml2ZXIuY2FsbChkYXRhLCBrZXksIHZhbHVlKVxuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgZm9yIChqID0gMCwgayA9IGRhdGEubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgIHZhbHVlID0gbGlzdFtkYXRhW2pdXVxuICAgICAgICBpZiAocmV2aXZlcikgdmFsdWUgPSByZXZpdmVyLmNhbGwoZGF0YSwgaiwgdmFsdWUpXG4gICAgICAgIGRhdGFbal0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeSAoZGF0YSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgIDogSlNPTi5zdHJpbmdpZnkoZGF0YSwgcmVwbGFjZXIsIHNwYWNlKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc3RyaW5naWZ5U3RyaWN0KGRhdGEsIHJlcGxhY2VyLCBzcGFjZSlcbiAgfVxufVxuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGRhdGEsIHJldml2ZXIpIHtcbiAgdmFyIGhhc0NpcmN1bGFyID0gL15cXHMvLnRlc3QoZGF0YSlcbiAgaWYgKCFoYXNDaXJjdWxhcikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICA/IEpTT04ucGFyc2UoZGF0YSlcbiAgICAgIDogSlNPTi5wYXJzZShkYXRhLCByZXZpdmVyKVxuICB9IGVsc2Uge1xuICAgIHZhciBsaXN0ID0gSlNPTi5wYXJzZShkYXRhKVxuICAgIGRlY29kZShsaXN0LCByZXZpdmVyKVxuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cbn1cblxuZXhwb3J0cy5zdHJpbmdpZnlTdHJpY3QgPSBmdW5jdGlvbiAoZGF0YSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gIHZhciBsaXN0ID0gW11cbiAgZW5jb2RlKGRhdGEsIHJlcGxhY2VyLCBsaXN0LCBuZXcgTWFwKCkpXG4gIHJldHVybiBzcGFjZVxuICAgID8gJyAnICsgSlNPTi5zdHJpbmdpZnkobGlzdCwgbnVsbCwgc3BhY2UpXG4gICAgOiAnICcgKyBKU09OLnN0cmluZ2lmeShsaXN0KVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jaXJjdWxhci1qc29uLWVzNi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnNsaWRlLXVwLWVudGVyIHtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCA1MCUpO1xcbn1cXG4uc2xpZGUtdXAtbGVhdmUtdG8ge1xcbiAgb3BhY2l0eTogMDtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIC01MCUpO1xcbn1cXG4uc2xpZGUtZG93bi1lbnRlcixcXG4uc2xpZGUtZG93bi1sZWF2ZS10byB7XFxuICBvcGFjaXR5OiAwO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgLTIwcHgpO1xcbn1cXG5ALW1vei1rZXlmcmFtZXMgcm90YXRlIHtcXG4wJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbn1cXG4xMDAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG59XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyByb3RhdGUge1xcbjAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxufVxcbjEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbn1cXG59XFxuQC1vLWtleWZyYW1lcyByb3RhdGUge1xcbjAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxufVxcbjEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbn1cXG59XFxuQGtleWZyYW1lcyByb3RhdGUge1xcbjAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxufVxcbjEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbn1cXG59XFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ01hdGVyaWFsIEljb25zJztcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICBzcmM6IHVybChcIiArIHJlcXVpcmUoXCIuL2Fzc2V0cy9NYXRlcmlhbEljb25zLVJlZ3VsYXIud29mZjJcIikgKyBcIikgZm9ybWF0KCd3b2ZmMicpO1xcbn1cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiAnUm9ib3RvJztcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICBzcmM6IGxvY2FsKCdSb2JvdG8nKSwgbG9jYWwoJ1JvYm90by1SZWd1bGFyJyksIHVybChcIiArIHJlcXVpcmUoXCIuL2Fzc2V0cy9Sb2JvdG8tUmVndWxhci53b2ZmMlwiKSArIFwiKSBmb3JtYXQoJ3dvZmYyJyk7XFxufVxcbi5tYXRlcmlhbC1pY29ucyB7XFxuICBmb250LWZhbWlseTogJ01hdGVyaWFsIEljb25zJztcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LXNpemU6IDIycHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB3aWR0aDogMWVtO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBjb2xvcjogIzk5OTtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICBsZXR0ZXItc3BhY2luZzogbm9ybWFsO1xcbiAgd29yZC13cmFwOiBub3JtYWw7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgZGlyZWN0aW9uOiBsdHI7XFxuLyogU3VwcG9ydCBmb3IgYWxsIFdlYktpdCBicm93c2Vycy4gKi9cXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbi8qIFN1cHBvcnQgZm9yIFNhZmFyaSBhbmQgQ2hyb21lLiAqL1xcbiAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcXG4vKiBTdXBwb3J0IGZvciBGaXJlZm94LiAqL1xcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG59XFxuLm1hdGVyaWFsLWljb25zLm1lZGl1bSB7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDAuOSk7XFxufVxcbi5tYXRlcmlhbC1pY29ucy5zbWFsbCB7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDAuOCk7XFxufVxcbi50b2dnbGUtcmVjb3JkaW5nIC5tYXRlcmlhbC1pY29ucyB7XFxuICBjb2xvcjogIzk5OSAhaW1wb3J0YW50O1xcbn1cXG4udG9nZ2xlLXJlY29yZGluZyAubWF0ZXJpYWwtaWNvbnMuZW5hYmxlZCB7XFxuICBjb2xvcjogI2YwMCAhaW1wb3J0YW50O1xcbiAgdGV4dC1zaGFkb3c6IDAgMCAzcHggcmdiYSgyNTUsMCwwLDAuNCk7XFxufVxcbmh0bWwsXFxuYm9keSB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgZm9udC1mYW1pbHk6IFJvYm90bztcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGNvbG9yOiAjNDQ0O1xcbn1cXG4qIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcbi5hcnJvdyB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDtcXG59XFxuLmFycm93LnVwIHtcXG4gIGJvcmRlci1sZWZ0OiA0cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItcmlnaHQ6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1ib3R0b206IDZweCBzb2xpZCAjNDQ0O1xcbn1cXG4uYXJyb3cuZG93biB7XFxuICBib3JkZXItbGVmdDogNHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJpZ2h0OiA0cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItdG9wOiA2cHggc29saWQgIzQ0NDtcXG59XFxuLmFycm93LnJpZ2h0IHtcXG4gIGJvcmRlci10b3A6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1ib3R0b206IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1sZWZ0OiA2cHggc29saWQgIzQ0NDtcXG59XFxuLmFycm93LmxlZnQge1xcbiAgYm9yZGVyLXRvcDogNHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLWJvdHRvbTogNHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJpZ2h0OiA2cHggc29saWQgIzQ0NDtcXG59XFxuLm5vdGljZSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgY29sb3I6ICNhYWE7XFxufVxcbi5ub3RpY2UgZGl2IHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDAuNWVtO1xcbiAgbWFyZ2luOiAwIGF1dG87XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJHOi9sdW9iYXRhL2xpYi9tYXRjaC1kZXZ0b29scy9zcmMvdHJhbnNpdGlvbnMuc3R5bFwiLFwiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL2dsb2JhbC5zdHlsXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFBQTtFQUNFLFdBQUE7RUFDQSw2QkFBQTtDQ0NEO0FEQ0Q7RUFDRSxXQUFBO0VBQ0EsOEJBQUE7Q0NDRDtBRENEOztFQUNFLFdBQUE7RUFDQSwrQkFBQTtDQ0VEO0FEQVU7QUFDVDtJQUNFLHdCQUFBO0NDRUQ7QURERDtJQUNFLDBCQUFBO0NDR0Q7Q0FDRjtBRFJVO0FBQ1Q7SUFDRSx3QkFBQTtDQ1VEO0FEVEQ7SUFDRSwwQkFBQTtDQ1dEO0NBQ0Y7QURoQlU7QUFDVDtJQUNFLHdCQUFBO0NDa0JEO0FEakJEO0lBQ0UsMEJBQUE7Q0NtQkQ7Q0FDRjtBRHhCVTtBQUNUO0lBQ0Usd0JBQUE7Q0MwQkQ7QUR6QkQ7SUFDRSwwQkFBQTtDQzJCRDtDQUNGO0FBekNEO0VBQ0UsOEJBQUE7RUFDQSxtQkFBQTtFQUNBLGlCQUFBO0VBQ0EsbURBQUE7Q0EyQ0Q7QUF6Q0Q7RUFDRSxzQkFBQTtFQUNBLG1CQUFBO0VBQ0EsaUJBQUE7RUFDQSw2RkFBQTtDQTJDRDtBQXpDRDtFQUNFLDhCQUFBO0VBQ0Esb0JBQUE7RUFDQSxtQkFBQTtFQUNBLGdCQUFBO0VBQ0Esc0JBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtFQUNBLFlBQUE7RUFDQSxlQUFBO0VBQ0EscUJBQUE7RUFDQSx1QkFBQTtFQUNBLGtCQUFBO0VBQ0Esb0JBQUE7RUFDQSxlQUFBO0FBQ0Esc0NBQUE7RUFDQSxvQ0FBQTtBQUNBLG9DQUFBO0VBQ0EsbUNBQUE7QUFDQSwwQkFBQTtFQUNBLG1DQUFBO0NBMkNEO0FBMUNDO0VBQ0Usc0JBQUE7Q0E0Q0g7QUEzQ0M7RUFDRSxzQkFBQTtDQTZDSDtBQTNDRDtFQUNFLHVCQUFBO0NBNkNEO0FBNUNDO0VBQ0UsdUJBQUE7RUFDQSx1Q0FBQTtDQThDSDtBQTVDRDs7RUFDRSxVQUFBO0VBQ0EsV0FBQTtFQUNBLG9CQUFBO0VBQ0EsZ0JBQUE7RUFDQSxZQUFBO0NBK0NEO0FBN0NEO0VBQ0UsdUJBQUE7Q0ErQ0Q7QUEzQ0Q7RUFDRSxzQkFBQTtFQUNBLFNBQUE7RUFDQSxVQUFBO0NBNkNEO0FBNUNDO0VBQ0UsbUNBQUE7RUFDQSxvQ0FBQTtFQUNBLDhCQUFBO0NBOENIO0FBN0NDO0VBQ0UsbUNBQUE7RUFDQSxvQ0FBQTtFQUNBLDJCQUFBO0NBK0NIO0FBOUNDO0VBQ0Usa0NBQUE7RUFDQSxxQ0FBQTtFQUNBLDRCQUFBO0NBZ0RIO0FBL0NDO0VBQ0Usa0NBQUE7RUFDQSxxQ0FBQTtFQUNBLDZCQUFBO0NBaURIO0FBL0NEO0VBQ0UsY0FBQTtFQUNBLG9CQUFBO0VBQ0EsYUFBQTtFQUNBLFlBQUE7RUFDQSxZQUFBO0NBaUREO0FBaERDO0VBQ0UsbUJBQUE7RUFDQSxlQUFBO0VBQ0EsZUFBQTtDQWtESFwiLFwiZmlsZVwiOlwiZ2xvYmFsLnN0eWxcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNsaWRlLXVwLWVudGVyXFxyXFxuICBvcGFjaXR5IDBcXHJcXG4gIHRyYW5zZm9ybSB0cmFuc2xhdGUoMCwgNTAlKVxcclxcblxcclxcbi5zbGlkZS11cC1sZWF2ZS10b1xcclxcbiAgb3BhY2l0eSAwXFxyXFxuICB0cmFuc2Zvcm0gdHJhbnNsYXRlKDAsIC01MCUpXFxyXFxuXFxyXFxuLnNsaWRlLWRvd24tZW50ZXIsIC5zbGlkZS1kb3duLWxlYXZlLXRvXFxyXFxuICBvcGFjaXR5IDBcXHJcXG4gIHRyYW5zZm9ybSB0cmFuc2xhdGUoMCwgLTIwcHgpXFxyXFxuXFxyXFxuQGtleWZyYW1lcyByb3RhdGVcXHJcXG4gIDAlXFxyXFxuICAgIHRyYW5zZm9ybSByb3RhdGUoMGRlZylcXHJcXG4gIDEwMCVcXHJcXG4gICAgdHJhbnNmb3JtIHJvdGF0ZSgzNjBkZWcpXFxyXFxuXCIsXCJAaW1wb3J0IFxcXCIuL3ZhcmlhYmxlc1xcXCJcXHJcXG5AaW1wb3J0IFxcXCIuL3RyYW5zaXRpb25zXFxcIlxcclxcblxcclxcbkBmb250LWZhY2VcXHJcXG4gIGZvbnQtZmFtaWx5ICdNYXRlcmlhbCBJY29ucydcXHJcXG4gIGZvbnQtc3R5bGUgbm9ybWFsXFxyXFxuICBmb250LXdlaWdodCA0MDBcXHJcXG4gIHNyYyB1cmwoLi9hc3NldHMvTWF0ZXJpYWxJY29ucy1SZWd1bGFyLndvZmYyKSBmb3JtYXQoJ3dvZmYyJylcXHJcXG5cXHJcXG5AZm9udC1mYWNlXFxyXFxuICBmb250LWZhbWlseSAnUm9ib3RvJ1xcclxcbiAgZm9udC1zdHlsZSBub3JtYWxcXHJcXG4gIGZvbnQtd2VpZ2h0IDQwMFxcclxcbiAgc3JjIGxvY2FsKCdSb2JvdG8nKSwgbG9jYWwoJ1JvYm90by1SZWd1bGFyJyksIHVybCguL2Fzc2V0cy9Sb2JvdG8tUmVndWxhci53b2ZmMikgZm9ybWF0KCd3b2ZmMicpXFxyXFxuXFxyXFxuLm1hdGVyaWFsLWljb25zXFxyXFxuICBmb250LWZhbWlseSAnTWF0ZXJpYWwgSWNvbnMnXFxyXFxuICBmb250LXdlaWdodCBub3JtYWxcXHJcXG4gIGZvbnQtc3R5bGUgbm9ybWFsXFxyXFxuICBmb250LXNpemUgMjJweFxcclxcbiAgZGlzcGxheSBpbmxpbmUtYmxvY2tcXHJcXG4gIHdpZHRoIDFlbVxcclxcbiAgaGVpZ2h0IDFlbVxcclxcbiAgY29sb3IgIzk5OVxcclxcbiAgbGluZS1oZWlnaHQgMVxcclxcbiAgdGV4dC10cmFuc2Zvcm0gbm9uZVxcclxcbiAgbGV0dGVyLXNwYWNpbmcgbm9ybWFsXFxyXFxuICB3b3JkLXdyYXAgbm9ybWFsXFxyXFxuICB3aGl0ZS1zcGFjZSBub3dyYXBcXHJcXG4gIGRpcmVjdGlvbiBsdHJcXHJcXG4gIC8qIFN1cHBvcnQgZm9yIGFsbCBXZWJLaXQgYnJvd3NlcnMuICovXFxyXFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZFxcclxcbiAgLyogU3VwcG9ydCBmb3IgU2FmYXJpIGFuZCBDaHJvbWUuICovXFxyXFxuICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5XFxyXFxuICAvKiBTdXBwb3J0IGZvciBGaXJlZm94LiAqL1xcclxcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZVxcclxcbiAgJi5tZWRpdW1cXHJcXG4gICAgdHJhbnNmb3JtIHNjYWxlKDAuOSlcXHJcXG4gICYuc21hbGxcXHJcXG4gICAgdHJhbnNmb3JtIHNjYWxlKDAuOClcXHJcXG5cXHJcXG4udG9nZ2xlLXJlY29yZGluZyAubWF0ZXJpYWwtaWNvbnNcXHJcXG4gIGNvbG9yICM5OTkgIWltcG9ydGFudFxcclxcbiAgJi5lbmFibGVkXFxyXFxuICAgIGNvbG9yIHJlZCAhaW1wb3J0YW50XFxyXFxuICAgIHRleHQtc2hhZG93IDAgMCAzcHggcmdiYSgyNTUsIDAsIDAsIC40KVxcclxcblxcclxcbmh0bWwsIGJvZHlcXHJcXG4gIG1hcmdpbiAwXFxyXFxuICBwYWRkaW5nIDBcXHJcXG4gIGZvbnQtZmFtaWx5IFJvYm90b1xcclxcbiAgZm9udC1zaXplIDE2cHhcXHJcXG4gIGNvbG9yICM0NDRcXHJcXG5cXHJcXG4qXFxyXFxuICBib3gtc2l6aW5nIGJvcmRlci1ib3hcXHJcXG5cXHJcXG4kYXJyb3ctY29sb3IgPSAjNDQ0XFxyXFxuXFxyXFxuLmFycm93XFxyXFxuICBkaXNwbGF5IGlubGluZS1ibG9ja1xcclxcbiAgd2lkdGggMFxcclxcbiAgaGVpZ2h0IDBcXHJcXG4gICYudXBcXHJcXG4gICAgYm9yZGVyLWxlZnQgNHB4IHNvbGlkIHRyYW5zcGFyZW50XFxyXFxuICAgIGJvcmRlci1yaWdodCA0cHggc29saWQgdHJhbnNwYXJlbnRcXHJcXG4gICAgYm9yZGVyLWJvdHRvbSA2cHggc29saWQgJGFycm93LWNvbG9yXFxyXFxuICAmLmRvd25cXHJcXG4gICAgYm9yZGVyLWxlZnQgNHB4IHNvbGlkIHRyYW5zcGFyZW50XFxyXFxuICAgIGJvcmRlci1yaWdodCA0cHggc29saWQgdHJhbnNwYXJlbnRcXHJcXG4gICAgYm9yZGVyLXRvcCA2cHggc29saWQgJGFycm93LWNvbG9yXFxyXFxuICAmLnJpZ2h0XFxyXFxuICAgIGJvcmRlci10b3AgNHB4IHNvbGlkIHRyYW5zcGFyZW50XFxyXFxuICAgIGJvcmRlci1ib3R0b20gNHB4IHNvbGlkIHRyYW5zcGFyZW50XFxyXFxuICAgIGJvcmRlci1sZWZ0IDZweCBzb2xpZCAkYXJyb3ctY29sb3JcXHJcXG4gICYubGVmdFxcclxcbiAgICBib3JkZXItdG9wIDRweCBzb2xpZCB0cmFuc3BhcmVudFxcclxcbiAgICBib3JkZXItYm90dG9tIDRweCBzb2xpZCB0cmFuc3BhcmVudFxcclxcbiAgICBib3JkZXItcmlnaHQgNnB4IHNvbGlkICRhcnJvdy1jb2xvclxcclxcblxcclxcbi5ub3RpY2VcXHJcXG4gIGRpc3BsYXkgZmxleFxcclxcbiAgYWxpZ24taXRlbXMgY2VudGVyXFxyXFxuICBoZWlnaHQgMTAwJVxcclxcbiAgd2lkdGggMTAwJVxcclxcbiAgY29sb3IgI2FhYVxcclxcbiAgZGl2XFxyXFxuICAgIHRleHQtYWxpZ24gY2VudGVyXFxyXFxuICAgIHBhZGRpbmcgMC41ZW1cXHJcXG4gICAgbWFyZ2luIDAgYXV0b1xcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMzQ5OWM4ODFcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc3R5bHVzLWxvYWRlciEuLi9zcmMvZ2xvYmFsLnN0eWxcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5hcHBbZGF0YS12LTM0OTljODgxXSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG4uYXBwIGgxW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgY29sb3I6ICM0MmI5ODM7XFxufVxcbi5hcHAuZGFya1tkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyNDI0MjQ7XFxufVxcbi5oZWFkZXJbZGF0YS12LTM0OTljODgxXSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xcbiAgYm94LXNoYWRvdzogMCAwIDhweCByZ2JhKDAsMCwwLDAuMTUpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uYXBwLmRhcmsgLmhlYWRlcltkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjM2EzYTNhO1xcbn1cXG4ubG9nb1tkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIHdpZHRoOiAzMHB4O1xcbiAgaGVpZ2h0OiAzMHB4O1xcbiAgbWFyZ2luOiAwIDE1cHg7XFxufVxcbi5tZXNzYWdlLWNvbnRhaW5lcltkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIGhlaWdodDogMWVtO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG4ubWVzc2FnZVtkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIGNvbG9yOiAjM2JhNzc2O1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLmJ1dHRvbltkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGNvbG9yOiAjODg4O1xcbiAgdHJhbnNpdGlvbjogY29sb3IgMC4zNXMgZWFzZTtcXG59XFxuLmFwcC5kYXJrIC5idXR0b25bZGF0YS12LTM0OTljODgxXSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjQyNDI0O1xcbn1cXG4uYnV0dG9uW2RhdGEtdi0zNDk5Yzg4MV06aG92ZXIge1xcbiAgY29sb3I6ICM1NTU7XFxufVxcbi5idXR0b24uYWN0aXZlW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgY29sb3I6ICMzYmE3NzY7XFxufVxcbi5idXR0b25bZGF0YS12LTM0OTljODgxXTpmaXJzdC1vZi10eXBlIHtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbn1cXG4uYnV0dG9uIC5tYXRlcmlhbC1pY29uc1tkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcbi5idXR0b24gLnBhbmUtbmFtZVtkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiA4MjBweCkge1xcbi5idXR0b25bZGF0YS12LTM0OTljODgxXSB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDIwcHg7XFxuICAgIHBhZGRpbmctbGVmdDogMjBweDtcXG59XFxuLmJ1dHRvbiAucGFuZS1uYW1lW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG59XFxufVxcbkBtZWRpYSAobWluLWhlaWdodDogMzAwcHgpIHtcXG4uYnV0dG9uW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgICBwYWRkaW5nLXRvcDogMjBweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDIwcHg7XFxufVxcbn1cXG4uY29udGFpbmVyW2RhdGEtdi0zNDk5Yzg4MV0ge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGZsZXg6IDE7XFxufVxcbi5ldmVudC1jb3VudFtkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMzYmE3NzY7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIHdpZHRoOiAxOHB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgcGFkZGluZy10b3A6IDRweDtcXG4gIGZvbnQtc2l6ZTogOXB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IDEycHg7XFxufVxcbi5hcHAuZGFyayAuZXZlbnQtY291bnRbZGF0YS12LTM0OTljODgxXSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjQyNDI0O1xcbn1cXG4uYWN0aXZlLWJhcltkYXRhLXYtMzQ5OWM4ODFdIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogMDtcXG4gIHdpZHRoOiAwcHg7XFxuICBoZWlnaHQ6IDNweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMzYmE3NzY7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zMnMgY3ViaWMtYmV6aWVyKDAsIDAuOSwgMC42LCAxKTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkc6L2x1b2JhdGEvbGliL21hdGNoLWRldnRvb2xzL3NyYy9BcHAudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFxRkE7RUFDRSxZQUFBO0VBQ0EsYUFBQTtFQUNBLGtCQUFBO0VBQ0EsdUJBQUE7RUFDQSxjQUFBO0VBQ0EsdUJBQUE7Q0FwRkQ7QUFxRkM7RUFDRSxlQUFBO0NBbkZIO0FBb0ZDO0VBQ0UsMEJBQUE7Q0FsRkg7QUFtRkQ7RUFDRSxjQUFBO0VBQ0Esb0JBQUE7RUFDQSw4QkFBQTtFQUNBLHFDQUFBO0VBQ0EsZ0JBQUE7RUFDQSxtQkFBQTtDQWpGRDtBQWtGQztFQUNFLGlDQUFBO0NBaEZIO0FBaUZEO0VBQ0UsWUFBQTtFQUNBLGFBQUE7RUFDQSxlQUFBO0NBL0VEO0FBZ0ZEO0VBQ0UsWUFBQTtFQUNBLGdCQUFBO0NBOUVEO0FBK0VEO0VBQ0UsZUFBQTtFQUNBLDBCQUFBO0VBQ0EsbUJBQUE7Q0E3RUQ7QUE4RUQ7RUFDRSxjQUFBO0VBQ0EsY0FBQTtFQUNBLG9CQUFBO0VBQ0EsZ0JBQUE7RUFDQSxtQkFBQTtFQUNBLGlDQUFBO0VBQ0EsdUJBQUE7RUFDQSxZQUFBO0VBQ0EsNkJBQUE7Q0E1RUQ7QUE2RUM7RUFDRSwwQkFBQTtDQTNFSDtBQTRFQztFQUNFLFlBQUE7Q0ExRUg7QUEyRUM7RUFDRSxlQUFBO0NBekVIO0FBMEVDO0VBQ0Usa0JBQUE7Q0F4RUg7QUF5RUM7RUFDRSxnQkFBQTtFQUNBLGtCQUFBO0VBQ0EsZUFBQTtDQXZFSDtBQXdFQztFQUNFLGNBQUE7Q0F0RUg7QUF1RXlCO0FBQUE7SUFDdEIsb0JBQUE7SUFDQSxtQkFBQTtDQXBFRDtBQXFFQztJQUNFLGVBQUE7Q0FuRUg7Q0FDRjtBQW1FMEI7QUFBQTtJQUN2QixrQkFBQTtJQUNBLHFCQUFBO0NBaEVEO0NBQ0Y7QUFnRUQ7RUFDRSxpQkFBQTtFQUNBLFFBQUE7Q0E5REQ7QUFnRUQ7RUFDRSwwQkFBQTtFQUNBLFlBQUE7RUFDQSxtQkFBQTtFQUNBLFlBQUE7RUFDQSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSxpQkFBQTtFQUNBLGVBQUE7RUFDQSxtQkFBQTtFQUNBLFNBQUE7RUFDQSxVQUFBO0NBOUREO0FBK0RDO0VBQ0UsMEJBQUE7Q0E3REg7QUE4REQ7RUFDRSxtQkFBQTtFQUNBLFVBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtFQUNBLDBCQUFBO0VBQ0EsbURBQUE7Q0E1RERcIixcImZpbGVcIjpcIkFwcC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmFwcCB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG4uYXBwIGgxIHtcXG4gIGNvbG9yOiAjNDJiOTgzO1xcbn1cXG4uYXBwLmRhcmsge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzI0MjQyNDtcXG59XFxuLmhlYWRlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xcbiAgYm94LXNoYWRvdzogMCAwIDhweCByZ2JhKDAsMCwwLDAuMTUpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uYXBwLmRhcmsgLmhlYWRlciB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzNhM2EzYTtcXG59XFxuLmxvZ28ge1xcbiAgd2lkdGg6IDMwcHg7XFxuICBoZWlnaHQ6IDMwcHg7XFxuICBtYXJnaW46IDAgMTVweDtcXG59XFxuLm1lc3NhZ2UtY29udGFpbmVyIHtcXG4gIGhlaWdodDogMWVtO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG4ubWVzc2FnZSB7XFxuICBjb2xvcjogIzNiYTc3NjtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi5idXR0b24ge1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgY29sb3I6ICM4ODg7XFxuICB0cmFuc2l0aW9uOiBjb2xvciAwLjM1cyBlYXNlO1xcbn1cXG4uYXBwLmRhcmsgLmJ1dHRvbiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjQyNDI0O1xcbn1cXG4uYnV0dG9uOmhvdmVyIHtcXG4gIGNvbG9yOiAjNTU1O1xcbn1cXG4uYnV0dG9uLmFjdGl2ZSB7XFxuICBjb2xvcjogIzNiYTc3NjtcXG59XFxuLmJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbn1cXG4uYnV0dG9uIC5tYXRlcmlhbC1pY29ucyB7XFxuICBmb250LXNpemU6IDIwcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG4uYnV0dG9uIC5wYW5lLW5hbWUge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDgyMHB4KSB7XFxuICAuYnV0dG9uIHtcXG4gICAgcGFkZGluZy1yaWdodDogMjBweDtcXG4gICAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcbiAgfVxcbiAgLmJ1dHRvbiAucGFuZS1uYW1lIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICB9XFxufVxcbkBtZWRpYSAobWluLWhlaWdodDogMzAwcHgpIHtcXG4gIC5idXR0b24ge1xcbiAgICBwYWRkaW5nLXRvcDogMjBweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDIwcHg7XFxuICB9XFxufVxcbi5jb250YWluZXIge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGZsZXg6IDE7XFxufVxcbi5ldmVudC1jb3VudCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjM2JhNzc2O1xcbiAgY29sb3I6ICNmZmY7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICB3aWR0aDogMThweDtcXG4gIGhlaWdodDogMThweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHBhZGRpbmctdG9wOiA0cHg7XFxuICBmb250LXNpemU6IDlweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAxMnB4O1xcbn1cXG4uYXBwLmRhcmsgLmV2ZW50LWNvdW50IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyNDI0MjQ7XFxufVxcbi5hY3RpdmUtYmFyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogMDtcXG4gIHdpZHRoOiAwcHg7XFxuICBoZWlnaHQ6IDNweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMzYmE3NzY7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zMnMgY3ViaWMtYmV6aWVyKDAsIDAuOSwgMC42LCAxKTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zNDk5Yzg4MVwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3N0eWx1cy1sb2FkZXIhLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xIS4uL3NyYy9BcHAudnVlXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uc3BsaXQtcGFuZVtkYXRhLXYtM2QwYjFjMmNdIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcbi5zcGxpdC1wYW5lLmRyYWdnaW5nW2RhdGEtdi0zZDBiMWMyY10ge1xcbiAgY3Vyc29yOiBldy1yZXNpemU7XFxufVxcbi5sZWZ0W2RhdGEtdi0zZDBiMWMyY10sXFxuLnJpZ2h0W2RhdGEtdi0zZDBiMWMyY10ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4ubGVmdFtkYXRhLXYtM2QwYjFjMmNdIHtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XFxufVxcbi5hcHAuZGFyayAubGVmdFtkYXRhLXYtM2QwYjFjMmNdIHtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICMzYTNhM2E7XFxufVxcbi5kcmFnZ2VyW2RhdGEtdi0zZDBiMWMyY10ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogOTk7XFxuICB0b3A6IDA7XFxuICBib3R0b206IDA7XFxuICByaWdodDogLTVweDtcXG4gIHdpZHRoOiAxMHB4O1xcbiAgY3Vyc29yOiBldy1yZXNpemU7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJHOi9sdW9iYXRhL2xpYi9tYXRjaC1kZXZ0b29scy9zcmMvY29tcG9uZW50cy9zcmMvY29tcG9uZW50cy9zcGxpdFBhbmUvc3BsaXRQYW5lLnZ1ZVwiLFwiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL2NvbXBvbmVudHMvc3BsaXRQYW5lL3NwbGl0UGFuZS52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQWdEQTtFQUNFLGNBQUE7RUFDQSxhQUFBO0NDL0NEO0FEZ0RDO0VBQ0Usa0JBQUE7Q0M5Q0g7QURnREQ7O0VBQ0UsbUJBQUE7Q0M3Q0Q7QUQrQ0Q7RUFDRSw2QkFBQTtDQzdDRDtBRDhDQztFQUNFLGdDQUFBO0NDNUNIO0FEOENEO0VBQ0UsbUJBQUE7RUFDQSxZQUFBO0VBQ0EsT0FBQTtFQUNBLFVBQUE7RUFDQSxZQUFBO0VBQ0EsWUFBQTtFQUNBLGtCQUFBO0NDNUNEXCIsXCJmaWxlXCI6XCJzcGxpdFBhbmUudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbkBpbXBvcnQgXFxcIi4uLy4uL3ZhcmlhYmxlc1xcXCJcXG5cXG4uc3BsaXQtcGFuZVxcbiAgZGlzcGxheSBmbGV4XFxuICBoZWlnaHQgMTAwJVxcbiAgJi5kcmFnZ2luZ1xcbiAgICBjdXJzb3IgZXctcmVzaXplXFxuXFxuLmxlZnQsIC5yaWdodFxcbiAgcG9zaXRpb24gcmVsYXRpdmVcXG5cXG4ubGVmdFxcbiAgYm9yZGVyLXJpZ2h0IDFweCBzb2xpZCAkYm9yZGVyLWNvbG9yXFxuICAuYXBwLmRhcmsgJlxcbiAgICBib3JkZXItcmlnaHQgMXB4IHNvbGlkICRkYXJrLWJvcmRlci1jb2xvclxcblxcbi5kcmFnZ2VyXFxuICBwb3NpdGlvbiBhYnNvbHV0ZVxcbiAgei1pbmRleCA5OVxcbiAgdG9wIDBcXG4gIGJvdHRvbSAwXFxuICByaWdodCAtNXB4XFxuICB3aWR0aCAxMHB4XFxuICBjdXJzb3IgZXctcmVzaXplXFxuXCIsXCIuc3BsaXQtcGFuZSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG4uc3BsaXQtcGFuZS5kcmFnZ2luZyB7XFxuICBjdXJzb3I6IGV3LXJlc2l6ZTtcXG59XFxuLmxlZnQsXFxuLnJpZ2h0IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmxlZnQge1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2RkZDtcXG59XFxuLmFwcC5kYXJrIC5sZWZ0IHtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICMzYTNhM2E7XFxufVxcbi5kcmFnZ2VyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDk5O1xcbiAgdG9wOiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgcmlnaHQ6IC01cHg7XFxuICB3aWR0aDogMTBweDtcXG4gIGN1cnNvcjogZXctcmVzaXplO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTNkMGIxYzJjXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc3R5bHVzLWxvYWRlciEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvc3BsaXRQYW5lL3NwbGl0UGFuZS52dWVcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJmaWxlXCI6XCJtYXRjaC5jc3NcIixcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtZDZmYTNlYjRcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hUYWIvbWF0Y2guY3NzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uZGF0YS13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxuICBwYWRkaW5nLXRvcDogMjBweDtcXG59XFxuLmRhdGEtZmllbGRzIHtcXG4gIHBhZGRpbmc6IDIwcHggMjBweCA0MHB4O1xcbn1cXG4uZGF0YS1lbCB7XFxuICBwYWRkaW5nOiAwcHggMTBweDtcXG4gIGZsZXg6IDEgMCAzMy4zMyU7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi5kYXRhLWVsIC5kYXRhLXR5cGUge1xcbiAgY29sb3I6ICM0ODY4ODc7XFxuICBwYWRkaW5nLWxlZnQ6IDIwcHg7XFxuICBtYXJnaW4tYm90dG9tOiAtMTBweDtcXG59XFxuLmFwcC5kYXJrIC5kYXRhLWVsIC5kYXRhLXR5cGUge1xcbiAgY29sb3I6ICM3NTk1YjU7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJHOi9sdW9iYXRhL2xpYi9tYXRjaC1kZXZ0b29scy9zcmMvY29tcG9uZW50cy9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9tYXRjaE9iai52dWVcIixcIkc6L2x1b2JhdGEvbGliL21hdGNoLWRldnRvb2xzL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL21hdGNoT2JqLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBNENBO0VBQ0UsY0FBQTtFQUNBLGdCQUFBO0VBQ0Esa0JBQUE7Q0MzQ0Q7QUQ2Q0Q7RUFDRSx3QkFBQTtDQzNDRDtBRDZDRDtFQUNFLGtCQUFBO0VBQ0EsaUJBQUE7RUFDQSxnQkFBQTtDQzNDRDtBRDZDQztFQUNFLGVBQUE7RUFDQSxtQkFBQTtFQUNBLHFCQUFBO0NDM0NIO0FENkNHO0VBQ0UsZUFBQTtDQzNDTFwiLFwiZmlsZVwiOlwibWF0Y2hPYmoudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi5kYXRhLXdyYXBwZXJcXG4gIGRpc3BsYXkgZmxleFxcbiAgZmxleC13cmFwIHdyYXBcXG4gIHBhZGRpbmctdG9wIDIwcHhcXG5cXG4uZGF0YS1maWVsZHNcXG4gIHBhZGRpbmcgMjBweCAyMHB4IDQwcHhcXG5cXG4uZGF0YS1lbFxcbiAgcGFkZGluZyAwcHggMTBweFxcbiAgZmxleCAxIDAgMzMuMzMlXFxuICBmb250LXNpemUgMTRweFxcblxcbiAgLmRhdGEtdHlwZVxcbiAgICBjb2xvciAjNDg2ODg3XFxuICAgIHBhZGRpbmctbGVmdCAyMHB4XFxuICAgIG1hcmdpbi1ib3R0b20gLTEwcHhcXG5cXG4gICAgLmFwcC5kYXJrICZcXG4gICAgICBjb2xvciBsaWdodGVuKCM0ODY4ODcsIDMwJSlcXG5cIixcIi5kYXRhLXdyYXBwZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtd3JhcDogd3JhcDtcXG4gIHBhZGRpbmctdG9wOiAyMHB4O1xcbn1cXG4uZGF0YS1maWVsZHMge1xcbiAgcGFkZGluZzogMjBweCAyMHB4IDQwcHg7XFxufVxcbi5kYXRhLWVsIHtcXG4gIHBhZGRpbmc6IDBweCAxMHB4O1xcbiAgZmxleDogMSAwIDMzLjMzJTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuLmRhdGEtZWwgLmRhdGEtdHlwZSB7XFxuICBjb2xvcjogIzQ4Njg4NztcXG4gIHBhZGRpbmctbGVmdDogMjBweDtcXG4gIG1hcmdpbi1ib3R0b206IC0xMHB4O1xcbn1cXG4uYXBwLmRhcmsgLmRhdGEtZWwgLmRhdGEtdHlwZSB7XFxuICBjb2xvcjogIzc1OTViNTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1lMWNjYTIzNFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zdHlsdXMtbG9hZGVyIS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9tYXRjaE9iai52dWVcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5kYXRhLWZpZWxkW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgdXNlci1zZWxlY3Q6IHRleHQ7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBmb250LWZhbWlseTogTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2U7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcbi5zZWxmW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgcGFkZGluZy1sZWZ0OiAxNHB4O1xcbn1cXG4uc2VsZiBzcGFuW2RhdGEtdi1lY2FhZjVhOF0sXFxuLnNlbGYgZGl2W2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuLnNlbGYgLmFycm93W2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA3cHg7XFxuICBsZWZ0OiAwcHg7XFxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xcyBlYXNlO1xcbn1cXG4uc2VsZiAuYXJyb3cucm90YXRlZFtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG59XFxuLnNlbGYgLmtleVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGNvbG9yOiAjODgxMzkxO1xcbn1cXG4uc2VsZiAuY29sb25bZGF0YS12LWVjYWFmNWE4XSB7XFxuICBtYXJnaW4tcmlnaHQ6IDAuNWVtO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uc2VsZiAudmFsdWVbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBjb2xvcjogIzQ0NDtcXG59XFxuLnNlbGYgLnZhbHVlLnN0cmluZ1tkYXRhLXYtZWNhYWY1YThdLFxcbi5zZWxmIC52YWx1ZS5uYXRpdmVbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBjb2xvcjogI2M0MWExNjtcXG59XFxuLnNlbGYgLnZhbHVlLm51bGxbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBjb2xvcjogIzk5OTtcXG59XFxuLnNlbGYgLnZhbHVlLmxpdGVyYWxbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBjb2xvcjogIzAzYztcXG59XFxuLnNlbGYgLnR5cGVbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBjb2xvcjogI2ZmZjtcXG4gIHBhZGRpbmc6IDNweCA2cHg7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICBsaW5lLWhlaWdodDogMTBweDtcXG4gIGhlaWdodDogMTZweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIG1hcmdpbjogMnB4IDZweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxufVxcbi5zZWxmIC50eXBlLnByb3BbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjOTZhZmRkO1xcbn1cXG4uc2VsZiAudHlwZS5jb21wdXRlZFtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNhZjkwZDU7XFxufVxcbi5zZWxmIC50eXBlLnZ1ZXgtZ2V0dGVyW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzVkZDVkNTtcXG59XFxuLnNlbGYgLnR5cGUuZmlyZWJhc2UtYmluZGluZ1tkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmYzA7XFxufVxcbi5zZWxmIC50eXBlLm9ic2VydmFibGVbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjk5O1xcbn1cXG4uc2VsZiAubWV0YVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiA5OTk7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBjb2xvcjogIzQ0NDtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IGNhbGMoMTAwJSArIDVweCk7XFxuICB3aWR0aDogMTUwcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZTNlM2UzO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgcGFkZGluZzogOHB4IDEycHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgbGluZS1oZWlnaHQ6IDE2cHg7XFxuICBib3gtc2hhZG93OiAwIDJweCAxMnB4IHJnYmEoMCwwLDAsMC4xKTtcXG59XFxuLnNlbGYgLm1ldGEgLmtleVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIHdpZHRoOiA2NXB4O1xcbn1cXG4uc2VsZiAubWV0YS1maWVsZFtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uc2VsZltkYXRhLXYtZWNhYWY1YThdOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLnNlbGY6aG92ZXIgLm1ldGFbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLmFwcC5kYXJrIC5zZWxmIC5rZXlbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBjb2xvcjogI2UzNmVlYztcXG59XFxuLmFwcC5kYXJrIC5zZWxmIC52YWx1ZVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGNvbG9yOiAjYmRjNmNmO1xcbn1cXG4uYXBwLmRhcmsgLnNlbGYgLnZhbHVlLnN0cmluZ1tkYXRhLXYtZWNhYWY1YThdLFxcbi5hcHAuZGFyayAuc2VsZiAudmFsdWUubmF0aXZlW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgY29sb3I6ICNlMzNlM2E7XFxufVxcbi5hcHAuZGFyayAuc2VsZiAudmFsdWUubnVsbFtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG4uYXBwLmRhcmsgLnNlbGYgLnZhbHVlLmxpdGVyYWxbZGF0YS12LWVjYWFmNWE4XSB7XFxuICBjb2xvcjogIzk5N2ZmZjtcXG59XFxuLmFwcC5kYXJrIC5zZWxmIC50eXBlW2RhdGEtdi1lY2FhZjVhOF0ge1xcbiAgY29sb3I6ICMyNDI0MjQ7XFxufVxcbi5hcHAuZGFyayAuc2VsZiAudHlwZSAubWV0YVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICMzYTNhM2E7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjQyNDI0O1xcbn1cXG4ubW9yZVtkYXRhLXYtZWNhYWY1YThdIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIHBhZGRpbmc6IDAgNHB4IDRweDtcXG59XFxuLm1vcmVbZGF0YS12LWVjYWFmNWE4XTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL2NvbXBvbmVudHMvc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovZGF0YUZpZWxkLnZ1ZVwiLFwiRzovbHVvYmF0YS9saWIvbWF0Y2gtZGV2dG9vbHMvc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovZGF0YUZpZWxkLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBeUpBO0VBQ0Usa0JBQUE7RUFDQSxnQkFBQTtFQUNBLHdDQUFBO0VBQ0EsZ0JBQUE7Q0N4SkQ7QUQwSkQ7RUFDRSxhQUFBO0VBQ0Esa0JBQUE7RUFDQSxtQkFBQTtFQUNBLG9CQUFBO0VBQ0EsbUJBQUE7Q0N4SkQ7QUR5SkM7O0VBQ0Usc0JBQUE7RUFDQSx1QkFBQTtDQ3RKSDtBRHVKQztFQUNFLG1CQUFBO0VBQ0EsU0FBQTtFQUNBLFVBQUE7RUFDQSxnQ0FBQTtDQ3JKSDtBRHNKRztFQUNFLHlCQUFBO0NDcEpMO0FEcUpDO0VBQ0UsZUFBQTtDQ25KSDtBRG9KQztFQUNFLG9CQUFBO0VBQ0EsbUJBQUE7Q0NsSkg7QURtSkM7RUFDRSxZQUFBO0NDakpIO0FEa0pHOztFQUNFLGVBQUE7Q0MvSUw7QURnSkc7RUFDRSxZQUFBO0NDOUlMO0FEK0lHO0VBQ0UsWUFBQTtDQzdJTDtBRCtJQztFQUNFLFlBQUE7RUFDQSxpQkFBQTtFQUNBLGdCQUFBO0VBQ0Esa0JBQUE7RUFDQSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSxnQkFBQTtFQUNBLG1CQUFBO0VBQ0EsdUJBQUE7Q0M3SUg7QUQ4SUc7RUFDRSwwQkFBQTtDQzVJTDtBRDZJRztFQUNFLDBCQUFBO0NDM0lMO0FENElHO0VBQ0UsMEJBQUE7Q0MxSUw7QUQySUc7RUFDRSx1QkFBQTtDQ3pJTDtBRDBJRztFQUNFLHVCQUFBO0NDeElMO0FEMElDO0VBQ0UsY0FBQTtFQUNBLG1CQUFBO0VBQ0EsYUFBQTtFQUNBLGdCQUFBO0VBQ0EsWUFBQTtFQUNBLE9BQUE7RUFDQSx1QkFBQTtFQUNBLGFBQUE7RUFDQSwwQkFBQTtFQUNBLG1CQUFBO0VBQ0Esa0JBQUE7RUFDQSx1QkFBQTtFQUNBLGtCQUFBO0VBQ0EsdUNBQUE7Q0N4SUg7QUR5SUc7RUFDRSxZQUFBO0NDdklMO0FEd0lDO0VBQ0UsZUFBQTtDQ3RJSDtBRHVJQztFQUNFLGdCQUFBO0NDcklIO0FEc0lHO0VBQ0UsZUFBQTtDQ3BJTDtBRHVJRztFQUNFLGVBQUE7Q0NySUw7QURzSUc7RUFDRSxlQUFBO0NDcElMO0FEcUlLOztFQUNFLGVBQUE7Q0NsSVA7QURtSUs7RUFDRSxZQUFBO0NDaklQO0FEa0lLO0VBQ0UsZUFBQTtDQ2hJUDtBRGlJRztFQUNFLGVBQUE7Q0MvSEw7QURnSUs7RUFDRSwwQkFBQTtFQUNBLDBCQUFBO0NDOUhQO0FEaUlEO0VBQ0UsZ0JBQUE7RUFDQSxzQkFBQTtFQUNBLG1CQUFBO0VBQ0EsbUJBQUE7Q0MvSEQ7QURnSUM7RUFDRSx1QkFBQTtDQzlISFwiLFwiZmlsZVwiOlwiZGF0YUZpZWxkLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5AaW1wb3J0IFxcXCIuLi8uLi92YXJpYWJsZXNcXFwiXFxuXFxuLmRhdGEtZmllbGRcXG4gIHVzZXItc2VsZWN0IHRleHRcXG4gIGZvbnQtc2l6ZSAxMnB4XFxuICBmb250LWZhbWlseSBNZW5sbywgQ29uc29sYXMsIG1vbm9zcGFjZVxcbiAgY3Vyc29yIGRlZmF1bHRcXG5cXG4uc2VsZlxcbiAgaGVpZ2h0IDIwcHhcXG4gIGxpbmUtaGVpZ2h0IDIwcHhcXG4gIHBvc2l0aW9uIHJlbGF0aXZlXFxuICB3aGl0ZS1zcGFjZSBub3dyYXBcXG4gIHBhZGRpbmctbGVmdCAxNHB4XFxuICBzcGFuLCBkaXZcXG4gICAgZGlzcGxheSBpbmxpbmUtYmxvY2tcXG4gICAgdmVydGljYWwtYWxpZ24gbWlkZGxlXFxuICAuYXJyb3dcXG4gICAgcG9zaXRpb24gYWJzb2x1dGVcXG4gICAgdG9wIDdweFxcbiAgICBsZWZ0IDBweFxcbiAgICB0cmFuc2l0aW9uIHRyYW5zZm9ybSAuMXMgZWFzZVxcbiAgICAmLnJvdGF0ZWRcXG4gICAgICB0cmFuc2Zvcm0gcm90YXRlKDkwZGVnKVxcbiAgLmtleVxcbiAgICBjb2xvciAjODgxMzkxXFxuICAuY29sb25cXG4gICAgbWFyZ2luLXJpZ2h0IC41ZW1cXG4gICAgcG9zaXRpb24gcmVsYXRpdmVcXG4gIC52YWx1ZVxcbiAgICBjb2xvciAjNDQ0XFxuICAgICYuc3RyaW5nLCAmLm5hdGl2ZVxcbiAgICAgIGNvbG9yICNjNDFhMTZcXG4gICAgJi5udWxsXFxuICAgICAgY29sb3IgIzk5OVxcbiAgICAmLmxpdGVyYWxcXG4gICAgICBjb2xvciAjMDAzM2NjXFxuXFxuICAudHlwZVxcbiAgICBjb2xvciAkYmFja2dyb3VuZC1jb2xvclxcbiAgICBwYWRkaW5nIDNweCA2cHhcXG4gICAgZm9udC1zaXplIDEwcHhcXG4gICAgbGluZS1oZWlnaHQgMTBweFxcbiAgICBoZWlnaHQgMTZweFxcbiAgICBib3JkZXItcmFkaXVzIDNweFxcbiAgICBtYXJnaW4gMnB4IDZweFxcbiAgICBwb3NpdGlvbiByZWxhdGl2ZVxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yICNlZWVcXG4gICAgJi5wcm9wXFxuICAgICAgYmFja2dyb3VuZC1jb2xvciAjOTZhZmRkXFxuICAgICYuY29tcHV0ZWRcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yICNhZjkwZDVcXG4gICAgJi52dWV4LWdldHRlclxcbiAgICAgIGJhY2tncm91bmQtY29sb3IgIzVkZDVkNVxcbiAgICAmLmZpcmViYXNlLWJpbmRpbmdcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yICNmZmNjMDBcXG4gICAgJi5vYnNlcnZhYmxlXFxuICAgICAgYmFja2dyb3VuZC1jb2xvciAjZmY5OTk5XFxuXFxuICAubWV0YVxcbiAgICBkaXNwbGF5IG5vbmVcXG4gICAgcG9zaXRpb24gYWJzb2x1dGVcXG4gICAgei1pbmRleCA5OTlcXG4gICAgZm9udC1zaXplIDExcHhcXG4gICAgY29sb3IgIzQ0NFxcbiAgICB0b3AgMFxcbiAgICBsZWZ0IGNhbGMoMTAwJSArIDVweClcXG4gICAgd2lkdGggMTUwcHhcXG4gICAgYm9yZGVyIDFweCBzb2xpZCAjZTNlM2UzXFxuICAgIGJvcmRlci1yYWRpdXMgM3B4XFxuICAgIHBhZGRpbmcgOHB4IDEycHhcXG4gICAgYmFja2dyb3VuZC1jb2xvciAkYmFja2dyb3VuZC1jb2xvclxcbiAgICBsaW5lLWhlaWdodCAxNnB4XFxuICAgIGJveC1zaGFkb3cgMCAycHggMTJweCByZ2JhKDAsMCwwLC4xKVxcbiAgICAua2V5XFxuICAgICAgd2lkdGggNjVweFxcbiAgLm1ldGEtZmllbGRcXG4gICAgZGlzcGxheSBibG9ja1xcbiAgJjpob3ZlclxcbiAgICBjdXJzb3IgcG9pbnRlclxcbiAgICAubWV0YVxcbiAgICAgIGRpc3BsYXkgYmxvY2tcXG5cXG4gIC5hcHAuZGFyayAmXFxuICAgIC5rZXlcXG4gICAgICBjb2xvcjogI2UzNmVlY1xcbiAgICAudmFsdWVcXG4gICAgICBjb2xvciAjYmRjNmNmXFxuICAgICAgJi5zdHJpbmcsICYubmF0aXZlXFxuICAgICAgICBjb2xvciAjZTMzZTNhXFxuICAgICAgJi5udWxsXFxuICAgICAgICBjb2xvciAjOTk5XFxuICAgICAgJi5saXRlcmFsXFxuICAgICAgICBjb2xvciAjOTk3ZmZmXFxuICAgIC50eXBlXFxuICAgICAgY29sb3I6ICMyNDI0MjRcXG4gICAgICAubWV0YVxcbiAgICAgICAgYm9yZGVyIDFweCBzb2xpZCAkZGFyay1ib3JkZXItY29sb3JcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3IgJGRhcmstYmFja2dyb3VuZC1jb2xvclxcblxcblxcbi5tb3JlXFxuICBjdXJzb3IgcG9pbnRlclxcbiAgZGlzcGxheSBpbmxpbmUtYmxvY2tcXG4gIGJvcmRlci1yYWRpdXMgNHB4XFxuICBwYWRkaW5nIDAgNHB4IDRweFxcbiAgJjpob3ZlclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yICNlZWVcXG5cIixcIi5kYXRhLWZpZWxkIHtcXG4gIHVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZm9udC1mYW1pbHk6IE1lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG4uc2VsZiB7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICBsaW5lLWhlaWdodDogMjBweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICBwYWRkaW5nLWxlZnQ6IDE0cHg7XFxufVxcbi5zZWxmIHNwYW4sXFxuLnNlbGYgZGl2IHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcbi5zZWxmIC5hcnJvdyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDdweDtcXG4gIGxlZnQ6IDBweDtcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGVhc2U7XFxufVxcbi5zZWxmIC5hcnJvdy5yb3RhdGVkIHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG59XFxuLnNlbGYgLmtleSB7XFxuICBjb2xvcjogIzg4MTM5MTtcXG59XFxuLnNlbGYgLmNvbG9uIHtcXG4gIG1hcmdpbi1yaWdodDogMC41ZW07XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5zZWxmIC52YWx1ZSB7XFxuICBjb2xvcjogIzQ0NDtcXG59XFxuLnNlbGYgLnZhbHVlLnN0cmluZyxcXG4uc2VsZiAudmFsdWUubmF0aXZlIHtcXG4gIGNvbG9yOiAjYzQxYTE2O1xcbn1cXG4uc2VsZiAudmFsdWUubnVsbCB7XFxuICBjb2xvcjogIzk5OTtcXG59XFxuLnNlbGYgLnZhbHVlLmxpdGVyYWwge1xcbiAgY29sb3I6ICMwM2M7XFxufVxcbi5zZWxmIC50eXBlIHtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgcGFkZGluZzogM3B4IDZweDtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMHB4O1xcbiAgaGVpZ2h0OiAxNnB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgbWFyZ2luOiAycHggNnB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG59XFxuLnNlbGYgLnR5cGUucHJvcCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjOTZhZmRkO1xcbn1cXG4uc2VsZiAudHlwZS5jb21wdXRlZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYWY5MGQ1O1xcbn1cXG4uc2VsZiAudHlwZS52dWV4LWdldHRlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNWRkNWQ1O1xcbn1cXG4uc2VsZiAudHlwZS5maXJlYmFzZS1iaW5kaW5nIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmYzA7XFxufVxcbi5zZWxmIC50eXBlLm9ic2VydmFibGUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y5OTtcXG59XFxuLnNlbGYgLm1ldGEge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDk5OTtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGNvbG9yOiAjNDQ0O1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogY2FsYygxMDAlICsgNXB4KTtcXG4gIHdpZHRoOiAxNTBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlM2UzZTM7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBwYWRkaW5nOiA4cHggMTJweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBsaW5lLWhlaWdodDogMTZweDtcXG4gIGJveC1zaGFkb3c6IDAgMnB4IDEycHggcmdiYSgwLDAsMCwwLjEpO1xcbn1cXG4uc2VsZiAubWV0YSAua2V5IHtcXG4gIHdpZHRoOiA2NXB4O1xcbn1cXG4uc2VsZiAubWV0YS1maWVsZCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLnNlbGY6aG92ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4uc2VsZjpob3ZlciAubWV0YSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLmFwcC5kYXJrIC5zZWxmIC5rZXkge1xcbiAgY29sb3I6ICNlMzZlZWM7XFxufVxcbi5hcHAuZGFyayAuc2VsZiAudmFsdWUge1xcbiAgY29sb3I6ICNiZGM2Y2Y7XFxufVxcbi5hcHAuZGFyayAuc2VsZiAudmFsdWUuc3RyaW5nLFxcbi5hcHAuZGFyayAuc2VsZiAudmFsdWUubmF0aXZlIHtcXG4gIGNvbG9yOiAjZTMzZTNhO1xcbn1cXG4uYXBwLmRhcmsgLnNlbGYgLnZhbHVlLm51bGwge1xcbiAgY29sb3I6ICM5OTk7XFxufVxcbi5hcHAuZGFyayAuc2VsZiAudmFsdWUubGl0ZXJhbCB7XFxuICBjb2xvcjogIzk5N2ZmZjtcXG59XFxuLmFwcC5kYXJrIC5zZWxmIC50eXBlIHtcXG4gIGNvbG9yOiAjMjQyNDI0O1xcbn1cXG4uYXBwLmRhcmsgLnNlbGYgLnR5cGUgLm1ldGEge1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzNhM2EzYTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyNDI0MjQ7XFxufVxcbi5tb3JlIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIHBhZGRpbmc6IDAgNHB4IDRweDtcXG59XFxuLm1vcmU6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1lY2FhZjVhOFwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3N0eWx1cy1sb2FkZXIhLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL2RhdGFGaWVsZC52dWVcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5hY3Rpb24taGVhZGVyW2RhdGEtdi1mYTM2YjQ0ZV0ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xcbiAgcGFkZGluZzogMCAxMHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxuICBjb2xvcjogIzY2NjtcXG4gIGhlaWdodDogMzVweDtcXG59XFxuQG1lZGlhIChtaW4taGVpZ2h0OiAzMDBweCkge1xcbi5hY3Rpb24taGVhZGVyW2RhdGEtdi1mYTM2YjQ0ZV0ge1xcbiAgICBoZWlnaHQ6IDUwcHg7XFxufVxcbn1cXG4uYXBwLmRhcmsgLmFjdGlvbi1oZWFkZXJbZGF0YS12LWZhMzZiNDRlXSB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzNhM2EzYTtcXG59XFxuLnRpdGxlW2RhdGEtdi1mYTM2YjQ0ZV0ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBjb2xvcjogIzNiYTc3NjtcXG59XFxuLmJ1dHRvbltkYXRhLXYtZmEzNmI0NGVdIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBwYWRkaW5nOiAwIDEwcHg7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMjVzO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIG9wYWNpdHk6IDAuODtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcbi5idXR0b25bZGF0YS12LWZhMzZiNDRlXTpmaXJzdC1vZi10eXBlIHtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbn1cXG4uYnV0dG9uW2RhdGEtdi1mYTM2YjQ0ZV06bm90KC5kaXNhYmxlZCk6aG92ZXIge1xcbiAgb3BhY2l0eTogMTtcXG4gIGNvbG9yOiAjM2JhNzc2O1xcbn1cXG4uYnV0dG9uLmRpc2FibGVkW2RhdGEtdi1mYTM2YjQ0ZV0ge1xcbiAgb3BhY2l0eTogMC40NTtcXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxufVxcbi5idXR0b24gc3BhbltkYXRhLXYtZmEzNmI0NGVdIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiA4MjBweCkge1xcbi5idXR0b24gc3BhbltkYXRhLXYtZmEzNmI0NGVdIHtcXG4gICAgZGlzcGxheTogaW5saW5lO1xcbn1cXG59XFxuLm1hdGVyaWFsLWljb25zW2RhdGEtdi1mYTM2YjQ0ZV0ge1xcbiAgZm9udC1zaXplOiAxOHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiA4MjBweCkge1xcbi5tYXRlcmlhbC1pY29uc1tkYXRhLXYtZmEzNmI0NGVdIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxufVxcbn1cXG4uc2VhcmNoW2RhdGEtdi1mYTM2YjQ0ZV0ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBmbGV4OiAxO1xcbn1cXG4uc2VhcmNoIGlucHV0W2RhdGEtdi1mYTM2YjQ0ZV0ge1xcbiAgZmxleDogMTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyOiAwO1xcbiAgbWFyZ2luLWxlZnQ6IDVweDtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgb3V0bGluZTogMDtcXG4gIHRyYW5zaXRpb246IGNvbG9yIDAuMjVzO1xcbn1cXG4uc2VhcmNoIGlucHV0W2RhdGEtdi1mYTM2YjQ0ZV06Zm9jdXMge1xcbiAgY29sb3I6ICMzYmE3NzY7XFxufVxcbi5zZWFyY2ggaW5wdXRbZGF0YS12LWZhMzZiNDRlXTo6cGxhY2Vob2xkZXIge1xcbiAgb3BhY2l0eTogMC44O1xcbn1cXG4uc2VhcmNoIGlucHV0LmludmFsaWRbZGF0YS12LWZhMzZiNDRlXSB7XFxuICBjb2xvcjogIzRkMGEwOTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkc6L2x1b2JhdGEvbGliL21hdGNoLWRldnRvb2xzL3NyYy9jb21wb25lbnRzL3NyYy9jb21wb25lbnRzL21hdGNoVGFiL2FjdGlvblRhYi52dWVcIixcIkc6L2x1b2JhdGEvbGliL21hdGNoLWRldnRvb2xzL3NyYy9jb21wb25lbnRzL21hdGNoVGFiL2FjdGlvblRhYi52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQVNBO0VBQ0UsY0FBQTtFQUNBLHFCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxnQkFBQTtFQUNBLDhCQUFBO0VBQ0EsWUFBQTtFQUNBLGFBQUE7Q0NSRDtBRFMwQjtBQUFBO0lBQ3ZCLGFBQUE7Q0NORDtDQUNGO0FETUM7RUFDRSxpQ0FBQTtDQ0pIO0FETUQ7RUFDRSxjQUFBO0VBQ0Esb0JBQUE7RUFDQSxnQkFBQTtFQUNBLGVBQUE7Q0NKRDtBRE1EO0VBQ0UsZ0JBQUE7RUFDQSxjQUFBO0VBQ0Esb0JBQUE7RUFDQSx3QkFBQTtFQUNBLGdCQUFBO0VBQ0EsMEJBQUE7RUFDQSxvQkFBQTtFQUNBLGFBQUE7RUFDQSxpQkFBQTtDQ0pEO0FETUM7RUFDRSxrQkFBQTtDQ0pIO0FETUM7RUFDRSxXQUFBO0VBQ0EsZUFBQTtDQ0pIO0FETUM7RUFDRSxjQUFBO0VBQ0Esb0JBQUE7Q0NKSDtBRE1DO0VBQ0UsY0FBQTtDQ0pIO0FESzJCO0FBQUE7SUFDdEIsZ0JBQUE7Q0NGSDtDQUNGO0FER0Q7RUFDRSxnQkFBQTtFQUNBLGdCQUFBO0VBQ0EsZUFBQTtDQ0REO0FERXlCO0FBQUE7SUFDdEIsa0JBQUE7Q0NDRDtDQUNGO0FEQUQ7RUFDRSxjQUFBO0VBQ0Esb0JBQUE7RUFDQSxRQUFBO0NDRUQ7QUREQztFQUNFLFFBQUE7RUFDQSxhQUFBO0VBQ0EsOEJBQUE7RUFDQSxVQUFBO0VBQ0EsaUJBQUE7RUFDQSxtQkFBQTtFQUNBLGVBQUE7RUFDQSxXQUFBO0VBQ0Esd0JBQUE7Q0NHSDtBREZHO0VBQ0UsZUFBQTtDQ0lMO0FERkc7RUFDRSxhQUFBO0NDSUw7QURGRztFQUNFLGVBQUE7Q0NJTFwiLFwiZmlsZVwiOlwiYWN0aW9uVGFiLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5AaW1wb3J0IFxcXCIuLi8uLi92YXJpYWJsZXNcXFwiXFxuXFxuLmFjdGlvbi1oZWFkZXJcXG4gIGRpc3BsYXkgZmxleFxcbiAgYWxpZ24taXRlbXMgc3RyZXRjaFxcbiAgcGFkZGluZyAwIDEwcHhcXG4gIGZvbnQtc2l6ZSAxMnB4XFxuICBib3JkZXItYm90dG9tIDFweCBzb2xpZCAkYm9yZGVyLWNvbG9yXFxuICBjb2xvciAjNjY2XFxuICBoZWlnaHQgMzVweFxcbiAgQG1lZGlhIChtaW4taGVpZ2h0OiAkdGFsbClcXG4gICAgaGVpZ2h0IDUwcHhcXG4gIC5hcHAuZGFyayAmXFxuICAgIGJvcmRlci1ib3R0b20gMXB4IHNvbGlkICRkYXJrLWJvcmRlci1jb2xvclxcblxcbi50aXRsZVxcbiAgZGlzcGxheSBmbGV4XFxuICBhbGlnbi1pdGVtcyBjZW50ZXJcXG4gIGZvbnQtc2l6ZSAxOHB4XFxuICBjb2xvciAkY29tcG9uZW50LWNvbG9yXFxuXFxuLmJ1dHRvblxcbiAgY3Vyc29yIHBvaW50ZXJcXG4gIGRpc3BsYXkgZmxleFxcbiAgYWxpZ24taXRlbXMgY2VudGVyXFxuICBqdXN0aWZ5LWNvbnRlbnQgY2VudGVyXFxuICBwYWRkaW5nIDAgMTBweFxcbiAgdHJhbnNpdGlvbiBvcGFjaXR5IDAuMjVzXFxuICB3aGl0ZS1zcGFjZSBub3dyYXBcXG4gIG9wYWNpdHkgMC44XFxuICBvdmVyZmxvdyBoaWRkZW5cXG5cXG4gICY6Zmlyc3Qtb2YtdHlwZVxcbiAgICBtYXJnaW4tbGVmdCBhdXRvXFxuXFxuICAmOm5vdCguZGlzYWJsZWQpOmhvdmVyXFxuICAgIG9wYWNpdHkgMVxcbiAgICBjb2xvciAkYWN0aXZlLWNvbG9yXFxuXFxuICAmLmRpc2FibGVkXFxuICAgIG9wYWNpdHkgMC40NVxcbiAgICBjdXJzb3Igbm90LWFsbG93ZWRcXG5cXG4gIHNwYW5cXG4gICAgZGlzcGxheSBub25lXFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiAkd2lkZSlcXG4gICAgICBkaXNwbGF5IGlubGluZVxcblxcbi5tYXRlcmlhbC1pY29uc1xcbiAgZm9udC1zaXplIDE4cHhcXG4gIG1hcmdpbi1yaWdodCAwXFxuICBjb2xvciBpbmhlcml0XFxuICBAbWVkaWEgKG1pbi13aWR0aDogJHdpZGUpXFxuICAgIG1hcmdpbi1yaWdodCA1cHhcXG5cXG4uc2VhcmNoXFxuICBkaXNwbGF5IGZsZXhcXG4gIGFsaWduLWl0ZW1zIGNlbnRlclxcbiAgZmxleCAxXFxuICBpbnB1dFxcbiAgICBmbGV4IDFcXG4gICAgaGVpZ2h0IDEwMCVcXG4gICAgYmFja2dyb3VuZC1jb2xvciB0cmFuc3BhcmVudFxcbiAgICBib3JkZXIgMFxcbiAgICBtYXJnaW4tbGVmdCA1cHhcXG4gICAgZm9udC1zaXplIGluaGVyaXRcXG4gICAgY29sb3IgaW5oZXJpdFxcbiAgICBvdXRsaW5lIDBcXG4gICAgdHJhbnNpdGlvbiBjb2xvciAwLjI1c1xcbiAgICAmOmZvY3VzXFxuICAgICAgY29sb3IgJGFjdGl2ZS1jb2xvclxcblxcbiAgICAmOjpwbGFjZWhvbGRlclxcbiAgICAgIG9wYWNpdHkgMC44XFxuXFxuICAgICYuaW52YWxpZFxcbiAgICAgIGNvbG9yIHJnYmEoNzcsIDEwLCA5LCAxKVxcblwiLFwiLmFjdGlvbi1oZWFkZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xcbiAgcGFkZGluZzogMCAxMHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxuICBjb2xvcjogIzY2NjtcXG4gIGhlaWdodDogMzVweDtcXG59XFxuQG1lZGlhIChtaW4taGVpZ2h0OiAzMDBweCkge1xcbiAgLmFjdGlvbi1oZWFkZXIge1xcbiAgICBoZWlnaHQ6IDUwcHg7XFxuICB9XFxufVxcbi5hcHAuZGFyayAuYWN0aW9uLWhlYWRlciB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzNhM2EzYTtcXG59XFxuLnRpdGxlIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZm9udC1zaXplOiAxOHB4O1xcbiAgY29sb3I6ICMzYmE3NzY7XFxufVxcbi5idXR0b24ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDAgMTBweDtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXM7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgb3BhY2l0eTogMC44O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuLmJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbn1cXG4uYnV0dG9uOm5vdCguZGlzYWJsZWQpOmhvdmVyIHtcXG4gIG9wYWNpdHk6IDE7XFxuICBjb2xvcjogIzNiYTc3NjtcXG59XFxuLmJ1dHRvbi5kaXNhYmxlZCB7XFxuICBvcGFjaXR5OiAwLjQ1O1xcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG59XFxuLmJ1dHRvbiBzcGFuIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiA4MjBweCkge1xcbiAgLmJ1dHRvbiBzcGFuIHtcXG4gICAgZGlzcGxheTogaW5saW5lO1xcbiAgfVxcbn1cXG4ubWF0ZXJpYWwtaWNvbnMge1xcbiAgZm9udC1zaXplOiAxOHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiA4MjBweCkge1xcbiAgLm1hdGVyaWFsLWljb25zIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICB9XFxufVxcbi5zZWFyY2gge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBmbGV4OiAxO1xcbn1cXG4uc2VhcmNoIGlucHV0IHtcXG4gIGZsZXg6IDE7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlcjogMDtcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxuICBmb250LXNpemU6IGluaGVyaXQ7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIG91dGxpbmU6IDA7XFxuICB0cmFuc2l0aW9uOiBjb2xvciAwLjI1cztcXG59XFxuLnNlYXJjaCBpbnB1dDpmb2N1cyB7XFxuICBjb2xvcjogIzNiYTc3NjtcXG59XFxuLnNlYXJjaCBpbnB1dDo6cGxhY2Vob2xkZXIge1xcbiAgb3BhY2l0eTogMC44O1xcbn1cXG4uc2VhcmNoIGlucHV0LmludmFsaWQge1xcbiAgY29sb3I6ICM0ZDBhMDk7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtZmEzNmI0NGVcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zdHlsdXMtbG9hZGVyIS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9tYXRjaFRhYi9hY3Rpb25UYWIudnVlXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjI7YmFzZTY0LGQwOUdNZ0FCQUFBQUFKQVlBQTRBQUFBQnArUUFBSSsrQUFFQWd3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHaVFiTmh5QnN6b0dZQUNGV2hFSUNvVDBjSVBYZVFFMkFpUURqUXdMalFnQUJDQUZnbndISUZ2d1VWRWpubllndjNvRDdsc2F0ZFhMVVFRYkJ3QnY5RjhERmVPWXBjREdBUXlPMTVEWi8zOU9naHBEOW1BN1FKMjVWWldJdENsVWZReDEwVFdIU3FuQ2hHSTZvVGhOWDlVMmwvTE1jSjZaRGlRdXVFUllGSVNGSUp5ZWFWRnF1NnhycmVzMjgzQlRZK2lsdDRmQndaUkRVeCtwRTMvYjdVM2Q1ZDNUTFpRdVIvbm9DL1lYQmt0OUE1cG81RUYvUFZ2eEVBLzVOSVhDdXdhaXpONkhTMytKc2V0QktzTXNDYm5Ya3YvL0dBUGF1ZSt2U2pPTjY2R0poMGdpTXR2UTZReVJJVlJDVndtWnluVG8vTy9jZnhWU2VCUnNNNzFwMG51VDl2Y1BxVkVJR2xBQ2F2WjQvQWcxZm9SZUtmZjRQZXQvMHZXZm1IUnlwanV2bzgyOW1YbTlJRlJ3d2ZwY0YxSDA4UHk1M2llSG9BWHRMdzNsWlcyZG9Eb0JYU2V5VmgzQVRtM0RmVnQrMlA5eExXTEZHbktZRjVlSk1PNzhOTTZma0pZaW1OdENsajU0ODgxdkJBL1crZFFZbCtwSzZQQTl5SituM1B3L0tDNndUOGdNRUlHRWdFanVEWnNRRjhCa2dMQWxLTnZjWVZOaDEwd1VOeEJjNnN4VEs4RmFhOXVFaWwxY3VqTHArcXExcjlpR3RxLzl6MHAza3ZZdDBTNmI4STF2c2JXcitiOWNacjl5ck1wUllKamhkb1BhaU8xQjlKUlVpYlhrVVJKZHJ0SlZlcmtKREx0c0VBU2hJUWh0VzFKbFg4SU8vTi8vY2o2K0NCdndRVFNsbnRuV2craUVvblkzcUE4dWR4RkxVNys0WGNTMm9sUFJSV3dRRFJXYjAyNVZMdVNVRmVCYVpNNFh1bWJGWWI5aDI5WUhzd0wrL2FIKzkrc05HM0hBQ3RhMWlVUHFsRlovQlIxT3BXeWdzQWVqSGdESDV6Ui9ScjdOU1A5VUJrVXVRdXdVd1hFRzdPaVQ4M2FyeTlXNlNsZkRFalJZQWxySEh3RjY2RDZkYk96dHg1enE5eVU2QVE5R0pMMEFTOFZhcllHblduN3J0K3VtOXhjcUtWdzA0amhoQ1RzNzdBM3AzeFNNc2I5dHQ0YXNLVFRLaEJEOXZudmZBZnhOWk84OUo2RHBYR2RNMG1ZRWZrazB0cFBHb1NleSt3WFNRUGZ2MWJSSzJkSTQ3Vm1kODd1ZVoxd1FyZkhaR1pkZTVFSXJmTHovVU1EREE2NEpRdHdtQkhhTm1wU3FCYlUwclZaTDFVZHg1bjhBMUtMQjFwVmNRRktjTGJuZElpbXRrVmxuS0k3VGVHcTlpUzlJck0xc2VFbDYyWVIzY1h4cGNrbDg4NitxVlVzNlBjdWJ0THVYWXJjaEZ0M2xWRjE1VFlYL0FVTDhBRCtrRC9CVEJDbklCQ2w1UkZIeUVLQW9rMVF3UlVFY21kTGVvMkRKazNTVGdqWjVVZ1pJeTB0SzlnNHAyUnRTTEJvSGVXT3E3bkozVmJWRmUwMTNSVkZlVVI2ODd4TDlodDUyOFROQTFqVFJJbTJEY3M3ZUYvS3EwRkExSWNmMFJJbklXMitmbmV4eDVjSExidHYwR3NJd3lDQld4SXFJRFNIZlBYZWppdHJZMEFOUXZjOTdjMFBUaUlpSUJCRVJFUWtoaENBMXY1OUt4U1R0dmhKeHpMckFNWEdnb3FESi9kMjdRZWI4NzRHMnRsc05DRlNRRlpiaUd1eE1FdHI3ZDhobUpTTDhiby9yc1pCU2FuZ0pFSm1Kd24vYWtubEM1aVZkcGxBNjF1M2twWUF4V1UrVTlSOHptVTkzVU4wN0Ivb2hxK21CekJEZmdkd2V0eks2NHNETDhjQjNkN2R0NmtSMERpVWFXdnkvb2laOVVEMXFHRUhKdDdqbHlxbUVjMHZZOU1pbE5jdm02VFRvdmVVWkJiOUg5YTI4bGZSRVNiSDVlSjJ4Y2FCeHFxbTFKYmJGQ0FLNnNVM0JVQVFVTUNreUFtOXhoOW52YzZkcjI2M2VrT0xkTmQ5OG9hME9RNEl1Ny9DZGJrZ3h6ZFQ1c09iTmRSL3NkOHNlV0RWaE1GRmd5aDh4ZWpoTWlXQnhNZ1VGc29rbHNiUUN5YksxTjFPNU9pM3FiTGlJR1JibXdVZ3N3d09CZ0JlSnpXTnBScHVoWlJMMHRtYm04ckEyM01jU0FLWElLSEJ5Q2VPT1d0ODBhODF0NksvdUtFZ2NDZGJ1ZmprQzFkVEtHNllWVjZvWDFTYXdkTHByTzZmT1N2bjV0ZUFjRy9aendvMUsya2hQRDUyZUJCMkNtalpIc1VrOFFYWWRkZk1ZbTA1TFVZTE00NUF3SlpKR1pTTmhxYWRid0I2Z0dlUFk3UVFuMEpEcGxpZEpiTzlIZzYyZ1JvaFI4aHhnSjFHV1psY1BYSGpMcVVDRWRBcHdhUTlTRWF1a2dmT21FaTB5SU9SNXJHS3dXWDN4RUpGS0g0cE5LdWVLZkxONHkwaXN0cXo1ck16aEIxaGtzcTU1clZ6cWc0UnV6VzlwWkxJQTdEcHFNVVdFaDhWTVFWU1RoUVhQdkk2b2JocDVQWERoTGNGVGQxcWUza3p0dFVGVjlhQ21GRmZTaENnd2VwdG9CdUloTVlMa3RwVklUMmtyZkpNa2JpcCtySUJSVkxEcXIyU05lOXNzSkR3NGNtZ0xzRWFlSlNtTlFVYnlGVmJVYmF0VVJVNnc0TUdiTGNRaUVTampNV21YY2crV1pPRjltT1o0WkVxNEdiT21jZE9iOENVYU1Sa3BuYWdsV25LWEc5TGdMdkxzQlJsUnhSV05MWGtwNHlqSlBsZnBRYWh1TWVsV2hsdFVnREdXK2x5VUpPblZFemRuU3h6ZG5oVWcrZk55QUJKMmZ6R2gxYTBrU3RobWdyNjFUczJWNnQxbHN4c3k2M1pGYWZPUUxMcjk1aU9NdnVnMnRITVFWS0JwZEQ1Q0xsZTVNSDlMUk1RK25yVm1jTXE0alBCbXc3QnB0cS9mWEVpTkJlckxoajNrYk1nVUxINzlZaFRPMmNGc0I5WEdRSWFLcW5ZbzFLaHFlc1lWclZDNkc3Y3R0OFcwVmZKeVZTQy82dG9JcXlRbzN5OW5tSEprdjZ1ZSs4OFJOd3pPUUpCQlVJaGc4ZU9jeUNFYTB0WUVrc1pHc2Ftak1xK21HNWxsUFpFNFVRWjFvNEM5MUMwRm52ZnZwVUY3Q2dLNWhXcGRtMWQ2a2p5Uk1tbUhKSGFjd0hQNmR4cWxDbE9BNThsMUhzdkluTzlJZ2tRTGlJUytpb3daZVhVeUNiYVdaUkxVSElmU09yTUR2NXFxSVBEc3NyOXNRNUhBTXdRV2JyODFYbi9wZ29vV0xFRk9xbFNmQjVBZWk1cG1RM2ZpMWZ6ZU9zalQxTXo5VHM4U1p2UUlSdWticVlvd0V1U2RMSEMxQWxCdVlZdzVlNVVlUXRjWVdmRzdjRjJ3WkN1My9zVVNWU1RaVGZtM1RkZTY0blRxakxTVVRaMm1uMDlieDU5UFU0ZWZUMTM3bjA5VnUyOWxkVjB2cUlFbldIdFg2OERQVW9oMmlkVXMrT2xHUWJVZklVVlBqRmZaajNCd3AvaGE5bjJUYmVCV0pqOWdTaStBRnE1MW9LSG83NmFFSGxVS2NTZGhldXQyQXk0UElCVHhhdXhyYWNod1hDdjdwZEVaQmRIanVaM2lidnNDRWs2cWR6bnhlU2JzZ0pRUW4rbUUrb0NrZGFYcXNncTJCaGtrcDFNT1NublhYa3VydG9oTnkyOFZuS2FTRDd3UUJvVDVwMnc5VEdJNmRkMWdrTHBWYlRXVTRKTmR6V0lYL1c0cHIzcXZTbmxqNEtCbExMbmgwSlZ0M3d4MzBKRFFjZG96R2dzcDQ3VUtON2JZODJGOFk5dVJFeDQ0aUxXZEVTZ0lVNGVDdXM0OVdtaFVjZE9GUzdBMm5nekpQRi94SnBkZXRDU1pxc1lXTko0WHRaclYzdUNERkJjNmxqckpPR1ZZWnhKWXdoWXhKVXhRTXRrbVZHZUVqZU9rb0svU3Azd2k1MFFMamw5SjNTdHFUTGI1RFNjOXBqRlYvY2JhVTdYaG9GeDA1OEpJR0ZONFprRkxEcWZhVTBqc2NWd2tlUnFEcWZwUUhTUEFRV1NNb2t6TEpIVzZWNjZTcktySUlleEhJSDBuajdKQmZUYzVrR2dCQy9hdmdGaTlDTGM0cFBjWGxHTlRkQnB4Ry9HeWFBdytKRC9UY1NOcUtoK0RneVJvRzJsa3l2UUErWkpBZmxHZm1kYTNBa2tWUXVJNG1Uc3F6ekhHZExZQlBNazh1TWdiY2l4ajZSQWlQR2U1bDBiRFJNR2pPNURVNGVnMnlRc2VvQk1QamI0SElaZ0YweFBKNG9YTGpxRnRrSnB0eDFjeHdyNEZKN2dSdUFtMUZZMjRoVTlFZGQwZ0hoa3U5M2ZMSFR6Uk1nNWR5M1VCeGpTRktGQnd4MklYWTBXVDVMU3d5UnV1blNqc25tZzZzaEZYNDRVcFJhN00yWENibWhBM0RZbjZKWE42c0twbkJEVUFSVHRuWUYwQ1RXSGJ6TmhoWk1VcHFEZUd3aFJVVzl6V3F3VTdyTzJQSW5uUEpNTmJkVnZFZUp3Q1FyQ0R4dHlBalVSUU1VV3dLelpZRVR2bVlMOVMxd05OZVJBSFdBT0FURmxWNC9vTGp3U2dZOU9qZkpRU2tPVWU3RElNeUllWDBCQVVzNzlJWnVOZ3Y3R283QXZ5MjVVUUQzYU80cWd4TW5JaTJCTUNleVI2emQ1WkNpbGt6c0s5a1lIWlR3MUZJcjN0MmtIVnlNMnZyUmkrRVoxYkIyMmhHQk5PM09PREJreStQYnpPUjhOdmhyY09HdStSelRkcmZxcUJpQUxHOEY0MW5yTHFJUWFTb0dWZEJ2ZENFcUh1YldsV3VBMzdKMVZHc3E0OE85TUxSVTNwb2xZM1NMak41NW9Xb1VWQW13VDJ3SFRyMUtxZytSd2I5S1VPN2ZqNXVjQ3UyN01IYUJpSS9HSTIxdERmWXNmVlIwRkI1WlNMNXE1Vk5BWU9XTnJpNis5anNGb2xONnRyRVhmM3BwMzcwSkdic2lRSjhva3RCNWU3eHQzdXR5c0lNcHZQL0FJa0ZxOFl6NjUra0ptMW9tMUFtRXp4TTJST3ArOFI0dmxnbHRVaHJYMlRiVklkMGRTYUR3UFJxb3FuaFlrUU5kS3V5Z3dxb3JrY3kvYzFtQmlRdHRFMlhyYnd2aEU4S2ZiekNjTGMwdW8rcFpMdGx4MEJyTmZXL0NBeUMxZ2RGQjZLU1UwUFJWWVFhenVERGxwQUZabXR2SnpNOXlVQWkrbE1MK0RMSWhVWTVIUGFjQ0doSmVVYmgvTVZaaFJ4dHlQSmJmY3RVeEt6ZXhzMVJxTmdJMnUrZDcyczZDTzZPTzNqUVFZVkNaVEZmdDQ5RUJkSkJ3a3hpMkRKNndsMlhLK2dNVGtya0MxdmNZWmdXOTA4VWpVOTNDN3dzTVFtRzRkSW44YXl5SXZ2aUxoRzlnVkE5V0NScExZTlRvdXpFUnI3OWxNcjBqRzRQRUp5ZDlkbzNZRjhleExMYitlc1Z6d1p2d1g1am5aQUtvOWVndXpPWG1jQk81aW84cVAyT202K2I1WlJ2RzZYL05XQ3FobHZkMS80VXVZazMzOWV2UGJtTTU3SU9LblI1RDV0U2xHNC9CQVRpU1pFd1lpeUZOMXlERThKN3c5clV2QlhyNXBNaUFQNzNNcVc0cytiT3VibTFrcjU0dlNia21wWCtGNDYzeHBCaVMxbm9GNDVKV0tXSjJJdElEVnB2V09RaEptTStvR2N3cnlzbG1CR253dmNMTmdlQUZJQWJYN1hYQkF2M2tqZFVwbytjV2tlbUs2RldDcVlFOWlsTWFkaFF1SENyaHVYSnV2eEVmbGhtcTdGSmlBcjRiaytnUGQwRzd5OUNJQkhmVGVzV0x3ZmJEUzc3Vm4wT3pHUkV6UHBiOTVVNDZIVXAzY055OTFOZ3VKM1R1K3BYSS90Rjd0dmJQcHNuMjI2NlZLMnpCZVhub1ZlOVpSWlltZGRPZU9wTGM1NTVZNE5qb29rWFc2RTZPQUY0WDFOS1ZYaU90Zk5EbkdubEYrS1d1TXJLVngya09mOVp4NzNyYmlwZHFxMTJIdHROMnpHcWdWWEdHeSt0MW5tWDJJbGJvOVRqS0Fib09sazdCdGZNUE8zbEFCUktYZENoQUdQQXJDNk5aR2UxT3Y2U3dUK2p4VGZLdnpLRU5BeHJHQVlEdFNHVmdNZEdRWHMwTnhBSWI2dVgxYXFRdk5wRE5XQTErWjNHRUFxcTVleTdReEdTeE84b2JWOHFNaUFwQUdDWnRsdk1WcTJndVNtWVl0RWVHU3FnMGpldXJRL3lia1VNYW5zM3doRmFoTkE2RW5NL3BCSU0vT2dZRlRHaERsMVR0R2dGdFArY1ZvaHFDaXlMUjhvcFRhT2I2Q0lBZWNiOUw4Y2NpeURHRTllTEkwZEpDNWM4U0tUa3FyR0xYNlFFTlJFV2Q4eVpyRFZHUUtmcTlmZDJGbWJ4TlhNbUZSVmNnaGV1T3F4U2lDVHNEb1hXMW9SNEpuTHdtNlAwdkgxS3NJaEtFSHYzcENnSmJpMDJFZ2tQYVlkR3o4L3pxakZVY2ZjemFFekJJYXlCZmtLKzAwVUZ1aWZDeWtFUGJTSlptNUlwRkw4V2dXZ0gxd1pkSXV4MSswcWx2NFhNNVhPSTV1Z0kvSFF2QmhCVDFrdVlZZTk0ajhRTVZicklDeVQ4SmxOUGxuNEs1N2tiV1FmaFpUMlNiV3JhbTZITW94T3pNKzlCS05qSUFXZWMxdUdxWkZIOHNOQnZqS0lFbVZYeE9KNjRyK0VYRVRxaXFhZUxNTEh0Q2xCUWdDVUV3akVPa2p2bEg0QU5kN25XNFhtRnFwdXdGdEx1Y2cvcmw2b2xaNTdodGlXbG1xbzIzdGFtaG5TNXllSVZlUDZQUFVOVzYzdVFYRlFxTzF0WEVxUmxXMnprTS9GbW1aOC9HeDEwMysycW1reGE0MnVoNlVXODgwUHgvc2RrcDU5clhlV3pYT0w3WnI3c1hXN0EvcEtPVmx6M0dLYlpyc1ZyVCtJT3M5cUpqeDRWc0VHZW5aMnYrQ0RGdTBQUzlxZnVWYXFpUzIwRmpyQ2RPWDNzNlZ1KzBGby8vSm9IVXNwMDEyNXVkYmI3N3o3WHZwWkM2blRaU2phSzlOU0pDNVVNVFNSMkRrSkRVbVN2WjZoQ05vTU8rbWhNTTZSc0dDSzYvV1VVK0FCeW0zbFpjaHI1V3UwQWRrdVJZaWhkUjhWNlpvdGVIWWJFZUdXOXlvaWh4a2Q3amlUa1RRMGNCVWdmNnNoRThDaU5HRlg2MkdjT1ZpUEg4Qm96d3U0VVBsRXVGZkJKVUZZMkZobE5tdm9hYXFOVG5yc2Exdkl2V0YydkVydzBRUXJCRTNUOTVNaldJWFlLVzA5akNMRFJkS0duWnZtZlZsU0NpWUJFZnF0UmF6WmVUeHl2RE9keHVXRythSDUxNkw0TEFveTNXVE5SYmxZczFLc3hnOWlpMUVabmFtTkQrY1lxczFvU3N1U0V2eFVWVWdQU3VrTHp5Q2tiekszWDhtRjc0U2w0ckl0Y0R0VU5oV1ZtbE92aEVQayt6M3F3eG5ZWGZpcEVZdG9wOHhhcWpzTHd6MEhGd2VoalcwT3ByVE1aQ01qclhiVzY0UmVOWE5DRFh2MFdMRUdCVFhMaWlkZzdTV3pTZFlFa3hQdlkwa1F5cVdJU052NkJMb2ZpZDVrV1RjNkVvRGk2K2UwZ1JVR0w4MFhnUVBEZDdZVjRtT045OG1TY3BDTmhyMHJsK25GN3dyeHNkSW5LcDR3aUtCcWl4RHpqRmxMdG1URHdBRURnZEkvRUNMNVpwUjl1Ymh6VXhuTGFMSDBrOFY1MFc0UThTN0I0aTFoU0N1eUZnKytaOWU3REFQcGxLNytnUjd4VnE1bndPUXVRak4rV20ySElNRVlaem5kelhYUTB6RElyelRoSWJvbDdXcWhrVkNrVm9GMkdFWGhXSHEwVmhTUzZXT0p1aVRKT245eEFLVkNONzM0WXVsTWwwcGk4V0hRaW54U1E4OFVSVGxWZVRsL1ZzV2xXdFBPWHhMKzJqRUxRdEw1U3lDdVpzL1FUMHBjUlNuUUdVbWl5QjJzWGIwcm1lMms5NTFYN2RxdEc0ZnJsRTJaVVJKYXE3N0RZTDNCSnVLc3B4dEpGRlZiTjBVMFVHS0dKVHYyMHhvMlplVE5sRWVPWGpXSDlPcU5RbGhoSWZHMU1ZTW1xbjJFSlBFbWwzWlcrZEZrYTVsMGJLaTFLQU0vdC9XclNWV3A5eFhabVhWQ0xYYS9Ja0c3UUdBZzh3OUlVcmdPSTR3ZWVZeU5nZVF2cUx0UFFKTGZ3aEdzRCtMQTZubUNvdEdiK2I3ZjYyU0ZyYWViYTg2ZW1zNEVzb215SzZCWVB4N2VoaStWVnlXdi85cERLWlJtMGRsU0NxaVJJSlVXcFZvck5XUjNxd2JMQUNjbGJnVklkbldlYTFBcGtxS3U5amVrNytJaTQ1cU1QbkdhSUllOWc2eXpGa1Qzc2d0OC9reVJoTVZFcnNEQ1puQkF2R0FiZ2x6ZjMvQlFqS05YTmxnelo1QjZNbHBEenkwTjM3NFVrYnlmVEtPK2srSnkrT1BjL3VGSzFxMjBvUHN4djIrVUpadmdKUVhRanR3YXl6U0xFNnlpdFRCODdDd2JpeXVMK1dXSHowVmo4dlZCek5oNlBaVHVzbXdNWFVNZENScFMrUHQ4cmJGOHBEelFzTzYvV055cTBHc2NrdS9FWjlpOC9JTXpLUWlBVVBaekpZQ3d2V3NEYUR6WWVXRitWa0thZEZuS2VkV2lrTktjYms3UjdhSmJKUU1wSEhOSURnM1BZbjV5N3BveDR4OEw1VkFma0l1VlhqMEsvSjQ4TFFhQjdjaXVOREFYejArTnBDT21WRzBJUWZub1Y4VkprK09KWXowaTZ1cUE3VDlxUmlQWG9VOXpQTXd5clk2dzJ6SEZtcC8ySHdSb3BIMFFJSG5pbnZqMU8rVWZUZ0R0U0xOY25EZ1FjMStCdzNZaU8yRDJwTEhyeUtTNGxDbEQ1MTBFcjdrUzFuVGdIVEV0M0xRZmZtYmJ2cTNOT2lEZWxWRzdQYUZXdlJ2d1RaQW9WWC9lNUFnSEpZTnMvbFNIWVV3bFFudC9ZTXJzcXlDblpYSTNvZk04MVc2b2JFN1hmSXFCOEc2cE1JRUZ2amNhUkdRWm5VMjEzVTFmczVrcjRUTEp1SzlBZjFtN0dJT2RaNWgxUll2K2NyUHU2TjZHNWw1a3VkVzJMci8zRGRVVm9DWEhFeUs3cEdGOFJNSHZEeHRCdDJwUE9weWtNNWlvejFDQ210R3dHRFZEQThIU0NVMHlMZTVtaHFHNWo4RnlrTVhUcmFXMnU2UDRpZmVGVEkzelNJdjJKeU1WNXBvMGk0TjFrcWErMis0T1V2VDUzcFhhaUpHaGd4QTEvYVZqUWdvc1dVczkyZUs2OUVhSGl4Sm9ZQ3FrWlNCWTlBczhrcG9IZVY2UkJ4VEFMa2pyQUMwYVArekRYR29mNWk5a0NJbnhjbWQvOEFORmpaVkQyYmRVTGw5bllVQThsSW5UNGFzdVNScUxqTERaNHJDTTBkNUpzTkZzMTd6czJzZHd6ckxMQkNMRnZRZjN3OVVXMU10U2M5T0xDOHVBY1B0MFk3UFpRTG4xTG5xYkFPbkxLbG1mOWEyZGFGUXlDdmFjZVJuVXNSVWZvV1pCZnNzOHA2akVGRWJtK2hQUUd4Q2xuYVlzdFI4WnNIRkw3VStLZ0QyMDlBSEVLL2FkRkxYclJzbFh0OEZhcmp3WXk4TFRTOVljR1J3OXF2c2NMMGtLUGI3VkhZQ09pV3FwYi81c0NEcjFsVktTUnlXSnBxVWMxM0hjNDhZVjNKQTY0WXBSQTQwZ2JKSFZZQW9XSnk5bGFRa3ZNQy9HWmlkQ1dUNDVubVF3c3FadlFFQVFHWG9VRTBiem1COEZOZEJGdWovR1VJTzRPclVqNFB3ak1WekhGekZpL2tpblFoaEt2NzJ6VnRIVzBQMEptOHNTcFZud3NXNENhUjAzRWdnSDRodDBBUEd4V3RoRFRPSmFJK2hjQ29iNVExR2FuUEFkN0pHY0JySHJMUXhXV2RWQzgycnpkRTJqQW9kOXVIckQxM2o5T2RheHg2eHRzV1RwMDFBMjFSUllWdTNUZXFXZFkwWk43SnFkWnp2aDhRQnFaVFBDZ0lRUjJZdE50ZVpQL1N6UHhscmwycENtM3FRYTdabzBwVDdDcHFpaFZ2cHEwR0g3UDNJWU1XM0o3QXN2TjdMaDFQdWFneDk2Y2RiblViS0dYWTJHT0p5ZXpreUMzcGhYWnhVdExqQ0FIZnZiV0k5b1NiaHNVRXl3R1ljS0ZML2FCNURtZUlBc0JOcWxZdkZnSzFUb050SncxUWJtb3VQVGFLd0VBa0xvdnZFS0xET0NzR0R5bjVTRmxqLzRPcFkxcHJKMHJteFNtYnNMZ2k0NFVJTkpmdUdjd0FUSW83OVRkUzRtNjdqaVlpeEh4cVlXYk93NXVYSEsvS09HbzNvYWUwbWVHOVNTSXVER3hsNjVRRnZRV1kyeUFUMUI0NHdlR1hUZW00STg5YWlEajlJZ2ZlYXl5dHJCdlRYWDJSeXhZUlNGVHEwQnkxV2J0L3B3RGlhZmI0aU9YM1V3ZTJ3TUZDK2ZhRDdEUFZXM0lWMHpZcElyVlQrVE1QcFNRck5hZHVrc09pMEU2Y3NKbGdPcHhyVnUwQnVCWjJMSVlEUVdSME1EdVBCVGdaK2xrVU1EVlZxZE9INzFnV0lvUDl3aHBkTXpNT08ybzdQUU1RaU5abUs1T21DN2loOUo1dnYvMGxyTEdWbWxvSDNpT3RVS0RFTlo2NXc3SzBVLzZQQ2FYNWZqVjNLYXd4WmU0bnJ6MS9ZcUdndlg5b0pjTmpSV1hObGdUWm1sWU0vSUE3YXdLdzZxMXVucnVXVmhNVnF0RGJ2c2hRUnRtT3k3RHZBcDlncGdVdjBGbVRRUzFaL3ZWVzNESnk0UFZKSVMxbVNUSzJjdnc2T011NlNnQ3JtVE9nZDN4Ylpad21pNE9wcDluSE02RnNzTjkrQ2dBdll5VndjN2x3ZVRiMmErQUNiRFJiTlJIVnlsYTBobWVSNTV1bUx4MmFsNUdob0Y2RTRjTzhNL3Jia085dmlEdXpVeEhUbzVHWlJXbERudmpUMUJWQ2xaUnREcGQ0WUZXTU5lUU1WRGNGbmFNSGhWdTFjT3p4U3BEZkhMdWR5OXpyQ0cxNCtFMVRleEZLeVg0YncweUlya2krRm5zN0JYVWxJTE5paDJlZ2RvbzZCSXlCS25wenB2SS8xTlZVRWpNOVo1M1ZZdHBSNm9KMHA3MDErZ3FMN3AxNDRSb1d6c05TNkV2RkNlL0pnZkV5dGh6TzY2a0ZWZkVlYmJTTGFDL2xhNjdIdEQwVFdPMkw5c2tKeDd2YmJaaFM2TlVObUZyNXZwWjFsb3BkMW1MTnNpUUsvbmZBRm5QT3RsYllvVytDWWdpQmtqbFd4ZnFrb0phRGU5b1FpVWY3ZUgzV2d2VXU1NHI5d2tYR3J1SUlCZFA2V3pDZFFJOU9JRzFwZFBCQ2JDM2laZVhheVZVMVR6Y3BsQmhlU1Z2dXY0K2dpcmxuc3oyUHVBb2pDMWdpUnM0c3R6YnNTMWhsYngrMnFodzhDQS9sUzVwYlZKTVV2dE9nYmp1SFhyTEhSbkRxWTdqRU4wT0hGMGMva29XYVN5MDdBYUdqTWU1Y04wUk51aFBMaCtWcXVWWGwwVmR1ZGZQS3BjYVcyUGpCbHB4NkZabnlja3BMcm9kOFc2UkcvaDRSUXdJdDRIRlh4ek9Dc1g3b2hRdkNsby9SdjRlS3NOYnZHRFpFenZJTklRNU5VQk1OVnZocUdtbFdjYnVtNWZEOTJhRnZhUnBiYzcyempiNVh4NTQ4TWlYYlpmMGtwN3JUV2JkUHBJblVBL2cvN05Gbi9td2VDdk8yNTRIQ2ZiR1gybUhaZ3c1SFpEU1BOTE41OURPWHQzTTRqOU9JOXJQMHA2S2hnbC96Z0ZJMXFhczJQMTdlWmRiY2FtdHozaWVXOTV1ZGQvYjgvN1N1LzFvcmZkZHRoWjExMzBxamUrdDhPWHVNWjlMcmpoYTJjLzhxWHYvZXE3Zi93WFB2bjlMLy9HLy9leCtQT0VZcFJEOFJSWUpoN0paaDVzQWRmWHVQVzlQV0JDSTBLRzNqVXZhdFEySmcwSFIxb2JyN1RZY3lhM3Y5SFdQclJFSjlCNjNuRU1odjE1c0plcTZCdmZTWEdvUklLeG93L0hLM1NjQ2dHMHQ1SlBTTzZSME1YWWMzMU0yMGFGYUNzdFViWi8yZnVSR1UwdmpEejk0dmVidGs1WVdZUXV6WmQrWVFZVnlIZHlYb1piMnZFMEZhWWR4NFhlT3dyUGlWaXBzM2hpemxRRWFiQmwvM1BYVmlUYU9kZlhPRERLbEZzeHlYN0RhY1pIYkh4bUMrN2ZCOVRkRUQvNzdYeVY0MkVwQTNLYm85MFlwTUNsdkVWZE92VVdvc0hlakVwclUvVkVvQTdlRE1hWGNtZkZtWDVTalhyNklmaXA5aTlHYS94Zmw1N21HQjlTTlFjMjZwbStrMHVtaVJHVHh3RXQvRXVkbUlrTDZEZWpoUHRsWWRIeXhCb0xFZGZtQWE4aHpMNHRrbXVkZXhLOWV1SWtjbXM4STRuWVI5M0xQNzBYZXhLVjQrcWo5b2xVYjFKNzh0SkYwSjNsRmpyL3dVQUVVVk5yTW5qNzBnWWxiWkNxdWJnOEp2SXVBaDNPZExVN2ZDcUNLWFlwbnhDYUFOMk5pdkN6YkoxVDlybkRoTmNqVWxDT2ZNQ2puL0FnNlZhcnl3dDAvTlFIQXBLZ24rb1FzS3daWDdjZktTREhNNnhZbEpYU2w4ZUVrR1RSRmpWQmozeEJXRUFmUCtnZXpzQks2d2ZpSkZMK3dtazJuSlduMkFiQ0l4aHAxaTFKWTkwVE4rSHVHcFY1Qml2TGwyTzB5by9GcnpTbG5QU2p1bkk0YlRKV25FNk5jaSs4ajBXaExOaTZIVnVYVGxtTlRIY3ltdG04VllMbVRIMmdraVdnSy9RQXQ3U1FWdDNtVWtUU0pyRGVBUmdUV0ozdFVnZkhPNXdsUzU2cmRzZmhPb1JGdGh5OGsrSllacXpSVWNCaFRTbnNvTDRtcXFzbzhTZnJvcVM1SWRPZ3F3VTZBV3htZWZjbW9lcW52c1IzdGJxTm9YVmd1TmpmeWRudzdSQnllVXpOeDNBdjJSb1pWMEVGeUZscWxJL0VTTG5XYnRZY0J0cGhRbzA1L29Tc1picVdXZGlYQkhYNHcyTlpOWjRGMld0QTNNdmlldzBWZ1NZSjI0VlFWQmlpUE1RUDNzcXg0Rk5FWjI1cWJiaFJFTXdJKy94bW1YV3Fxd0RqUHpPdzN4NERLdUpPZDM5K1pNUEMwY01sUkJ1OXVkK0xUWVQ2cWl2OWhqSGtPL1N5clh3b05JSnYxOVcrVmJzMW1jRTZhVVlnWExGNjlsTWJhK2h0dXFyYTh6RGEzaHRiV2JoNVNGT29kVEtNazNDWTE1czI5ektEcmFoOHpidU14bENEUlpUK3dRdUVSYlNudTZBTFA4L0Z5OTZ3d2VYNGNCN0hCTTZKYkhITEtkQU1LNWE0ZWlsK1RaU3ltQldlS2dDTVdoUDdqWmQ3cXg0VjRLSzh0U0doTmNhTjBCZ2NSNDFDT3d5OEwxM0krOWFDOHk2ajN6S0h5K05VNTVFaWE1aGFJK3hVb1BhRFBNcSs4NEo1NmhOS1FuaGU1L2hhcHNPVGVCb2pyVkphOUROdDZKbU9KS3RHVmFnWWJQMUhuMlRSM0lPZ0IyQmVJOHhmamM3ZHBSNVRGaDBnY1o3M2RJYWJFZlo0UXFGa3dwU25ua2Q1Y040bG9XcU9VeFdUTW1uRFdGVm5FdWR2c0pRMHEwMzFFTkVta0dqOWs5K0hFNGQ2b3BTTTZ2bUZ0aWZIMHZOSzRBMDY2RnowODl4cVYwOWhTVUgydVhsMmc2bzlOUEZ3cnFMVlYrV2M5ZkxVeVhweG9qS3dXWit0WkJITGpUR3FDZlhidzhxeVdKK0VLWGRCTFY2ZG4wR1FRbjdhU0YvTG5mWThCZ29vcFhEUTVldm1yYXltNmVtWE12L3dwbFBYREsweFRkMTcwaHB4dmRCTE9lZWhheDd0SmgyTjd1WTZSVHNXMXpqdHJxaWx1d09BWVdoaWZlSjI5SmlDOVJzd2d1cUNvT3FLaTkwd1dScE1jR0VkUzcyREQ4WHhpcitTeXBLZXdQejc2NHZpNlNMMzhSZVVBc1BvcVEwZm5vK29EdlFOUmhueXJaYXF4MktGWFRYQzVob0xBVG1SK0Z5aXRSU1dwTnhvUVBVTUQ4d0Q5dnEzRFpLN0FKOHZrK2I3MHdOSXpwU2JVL1Ixc0dGQVZTeDdWbEl1aUMybklQQWtpOFpzazFzNE1CSmFTNkZYV3VPUFA3OWs1bE0xdWc1UXlZSWxPejlXRjRmZDNRWTFXVDNRQ3prR3dRVi9BcUNPWUovaU1CK2FpV2hUcDZBVXE3QVlralo5QVZEYllQV28zUWd1OEFNaXpHbXZycG5yQyt3eDZGMllTNEVtWVhEcXZoZE9RTklvelhJSUlqYmpwM3RldlovdElWM21NdktXcWRrOFkzL2g0TGdGaXJDSzAyOFN1cnNYaEQvd2ZCYk5BUjVOWlhqaE4yVmlldHB0T1lFdkdnSk1veGg1SHVpZTlINW1vd1A3a1pMVk41SklBTzMrR1gvYWJTZUthWU05VnY1eHdja3dmZDV5S0l6TkU1OGtPbzEzclNSTkw1R09hSWttWHJNeEszNjdaTGV0Y2M4QWppYmhHTTJleFUxd2FQQ3NtZzZxaGFOUkkxanFrSnBjVnlpRzhFeDA1Nk90YlFhaEZlc0NKblZqWjFhU2Vjb2RTREZMRjNFTFIzZVAybkN4MWliUHNZRHdZcXg3N0xwVjY4RmVVUzNyUUh1M1FjY0lmSFF6R3RjM2tQOEtKdXZiRU9DTC94N3kvMXdjQjB4MTRQZWZyV2QwL0VQNGY3ZlkvK0dmZWVLNlh6T3JMdmVYKzVLLzBiOGgzOU5mMHRkK3dBODBtajlDcHkxc0pYOEFOUWhYdlBIRFFBUXhsTktNdytTcDFGeXJxWFowcW5uMVUyWEhlY2QxeHlOSGJXM3pQbDE3b1k3TVRHUnE2dDdYcXlaMElqZTFmUEU2N3IzbnVtZjlYcjJFN1A1bHNmM2NhKzhWdUZ6N0JZVC9JRllEdnZsazNQQWxpRkJNeEdGbkd6bktOV2RyYmpqU2ErYW9XTDh3Vnh6M0hUVzFBWDI0YTNWRVdtNVpsbFBkcDI4MEU3NGhHN09ubnZQdjQzcGFMOTYvWlB6RmZFc2Q0SDRIcitBai8wajlseWtYeFAvL2N4UkVoalFwNHJvbmRVL29IdGM5NXZWNzNJdTdjQ2Z1d0R3dlA1eHd3QTRsYnJ3ZTlQelgxTzNaMXROL1dxWTUvQk1PaDRQaFFOanZUL29wMytNZTZzKzZiMjZrNndEWElsZXJ1K0l1dTB2dW9ydmd6bXYreko2TzY2RWY4bkh0QjYvL0t2QzBtNy9POXdDR0V5UkZNeXk0L3YrQ0ovR254V2UxNlhwN1lnQTMrakFoeFRRdlIrdHg5czd1SDMwR2szR2ZBRHowQytDeFh3UGZmd2wwL2V3ZFVPcmZBZHI4OTJoNWJva3BZYVdpRUt1alFyRnQ1VW9WUU13eGs2L3dSbFhGK1dCU3lWVlF5bXZPSVp2dlRRU0JDUjk0MDNNV2dGVEVpd095OGNHQmU2YUh5SDV5UVVMa2lieGh5ekZEamZkNFF6OFE0ZUtCOVFBd1VhQ1JvaEtiUm54Z2dkZ0NZVkdVNGZ6c202WVNyVStEL09Jdm16Z1ZraVI2NFBDdENmSUlzeUl2MUlDZ1ZvUXBING9sb0Q5SG9BdWFRODAyMXc5cjRMNTRqUUVidjF4RGZxQXVyRzRSYTVEV3ZyUCtPK01wTElBd0tVMWZVeEJ3OFlINlZTdHQ1WWJFUjdFUHRHK05ORHlTc1J3ZkdMMm9HVVNJSVdTbVVXbE83UmNucm1HUUNXWWpNMkRBNkVJSEFXL2IyVnlTMnlQSjRjSEhaY3JGRHhabEhWVldRL01XNm9ROGNCUk5vK2oxVC9TS3NmaFlDeXFBbmdwbFB4bWhwQUs4S1YrWkVDaGg2VS9tNkEzYTZMU1VVcnJ3eG8wRkdQMXBDM3oxNVhwTUQ3SDR6aHhGaU9aM3hNQ0FZeW9WSXprWW1MaGY3REp1NXBwOEVIbjV1TDhDajJETkdhZ3IrcVJmcm9aOFlMWElDc2JOUW55cDU3ZlNSUWI5eHdtKzA2d3NBcWZFMXJkOWlLb2tBaEQ0Q3BsSmRMOGY0TjFJOEp0QlB4MGcrVEJsMmUydU9RUHdTQy9lL0Y1TG56RTgxalU4VG42VFhUMHFFTFgyZ0pIWktDUlN1a1VTL3Y0YXRRUFNsaFpRYThua1VRcWtSQ1ArZ0FLaHFob3A2Z2dabHNMTk1TQm9IaTBwcFpuR2gyVTQvc0gvZjFiYi91T1ZQU3dESE1Wb3ovZHJaU2w4QU9oQnNaZDR4Qk56ZEhtSExQcXBsRnI2d1Q1Q2IwRHZ1WHQ1Zmh4MWFpa3l2QWlKdUFjK0txU2xvVzI2amtrVVRmMWFDUGRNbE9TVTRhdjFDMUV6di9HVWp1YTJBcTNVZjVVV0NySjdZS1h5bEZvTkNUVlF6QnAzY3pBZ2lWVlJDUm1BcGlhNUJMRzhPOE13R21TZUdTbDFFRm1xb2Nqd053cUZ4ZWJkckJNbm9ENDBwUjdZRG5rQ1hpSzFLMUZiVXE0ZEhRU2hRMGVialZBRDZNU2VNbmhKcVRMelE4ZGlnSzlRMytyd2VlaUxMM241VzFybUw5cjV5eklpa2pOSFJncFgwaFVuZlp3RGpRWGczTXcvS0VWQ2xKWDZoQU1COU5RWFJwdE1nc2hSNlMwWDlPUEhGSXJhZklkei8yTGZaWHZaNVhNWU1EeTZzVEUveW1CU1VXWndNQXJKQjBHR2YrWDJvaVBzVmhWTHdZa0xOWndCVlcvbjRBZkl5aEFvaU5PZVJ2cUkwUnJzMUQ1REo2UVdWYXBCWUNLRG1RejVGWlltRXZoNzl4YjZSUk1TY1pDcFVYMXFVVXpISG91TkNDaTh6OS9Gc2w4REtYcHZKMlVydWFqQUxVanRMbmhERmY2U3BDcm1jalBPYkQzMVNUN0puU0RlNnNLRDhYMUU5clFHcE5SeUlyekFzN2gvZW96S3RIb202cFhZWERQUjZ2YUp4aHNxaUYzS1l2V2lpRWhVSXBVN1BIZktIc3MySGNKUi9RbXd4WWlLMWJJZ0EzM3NydzV3dU1panBaeEpxWEVkbnpybnlrcHp1cUFJQ242YWErMEF5YU1vUy9KYmYvY2VwbXU0dDloaUJCYm5rUHRqWFB1bWw5R3h5VG1ITkZ1ZHczTmtULzJobW9OS2F4NzBXRWE3d0dvWHg1VklJMHk3dFFISG9oRXpyRFoyLzczOCtabFdrTVBJR2ZVSVU3Mkk5YmNJSE5JbDdkelRsMEJ5bEJyTVpaMENyK3dIcHdlS042RE9UUVpiZlpXT2p0ZC9JZDN5YTBkb1U0RzJ4WnZlblZmSkluTW1QbWhQSERZaS8rSTJtanRMMDFkbTRpczk1UEZWUndwVGN6c0E2dERtMjJKL1NyazlMUkI5TXcwSkhTVTJsWFkyVFJuMXBEZHF3b1ZsNWFCVFdxM2YzZHViV1ZOU3FqNmR1dzFLaks5dzlRMUlJZDRxdGFnMmtHNU1ZenBNMnBiN1MzTFZjWHBpbmZKWnBLZU81MnZoT2YrZ3locG5XdGZUeFZoWkMzRldMcUpKQUtndm4rcVFpaEpiTkp3Vy9EaThYbHpBTTNGSmpDbzhTOTZWOVNpMWFOT0xMRTJ3MndOQjZpeUY3MlNZT3JSMEswTjZHMWFoMXZ2QWo2dnBsRW1ROXh6TWdaaUxpbjN1WjRzZ1hyWUd4L2luelpYWklYV1RRbFFtcm5lRVBnSFFScGhkaDkzOUJwMmdaQ0lBWmpBZmdxTkk5ZGgyMXJYc09aYTh3QStYZFUzSmhDZm1EQnhOVWkxQjM5QzJnc0ZrVnFRZlZrbm42ems4NDdhdlVOa1AzaUZVQWtzczdaTVAzZzEyV1hKdVAzZ0tKelhMTEhYTnE3SnlSdjJxKy83UTF1UWxVZWVidHBtOGwxbjNBcHYyRUlSL0lrMzkwNGpmVDQya3ZOWDhCQ1BvQTBRM3FaOXV3QW5wUTBoMjBadEoydlRISDZFTEcva2FhTUtDTVBNZS91YUxxMEhmQmxNUmtoZkxRaE1HVUtYZ1AycGlxRm1MMHRTRGtiTzZKVFhOMmRRaXFjQzFOSXZGTXVYQStNSDF5cHpldDJlNjlGdlNkU25Ma2hkckVZQS9ROENLU3FTWjRXdnAwTm5oaHZwaDRvSUhYd240dkRlNTVBMGJ2UDBZTHUyQU1MU2tUTWh4Wk53Z2hNbUFCSXJPL2ljM3R6S25zTG5MN2NMSnJHLzlTY1pBQW5nU1ZmSytBeXpvS0JFZlcwWmIwTEFFbGZ3cWxxa2JBNS9sTU9KaDVDVGZ1cjdsT1lHZHVZZjJnZE8xZU82S0hVYUtQR0VnZERYK1BDOWtERFcxZDhIYzVjaUtLMEE3dkkxTkxBT2NLZzhZK2tUckVKWHRZVEVVaGJ3VzdtVVg0YWxLMEZpbXBGL1FwRUNxRkJSSXdCQ2kwaVMxVktpaDdoR1prMjk4U1ZhV2dRNldPNFNoMDBYK2MvdEF0NUxhajliOWxDN3Q5T3NVNmJDTFhYcHJmRk41YS9nNVpCMlVJVjM5ZXNIYXh0eWJ4Lzh4NEJ2SWNIa2pWV0FhdXBzSzVDbmQyT0dDS3RnZjZraHQvUjNwQlJZNnFHd2hLN0EwcThZd3V3VEU1d1ZxVDEzU3JHb2p5bzdiQW9iUmdsYlpvMGVJU2hrNFhvNTFoTDQzdGFjbmJ5WVNsWWFIay9wTUxWa2NsN2VrYzYwR1ZkblEvR0lLbEd4NllvNFNjSEV4WlFSSGxqQ2szRUtEcjhjL3dSNVpzWnVpSFBucGwrWWRGVEZldzd5N1l1NGFWd2tmOUV2S0Z4K3ZsNmNQUDVWQnc3T0lHaHdGU3ZOUmNFQXFuWnJtTzBWRmhsekYzWFpud20rb3FJN3NjaEJwQWhuWUlFWlJHWG9DcHFveGJEcHR1ME5DL0ZzKzRBZWk3Mi9BR0JJWS91RjI3TGJUdEZiRCtjSjV5QWJXb3crWTAwYTNXZTFmdlo0M1VFTnlxNFArUEFKMXFrWXM1b0JDSkN6MHVBTWg0WjJNaHJKVENzNDdsa2s0dGpxSG9FdVEvVEpuYU8vSkNrbXRTVDg0SjVEWnA4bVJRUmdJcDkxZWZscmpLbXVLWko0blVUeE1pTkJDMkJ2aTV5VzBibUtydjlncjZYdmdZc0VoREtmYXlKYVZwVld4V0F6TGRLUHBvSU1CSGJ6RU43VVBVN3NvWU5EdUFJekRWSEx1d2dqOTI3cUc5dFp6YU52ZXRQM0dKTnFzYTJDRWJJT3ltTWJaWW5NYTNyb3hGRmJ3SzNPV2wwN3hEUjZKWnVsMkMyd2h0bGFXckNzY0FjV0FINjI2RFBBOEZ4c2wzelpDaHQrelhjTktOOURYMGNxZG5GWnluSnFRRzNIRVFQanRyNjVoU0VLV1E4VEVEckFMZ2dlTUZ5eVRZRmM3cFNCUUVXVWlJUUY2Uk4vTXFBc2p3c3VnV3hrcE9lRXRZcmJPQ2pweUM3TGdYSXFmOVNvbmNLZmhOSElBc3ZBQ1lBUmlGeEp2cmVCNWRjeFdHRnRFcDZrMlJ4OUJoeTVrZ0U1TVFSWWl6YmY0MC9mT04ydi9HZHFGbHBwZlk5UlowSmNFWDlUL25ESkF0Sml0R1picFkrMXRRVnFrQStGSVVkemZXY0F6TXc5Syt1czdSM0dEODVtNk5CVmZuVStwb1llOVdHREE5MDU0M0JmMGFoSVV0cXVlSTYxTWJKay9yWTR0NGQ1TFcwazVRSHl1TXhDU09lV3VCTlprN0Z0VGl3V3hIVjNKeGVwaVlQQzhvMHA5NnlBemREdlpTb0Z4OWRkQlNkWVRRVjd6YXdMeGpBa1k0Z2c0MEI4aW0yVTNzcWxqL2xsaUdjb0QvZ2ZyTng0VDJoUlk3RzZLSWNFMTNCOWQraEQ0YlR5UU9CQWNEZWRtSmU3Zld5Q09VT3BXK29tRU4vZisvMzZiS0FhNld1aERENmNXY3p3T2pWR2tMQVErL0FrR0ZtTmtVd0tDOHNjeTEvZnlRUU5jbmdWejlmUjA1VjNzSys4WEY3dk4vNXJQSUJsRnJQWFFoV29FenJnNlJZSjh6UWwxdXR3R0RMVkxhdnVhZ2hBa1JmR08rZ2RyNjE3MWFCK1F5RUZxbThpU2I5M1VUcHpJS3Y2T1p0bUhaNTJGT1hNc1pvN1lzZDIzUm12RTBkSmZWTmRsMmNNTmVDcm9CckFWcm1PbVF3dHJQcUhUU0dzZnQ2NkRjNFBKZThqcWlqVEFmTkJuZUprWDIxck5LcC9YdVhOVWViNXVvYmFueUE2d0M0MjlpR2MzRHRqOTVGcHI4OVM2MWZ1ZnBlVmh5aTcvY05OcXVSMjE3a3I5Y045QXFHUSt5U3UrUGdkR0RTVHdKdU8wSzUzYk8xZE5mM2J1WmNzZnVFdlZ4S21hTVNTSGpFcUJNcTVxRFlvR3hQZGVIcEpDSlJoMm5RUEV3Q2dBYzR3cEQ5MTlRTUtpVkd4TUVKVVlHdnhiRU1HWktSenQ4Z1JQYndMdkpiMUtkcEROalRndkQwVU9aVGpwbGlSeXN4SERNUEFJOHNxVVpOSFUrZ2xPbjBrNWxydk9OakNTcG0yY3FrMzBkalhsMis2YjIyVEp6TE4yMFdtN2JWV1ZWR0h2V1l0N1diWlNzdlNocm5VV3hzS2doMC9QRlhyRzRUOTl1UytRU3A0MGJNdDFsTTJYUjBKeWFvSGNIeEt0WVRnV0s2RTRaQWxWUnE0RWxCdHh0TmQzQ1lPckJXNWk0SXhvU3hKbUZRUFpNaU5QTXJidjVOVnRYQWhzM0xOdWF0RXd6OFJTbFFYWHZKeno3TlA4SUNrMVI5YWc3Mm5ESmZZKzlveC96RGRwUHlzVlJ3dkVBNTJZc3FWOXlyV2RyTC80WWQ2djdvMHVuZkdVS3JRUFNZZ1B1aVBzZ0c5a2ZwY2NDSXIrN0hpVzc0WnpwWUVlVE4yNDExeTBwYWtyM3EvVC9NMVZ5TjFrd01CT2xCV202d3dUV010THhCa1ppbmVPVHRKQUkrZW9nb1NoZnY3azlqT2dyN1duY2txbXlaWWRmT2JZK2dhSi9uVGtmUkx2SG1lZ04xM3k5cWxVbU1CdFlhZGJYaVM4OGhXeWZ6Mi90U1duVW1DdWxPeWFKUEM4L2gxUllhLzNyUzVPeUt4Zkh5Y1VaUGlYMVNJS2JXVk5DL3paU2tUVWdjYmhXMm4wZ1Rubk1HSk1BaExNVHhwakdhak9jajN2OFpZcW9qck1FcG01NmNLcFkra0tRb1plQkxsNXltZ21mMUtBYTQ0TWVYdllYWS9RWVdRTnd5b1FNUWhTc0Z3NWtRWG9CeXR1TFN0VEl2ZGlXTVBCMEhqTks2NjVzRnhGemtyWDJQNmFlcDJyOTcxOEVQc0dxWVQ2aThHcjFPTWJtWndTdDVWZDU2Y0hFd005eTNCaW9zRTVZcmFFdmFrbkZRdXlTbitnMTN4ejNsZzdtNkRtL25CR3VCMG1nbmRDZ3U0S1prOHVsaXcxbEF1RzBJTU0xM2k0UW9tNzRISXBNcmdUQ252a1AwWVJqSVFwR3EzaVBYam10UlRteERhMFpZbEZSWHE2VE5aVTVLSzEyS0JSSmxsc0x4dExKeHZjL1g2aUNtMWtsV3dwancrQ3ZtU2R5MTZ3aCtuS2ZyREhZQ1BoQ3hsWEFacU4wQnc5d3l5dWYxNFFnODZCbmZkdEpTT2VIN05qMXlJaW9QNW1qek9RTHo2K1hkUkR4aGw4bW9HNWZ1d1M3anpvdU1lVmdBd2NQTk5UOHdYUjJ1SzFqZVFCMWpGQTdLcUdRMkNKK2U1TXljWW41VW9EMDhlL3ZhTkRDUWpPeDlmOC9BMEdlcE1KRUx1RkVmS2NPekxNOGxNdG54T0pHS1F0bGNUcVJEdllibDVLbW5SeWVZMkJIdmM4eDNuVGUwblpteUdkVTlYNUJRUE5EWTdXdnBHYXlOQUdJUzZLMDhWS1dadTdhaUhCRndJSlE3QU9vbVljV1FVZExHZmIyWUlGRHA2VXdWZ0VNZS96Q09FczNXUTdkYW5lcS9IcWdBd29GQ3ErYzlKOFFROFpjbUFlUDJFNk1yNlo1UnN2WGl3czR2OFdkdmpGNXdLRW52QjNTSnpJN1daVFQ2c0tqWS9uaG9UbXBjUGF4SmJaRm5SVTJxYnE3U1pMekZMZHhQZmk3SG5xSXRUVXpxeHpsVTRVMHRJTS9uNWp4UVBsaEhVSEt1eFV5QXNrV3IxRXJJL2gvVTVSQm9FR1hsVm5FM0hCMkVTS1BVbG9LNCs2aGNoOGRlNnFBV1QxekdtNFo4L3IrOTFYUFR2VGZWRThOOEhlVllXN1VuUEF4OVhrOFc5Yi9pbFczMWxvckltOVFXSTdNQ2V3aGdUMzdMRStQL2Q0YWttRUdZS3RWV0FqbDVRbHFNaEF3Rmg4cU00NHFicUFyQjc5aUV4VzU3RmdkdTJhZDdnb3pjdmlzYlhoTzlVSDdoVGlFOVVQY1RmUERqOEJQcTdpVVZnRndRNkU2RDlUZ2VXK2kyVzM3eDZpdXI0VHgyQnpFc0xyN1JQa01Ja1UyWlhkUHY4RnhQQ2FpbzlnUWp2TkEyM2hhaExGRGdUMEFzdERKaklZQTkwRVluUEJrRytja1FLbzNtNWxhbkt4ZndxRlY1OE9DcGM1V0RTemFHUUk1dUxrcy9BSS9FcEdhcU5DNk9IemR2SzhuZ0VtYWRpM2IxYnV4b1M4Zmw3M0VTSkNockRWSzl1a1NIWnlyOXBXWmxHQU1ic0lZQnN0WWNBQVBBUXJmcW5mTnpoeUdVTnJMK2ZORXhLMG9EMkhxaXBlek1rOFh6VXV4QkVaRFZtYmc4VUxsL3ZORTBJalBBWEZDcGtvek5UNW9oWlFjZnNwNHJKdDRXVlNFVmJRSnoySTBiTG5CR0RxZ2JLMTdFVW1GOERKNTV3NVNiWkpqT0RPTlFZS3N2Z1JDWVdHZWJwTitLalp6Q2FUTUtzVFpQTU9uQUNGN1RYelcyQVRwd2JYK3hacEQ4M3RDM0gzZ2RNbG40YVEyOVRpOTVaM3gvUHlRemJsZFl4NVlxM2J6S1VHZW5OYmZzd0piVEFVTkIrL216dmJEZHgvUG1sTGFxUzh0MVkvMzNzVHc1eHNqcXRBSzNZdzBKNFFPM210N1ZYRlRTZlNCZVRhOXZmd1grNk90ZTBFOWhNVlprbGl1Q3J6dTFwa0lKYU1pSVpadUM1eU1jbGRLTktpaklRT0IwY25kdW5MZHUxRlNBaFBwZ1pxa093aC92N0pwTWdRQk9QdGFFdy90RmdqNGlWaU1mZUl1OTg3QlZKTm1VSUVQMlFDWlhtYk1XNFl4bzVVbGpnZEtQR1h5TjFzeGl6OVVPMCtjcjQ2d1ljS0lJbnpJRldqOGMwR3hvc3g4RGJlMzRvTW5JRVFjTjRtazhSRVV6cWI0VVJIN25TTUxWMjB1elVsSUN5QnVEUEVNQ1FONkNpUCtVbDUxYWkwalgwNjJKV0M1NlJOcEVQUkYyTVNsVENVWnpWa2ttZDdJR0gwaVlTVTJjaS9ibTZTR05pcHhiMGJFQ3NuMkV1NHptMzk5OEVIWjZESTNTTFBGZklmdDdkaHNlVG1NNW5iR0xvclIwa3lZWUNZTW9xeHRoaU5JRGZvMTNiUm9wV2doTmViMW9sQkc2Nm1GK1Z0bGc1NTJrZXo2NjFWZGExOW9sQzh0Zy9CTkxHMUI4Kzh3RW5reHNPQjVRSDJabytFSlhsRUYzVnR6RE5wcHdiNXRSQVNVUFpJMXJmaVBNVXVFbjRhdVRwSTBwaFYza2JWQ053aXZiMVZ2N00wK3NXeGxUSTM5SnRpRXdZVzVYcGIyK1F3L00vUFc4eXdBYmFSd3NTSnMyL1dWcnRGUG5NK3dWeFRZcW1aempRcXNBU1ZnNkdXcnZzQXRqTHJiNTVYZXpjTjZGbHhBeVgxZzFSSWlCaCtCVE9VRWlvckdqRGtJZWx1SU82OTE3aTNNRUZQSXFPYmxZRVd3S1VQRThOWElhRG1hVjFqQWR5QVZIbkRBNWFScmxlTzNCeG9kWWdNTmdZc3F0aStNaklqWnFhSkJIY2p3UTBCY2paaU1mTkpZTzRCNXZxek11ZXVPNnY2Z2xpUXFCeS9lQ0R4ekRXMUF1TDhqM0ZNUU5oK3A5TFVqWDByNHBpSDllMUpDbzVvTTljMTh4aVRvTVhPWFc5aXU1UkU3MmtrY3pjVUJ3SnJsVlJ1TUkxY3lhWUVMNnU0dmZpaDdxdytXUkJZaFMxN1N2RnUxbWxsWHRlQnlJR01QNFlKZzdwSC95eUh5Q3NBRTFSYWxXYWxQZEloVVR5RHpsSmJ3K3prVnEvNHBhdkxTTkMrN2JnOSs2MlZyaVM0T3JteEZyZTVnT0ZxWlc5MjJidlRIZXo0MFlja2NmbDk3SXRLaDhRUytjSXczaUM5eGMzYWhibkNNS083QmFMd0RYZENnYXV5TnZkc0U5aGU5SnY5QlozcldHYUwzcnN0bFRmbkt0NUVyeUlyN2l2TEdKRlhkWnc4TTdUZzllUjM4TlNMWWhQamk5T3lWZ2QzVGk4OVJuSzNhTVpNMms2Q2NoTlhneHhoQXZlekR1MUFKN2Vva05IdkdtdjRxR0dpN1dYSGphUVpSMFlsWHBIamQzTU1uTFdwQVAyL3ZFN2VjWWZ6YTNNekVWVWxqUXFUem1BZ29jZGRETkR5a1MzT2V6am1ndGlSclpIWG9sZ05iQTNZWk1sUkdyNFRMcVVrOHBUelUrYUJmUVRzY0ZsV25CMmlWallKSzJQQkhmTDIzTStJZ0l2QlFIUXVUT2xuWnhCOUNIZEJCMjMzeW1wdFliZUxaVG9LM2Y1R1lDdVJqZUZCNkdFZmJtVzBqVDFCdGlXdlJMaEgxMUgrN2VaU0R1SkZjZ2VaQzhZNHNNaW5UUnNwTG1xeUlYNVBVUFlINTRvN3dUd00yL0Y1UkF0MDBMdFFXUjRnZ2FKRGhPeHBmTXZGeHc2Y3lsSi90cGYrdnpHV2lCM2tmYmFqM01aS0hmMXpKdmI1ejNsWjNIZ250S1hNUjdWTkZPK0R6MHV2dm11OU03bk9zTDlaSVlsanhYS2ZkTUN5cTBQWDZrZFNiOGNVVnB3dWV1UDhkSXg5cmJ2WUcyNktqRTM1aUg2TFhXTjV1MkJLQjVDdDdRZnYyUmxPL2xaT1Q3TWZTQXh3T25SeWJ2SEZ6cXpMSmxiVDBhSHpiMjl4bEMxWTdpQXpnUHkyL1lqQ2xhYWNUc3dTbm5kbElPd0JnN056am9pZWVhclBYQjJPMk1EYlBJSFlQTUhrL0Rra2lXb2FDQitybXM3WUxQUTEyUnkrLzlMb1F2RFNNdE0yb2IyTFV4V0JCNWdpemQ4dE1HOUxHQXUwbFNxVTBMUG1VZ1VwZk50ZmhqWUlleWc1Y2dTN1pxckF5djZONDlzWjdtZ0kzbWJKYjhLYktzbmNBVVBNQWpPbFZJZEQvQWozYjhWSzJhbVBSb1plTDJDdlgrU2VuY0xUbVVrb213c3IrZDBheGF4aFZHejBwZVdteUN6ZnI2cXFyeVU5NmV0Q29iRW5IMlY0MVZhYU83VW00VVBvL0hzR3Ftdy9vZ2FGZFNHcUducU5QTk12aDgzWXhBNnhla3JXSjBwS2RWSFU1RVBCaU9CZEI2RXN0cldKTWRpejNsMnJtaVc1dFJvNDFrYlhnZUdBVDZKL0N5RWxpYkVOZ0hiVk5wMndxRGwxZ2dEVlE1Q1FZVzJVNU5DaXNRYk5ZVHF6TlAyWldOeEw1azVad2Zpd3NwdDdVQmw1NzV4QkZlYmMwWDdlV1dYVGJ4U1E4RGIzZFdDRWo1T0p4YjdPNHZBQTFzZ2ZMOVphdERWajlrcFp6TzZaQ3dUYzQzQmsrdG1zY0ZZY0phZ3dUMjJWcTJWRzByV0pIZkluQjNhS0JxMFFDLytaeVp3MTFkTUU0bkR4Vlp2ZEhFTHhYN0FaUTdLSGtBa2R6bDl4ZFMwMGRyM1RHc1pINDgyM3B1Q2J2YkZRKytLU3YzQ1NIRHUzeTlsOWp2VHdVUFc5TS83c01Yenk0dURJY1AzZDA1YStQWTArbzYvT0tsOWZIYUpzbW8rbmRVWHlIbnArZXl3R3lONnZiNzhMQ3FGOE43RG53dUpMR0pzWjdtRS9keWFTRDBhMGo4RmtUL2lDSVlNdExTeXlacXRhbE15ak1WQlp6SlkxSUNSdDE2OXV2V0M3VnVrQytqemFZeFlXcE9JdVF4YkRDdmNpb2VVUlh0QVhJeVFhU1lPcDBXaW1oaW1aZDBSSDl4UVlBNzhTNzZlTEFIeVord1FDTm5PQ05sWmdZaVVWQXNUZ1dMb0dWVWp5QnczT290RVpOTmpIQVlvRURjbldPZEN1aUUwSDdUWWJHV2x6K3pONUhxSzJvQ1dEUVFwck9HMlJXdS9WT2p0c0U0UlpMb3h4d3FhVUhWa3pNZ2RHS0tNN1Z5d040V3ZvMElucWp5R24yanRBQWs0Z3dzWmI2aWpQUjZOaTJaR3BQUmR4TGNOTjV2WVluRW5MbkFUMnZQL3RzNEtLQUZ2cU1kU1JrZnBoaEdWekNabE52NWoxSmhVL0loQ3lOdlo0V3pnVmtrVTRIa21Oa2hNeFRXdDBpTkFmNjJXd0dHYVkraEJwOEVNY3BXR3p0L2lCU0RXcnRqZkh6cXIrdW9ibUp0YTZmUXRpSThvNytnanJFdGJ1Wm04cWg5ZlpzS2NSSWx1QnM3Qk1NSHF6a3lORlM2ZUkxRmpaQkpoR25Hdy9MUHYrN1RIaGVTNEdjVk95eTNJMWVGOGlWUkV3akVuODVXUmtDRm5qYm9zMXdBQ1d2c3NxUHdVdEtvMm5hb1FHQVlwSjJLT1Q5SVpFRDVpK3NZdlRKYWJsQ0dCS21tZ01GQTRZME1YbzU0WDRISnQ5MnpFZEErc1J2L2pFM282UkpETHRrc1k5MTl2WEE5T1oyU2hUbWNvYm1EV1VIWGFwY05yNDAwRmpTVUxNWFRZZHpiQnJNQ2RSYS9LdXpXZ0dybzNCbDE1a01yZTFDYkwzY1ZCWXo5cnE1V2ZuRmozcnNzelJyamduWXMrNVYrWU9QV2FkL2pqelNmdk1QdGhUOXpYY1kvRG93MWhGczVWRDhyUG84NjdJNHlLb1g1aU9MKzQwa2poUzdUdnpQcHRuY1FIK1FDRzg3RnNFeC9DdXFxZU81aGRGbTVzL1dmZCt4RDVmM3lHeDNMRWJiU3ptVVA5TjNWREZpcy95Y3c2Mjg0Ym5GN1BYM0I2QUwyMS9iL1c1RTJ5ckJ4OGRNWjdwSjRjRzZXYTk5c1lrb3dOSy9WbE44TlhNeXF0THAzQXN5cVlzclplbzRGMldjSzl4QlpXcUJDR01ybzMvVHR1RXZxck1yYkFwaWQ0bkpwdUtRdkNSOFBZVTJSdDljVXl2UjQ0R2U4Y3lhR0UyWUE3aXd3Z25mNG9GMS9vNEJjTjY3eE1iZmExVE9Qb3lOeGdHTFB1WTV3MjNnYUhvYjdoeXVLV1ZKR29ITndFN2FoWG92eVRKSGRFZkFBeGp3VWtQKzdEaGR4aFowUDJ2NlcyVWRwSE5oQ1RlaEZnNWVPZ2NFVDVVcEZ5RWV4bll1WVJueDVaUEo5RFh3R3JrdEJVMStTUnNuSkRyL3ZIcHNmZDRFRnZZSTlHeTh2Tmk0eU1ZejBuY2JvNTcxYjlScnhmTVhkRHFZMXI1RXJzNWlTdHQxZ3lFTHFUditqcnRlaDQ1S1FQRU00YXBqRUVQYWk2d1djRUlmRmZTL25uNzd2SGtzY2FubWJ0UFFCOU9INTFRQXI3UVpTQTNhMldab3FTUWRzWW9JYTh4RllRTCtBOThNQXJncnNxZFQrKzhzbjErVWp6dkpWNFZpMklGdTluVTlNQkNKblJHbFRYc0U3M1A2cXhycm1vaDBEQmp1WjdBZGxGQjdpNkNMRG5nZVRjQTRJSS94T1FhQTgwSkpKMkhBd0I1TSs0Tk01RGdVVGdSOWo5MjNSQXpwckJKMjJLbHluNGxnU3g5OGhXTkFBcUVjQVcyWEx3TEJIc3BXRkM0RmdPN2RYWVZEaGVuOUN3akFuMlREWlpCbFBhV1lXcTJvZ0hvYWljbGQwclBsbXFyK3ljOHlaOU9JZVI4WVZIUnRPV2lXNzF5eElrU3RZMEw5aGhOdWdmdzVOaXhnUTl2eU13elM0S204akhaQkpuOEFBUjhYRXN4a2FxaGZFT0FqN3J4V2liR01CdDlBdE1EMjBHR1ZkaSttNzdYM05FVEkrSmVRK082NDdObjg0TkVheDFjY1k4ZHFGUlVEYTRSQTVldjkxQ3FHczI1Z0NzNzVmT1o5bVpYSXd0dnFweTFKNWZ0ZkczQnE0dEd6NEdHcG9wb2ZremsyK2V1WDh1VXhmdWc5OWhiVUduN3ZrdW94b2Mzc1h0NEJ1WlczdHVDL2VTRW90NEhpTGd0UlpsVFVzK0dMWXROaW5uWE43TlRmcnZZbmY1YVlCRlh6eGFqTHFjTnRtN1prLzJzV1RQV1owM0tsbENEd3VNYVhhWkpmUkFNTmo5Q2ZHN0ZaSVE0b2s2UkpWZ2xOTEhTZVlsVncwUk8xR1A0M3A5akdvdzV4M1hjZFFjSXIrRkFBVFB2bDU5ZE9QOHBZaVVsWXgyakVQYlZMS0MvUFV3S2ozWG1kcEM5MU5lWGdhdEpiNFFMVWVrUHZXcWNscFhkWE5BUUM0bE1pYTViMm9FMzZwSUJsWTU0NGhIMlJLMEtGRG5jT05sbGZ3eU4zUlFKd2hnSXhQWVFDVEEvd09wS3JOaUZiS1pSUDVLcnhwL2lxNGZBOVJUb1BweXVVbHRFKzVGOUprOW81TWlTMnlJK1Q4dXducVZjTXNqSDl1VGRxMjliWGVlUEZHdlFPWkdLN21McU90VUlTdHlLb1JNM3J5MVRVNUVhbGVVUzdEZ3ZjeWgza0Y3Unc4VmZzeCtVdUVRb21xWTM1RGk1U0s0ZjdnNFF0Znk0K01RZkZnY1dGT3VvcU10M2pNUjV6MVY3cTYwMmo5SDUyUkR6ejlvOXlPc1dRQno0WklmMDFCdmduL1dCbCtzcGIyWFZyUStvN2RoMWxTTkZEbjBaSStBZmJSOUwzUHcwOSt3UEQvckM2NElNSEliWGphcnFhbXRva05jK2JRSTFPYTE2ZnBQSVROMkE5OEgwL21rbVozZ0M4V2RONUJHT09zd0dyd3JlRTBYeWVUUDl4UmxJaXpUN1ZHb0VBcjNNVTVEbW9Fc21ydzUxNXdKUEE3ZG9vV1ZybTRHZXFFR01LR3prdzBHWEFWaCtObjZ5L2p1QURac2xxQjlZZkdkdnRKR2VXb29FRVgranFWMm9maE1FcnhuZm5xRVhpVlFYTG1xTnZUYjlMaG9tZTJqRldFWldpcFo5d09FNWl6dnQ4cmVoNW5yOVBuTk1VV3hjemxrUWE4cDRtaThLNVQ5TzhmdUVGbXgyTlU3WTUxWUJJS0tleGIzTkVnQ25tdGxZMloveG4wRUtKenM4Mk5CY2NjcG9XamtKanBoRGRzMHg5MkxjZTc1UHNOdmtwaEJJS3prTG5waDlCOFNVZDl2Tis1dnV3SU9GUFFZQnN6U3lMM0JSMXJXMktNYjRpeEpVY043SjVlWitGSmtOMjFpWnM3QUhNNEF0KzNqYUxSWjdqMTYyMG0wdUsra3NwOTNBb09iTmFCNFFQVmVHMlkvWktjcmM2U3lIdkY5aXVEZk4xdlQ0ZmI0RnhCMnF3SnV6cGtGei9zOUF6bGpwbnJtTXZMell1a2VZR0ZRY2E0V3lqYW4zb1ZwaExEbUhFZm5nNW80T1hGWWIzUEFvNUljZXM4YWw2UlJCN2t3dWRoVUl5M1hkeVFVamN2b0dXaE03Nkdlem1iY2k3UHowNTJoakVhUnJlN3FFcHJJRzE3YTBETG44YzVJYnNaR2c3RlVZTXZpemlScVlqNkxESDJvbHZ3cXZabmZTSUcxT2RYdkU4THM1TWt3YUJCdGxTN0dHMUMyb01QRndOSStick8zd1NpZjVKbTFjRVZDUXVCeFpMRTlRSlFnYmdUbmpNZWowRXBPWTRpaEREM09xMTUranQ0T010WmVaZjgwUDJ2L3RmTnlpaXN4UE0wQU0xL3ZmdnZuWmN5Ky8vZW16OU1MQmVRWkVPRy9OOWJVWCthc1RZbmlyRG1POExsQ3pJWE40YS92VUs2YzdEODArR3dnT1ZneGpDV01YeE1CVjBSY2plOGRFUmIvYzJJanJIVU5UbytxdFB1MUFXaUdiNGx6cnRJM2ZVU1YvOUJQR3V2OU44aW41Wi9xNjZQOGpNczY5TmlQMVp4eUtQeVZTM1FHZXMzZmY2YW43SWw2TjNDUW9EeTkweHFXS0J1cXZpdHFaNnFkTElhaDJQWU8wS0xGc1VyT2lXWVI1LzhkNlpOQjRuSkFheVdTdlNyOW5mUUNOK1BERmYzSHZMNzd2TEM2bGJ1MmV6WjlXRjNjZFd0UXRYbnRTYWl4NkgwbUNLRHNaNzlkdEVoV2o1ZloxRXZWNkxWWko0NnpmaVM3ZVBRWWpCLzUxUTUxL0NSRGxmT2o4RE1YaDE3eGhjQjZZWXFMaEdSbXZmVXJHeFYzUGtpT2x0aEtTdDNsTkRiUjRnNFROYWVHYU02ejdEWUFyeTZEWjI0ZTdYeDZubzV6QU02WWh1bjFtNkxXRGY1MEU2ZER3TFRsTlBOYU1Da1pXM0FMck5wWGozRzh1YXNNSW02Y29zUEo2Uzd0YWM2YXVuYUkwN3lXdkg4L0FrRzRGN0FQdUtuS0h2WWI0ZXFiazlTRXlDWTh0UHF2dnNYdzNGTW1rUGN6OVBqQTU2enBFMlJDUC9MSWlUQ3BIRVU3NkZUeVZBYUhXRCtFa3JuL0Qvd0FuWCtFSGJvYVAwN2plZVJaZDREdUFsajBpS3lmSkVzNnZiSHBFZUo5WWJlUlVDWnJjemh6ejlOR2x0TFJ2SHdQMG1BcUVtS3FEV0toYklIN3NOVm5id2pQdWpOUllJWW9HT3gyN1FzZVdvRzRXOWN3VHo5QlB3WmIrMHd3WlZXT09Lb21ObnZCZkNXWktzZlRRd3F0djR5aVp0OXJVVXlpTEd6SnhjMWNWZFdXTEROTzF2K0ZHc0VsK1dIWnpsN1BrUm1wYTV2eFdUb1pvcVlkOFlGaU5jRUpaQnkzZ0NiY3VDNDQxWG94blIrYndkL3NnZFd3TFRZSVNoZ2k1NGk1ZElXYmdTc1NHOENFTHRqcEZocXRNbTFGeDVaWktEVElPbXNVdFYvc1Z5K1h1OXk0NzhPSDFpSENXbUtCREJPc2hQemZrNTcwOGwyOEhFRkxueXppT29aM0tMSHlHWisvLzI3Z3NxenpPT1krVFdEV2lEUnBmRE1NSFhNeFNwYTVrc0ZPcTByelZmQk1jbk45NkJzNi9kTFpWM0I3eVVqZjREaHE3bTAxQ3NXYnBzcmNlK2tMTzdCclA4eWwvV2V4UU1XbklDTFBJWU5FcU1PYktHa2lVTTVVY01Iek94cUZFNlhkbjRaU2ZLbThQWGhEeXQ2TFBYQ3JUcUdWbmFrMEduNjhuWUw3anMwcndSbVRTVFMvMm1zK0JtZXFwbHlQcjA2b01KREs1YUg2Z25ONE5jK3BLT2JPd2VTbjdzeW55UEl6ajJDVFFIYkFkdHdYOXlLZGZPRjhwaER3NXJaYXkwbk93M3FndmhhNkl2VGVPaEZIait2TGNHMG5hcTRXeVU0em9pcjJUMTdielk4NWlYSElTYzlWZDdKbWhaSG9wbEdsSGNwVHlmcHhMMGdkWjdWaGxRVFhqQ1FXU3p6b1lhaWIrWkZMN3BRcU1ZU0MwY2Zmb0s4UmkvZ3k0eVN3MGJpVHNidDFrcTI3Tkc4bEN4bEJ5UWwrclFUNUdTWGw2UjFOVGdWOTBwVms2S3luLzNBVkQ0Z1BTdHE0UWNuZlBkZ1VYb2JabzJ1cWFiQ3lNdHFhdlBUeWl4NU81ZGhpbUhmNmdlY081enpaMjdSUWRRZC90LzJ4OUMwRUh5NzV2Rnk4TmorN1NQRGc5V1ZmQ0I1M0Q1OWZRZy8yTkhuemdMYnltRHAvZGJ5MkpZdERNRjdMbXJUUXJEblpUNUJDZytEMjJOcXJhRkQySFcvc2s2dXFva0VkVTJlcmFtOWc3UkRmZ3pqYUpyMC95SWMydnh6bVpvUkNMdkIwSVJ6Rk8wNlo2c01VVnFsdVNVUGpaWFVDV1dtbXdTKzU5RG5sTGJTcXZqbzFPdERxMzd6WHZJR3RrSy9zM2pGbklsQXFnaHM4M0FWR3V1U2hwRFcrZ0R2WXdralBWaDdGazIzWDBQWkxzU0tqekdjWWxJLzhrWS9HUXVTT0JtZ0FmSkJDc24zOXowUlpRK0V2MVc4R3Bjc3FLV1RKUFE4ZnBBMkdVMHZGWHJZbU9sNGFNT1FIN0tmSE9CMTdvV0lmYnVicmFjQ01JeXpmbWczWWYzbS9SYnlib2tMYlkwRDZyVjMzaEpENnNIUjM1WkJTZTE1OC9vWEhmT01QUDRDRzdGem1pdm56anVlTkYrZUpVVzlJaTFUcWFKb0FHd0l6VzNoVTMxYU5TSHFLYlprV0xkRzVpVVNCQ0pWcEZ0ZjhjMUtqQ1FQSFo2L3luTzdVVDdJSWdCZGdqVUZUL2hMaG4wSWgzU2NJVWJIM29QWVZHdWJWTldHRHlNbVNNWVc2OTNLWGxCai9WSUVnTkJ3S2pqSFNGMngyYTNZTWR0YlJDZDVHYnlVVnpFY2tTeDRteVYvUUdXbHgxRHZTeGZHcnZUSTUvTnBOU0lmYlcvKy9wampaSkZZdlJ4VkF3YVFkMitMeEpmSEY3eUcvNG9EZUNYb2FJQzVuTXlBRDl4U3g1L2hVc3NZNDFsazJsMEpvRjlPSVo2QUo2TmFrekVwdGhFRVRtbkRORWxlMVRGU3JrMWlOekZzMExmajVjK0hacTJaRTdSakFMbFVqMjdESjVaMTQ3NjhuR2d2SnFQMUtQeE5NK3c2RjNQYVM3Yjl1VlJ2U09lNmtOSURPR0xFMzZFV0ZLZlcxUkUrV1U1TzU0aFdsNDgvZCtPU2RqeTg0VnFucnVwV3BxZU1aaFBNVlh2Q2h5aGZnSWE2blRieWJkZUZvNDVlRlVTV2QyeTlkRzkrRTk1T1hBbGh2N1FEWVZyMi9LWit1clJ6eTlNM0J6S3FybjdBdmdXMGUyVkErbDhVQ1lES1FUQVU2VmNNd1RwZ05oMUJOcm5pVlcyNzlRWTc0ODQ0dkhmYUsxZkRLVXAzeDVJcFNVem1QdTdUTHNkNXB2SGF3eHhtbElNZ0gzWXQvL1B4ZDJ4L1Era2tOZS8xRXBaZ3JpWmpDQmhSUnlWZzhpalhjVnUwbHBzaUtDSzVqb2JlYVdndU1xNkZqbCsrUVovWVhwSUxGcjJGUjRmZFhSZEZrWnVyNzZNd0tuMyszSmNYMGpZWVRiUHRyOU15Q0RNUjA4SEdQdVpvVExZK1NxN0tVMlNSMzF2RHdPQ3RSTTRXV1ZrYW1sLyt0MjF6MEdUNFRISDdPN0NiTEcrU2pzWkRMSTZwSHNSVFVuSjlNTDUvUlNHYjlnc3R6YlUwbDNPeldCWlp0QWNlNS9LcGJ2NjI0T1RJdlpkYXRBRE8vTmFIVlY2M1JpQjhreXFuZDJhbXg2VUkxSDFyTlBmVUdUd3dURGxLT2tSRS9WVlBQZDcybTR2TWxMaTgySmVScm01ZHhYdjFoNnVHeGxJN0lETmk1TnFuNUFQZkFKUUJSOTRhek80VDlFNFR4eklIVDRXZzZzcnM1REtYM1hYYk44dHZpUjFISHFYUUVOU1lPd1o3UG5aVGhlcUVaWWh3anlNSHBxZWhCcGplV3Uybng1UFpiVVhEWmlxU3pOVVZMeW16N0tKaDMrS0FXYVRSQk9WWUtPMDFqSzdDRHBwM0VGbVJUYWxxdlYxd0VpSjU3OXBGQ2sySEh2ZnpKZUwrN0tsNnZKKzc4RmN1emkzQ0YreklqQlZCbTVsV3IrbjAwalR3cXZnaExielo4czdvbzZpVS8wZEJQbXlwa3lwZDdxUUJHZndSbTN4T1BlbGNCMjQrVEQ0eTVYWVNtSHZ6OU9ucXU5UHdHN2RMeTVkMXBZTVNsdHU2N01oeEVVN0pGM3NabXJ5OG9ndC92dVVWeFdpSUZsMnpDWHVheWR1RFRsNU8xMDlRS1dIWTRUbnFOcGFmaktiQ21lektpaWhrdU54YzFseW1lV3VnbFFlOUZVRWlKdFdVRS95alQ4MGxKT1kxbEhIOFliMkQ1Z0UySFc5WnJKR3U1NWZISWdUYml5bHZiSzNVbGJyVXFOMTBtTTRNVmJYT1hybVcvUUdFOEFVOGRNbkdzMCtFZ2t1RkFPREhzdVZSa20wcDB2eGdzY2hBbGZtSWZ1QWJ4aE1oVC9aSFdOeitNZ0xqYzg4dWlOMTE5LzZKU2hpU0VlT2dJT2xlSHpleFlRZm54RjlZbmJVNnRjblpCenNEZWNqYWpvd2Q3R2lCejY5eFlVRFBCeW5UNkVwWWZHV0tDZWY0cUJHcElxWWpZU2RyVmI4UElJRlcrMjYzaEQ4TGFsdjIzbkxmemZXQmN5S2pkTnRDdHZaM2FyK2pRaUtOdzlZZnB0NGdMYlVSQnN5V3hkTHBPSXE3cEExditkSWQyY3hKeFJ4RlozcTArazBmOUJPcndvNGlDN1kvdnkrd0JtNm16cUlDRkpSekRDcGFZWDkrOVhYd2xlaFdNOVBWVU5xbENEUjRFa2hPOTVvRHlQZUIzbnhyeW1XYWZTQWI3RkxJdkM2aTNkVlRjZEw4VlA3ODgzMVlYSFJPY241VWZIaEovMTh5L05jTlNvZGhSK1Y0ckp5eThyTnRjTlZTLzZ2V0tDdjRlakt3cjluNGVWNlpEcHVtM2J6cWdONnpwcVZvV2NtT25mdFhPeHdjanorOHZGdUtxNnNVbUhyaWt1S1UwbUZZQ0tDWnVrMkxBckZJOFE2MDVsTkJHWXhSR0RqQi96U2I0b3crVjUxRGdGU0VXS1ViUEJTZ1dBNGVkNDJGL2dScnczQkdPdzVKTXd3UVFSUENGaUZWOTBVSGpoM2pNRlV1RlgwWVMzdlJ2QklETW9EUWJiMjRQQkFaSmFxUjlRcW8zd2E2NytqaUZ3ejkxeGFlak1rTjlzZmlzZjFHOVBVS01VVHFQU2xOOGRabnJmdWJkZ016THg1QUFoSnB6MWZxcy9TeFA5ajlpN3pyNWozd1Y1eGZTdC9yV3NkVDJ4R2p2RmhrM09qWkIwQm16UUxEK1c3ZVhaenNRRVdVNWZGMkVyZW5vcWxqOFRtRTAxV0N3RnlDY2FZaDFoa2twZllhbXJyRUFWbFR0dFJYcE9hZkg2VE9CakM0aEtVaEhkUXZ6WGQvVEZ3K0VCSnZ3R0E0ZXk3eWp2bUthSkg3MnY2K21SbTVzM2hMNXRucDI0Vjd0am9ZcW9Za1V4K01Db0E2R1lUVGx4cWViVW9YaEFKcGdhcFhqa2hSaWpJMngrQVNIQ0lxeVBBMUtZRUpBUVBKUURSNFEyNTYybENJY3h3aUhPR01naUx4SmxMT0daV3EwWHorS0ZBSjFDVG9uSTREOFVUSENZYm92WkxkaFNGTThhcDZCUXVIQmRUZXl5c3FvVVlzdEthNmpiVllWRkM5Y0cvR1Z2UnNPd2JIVnhNYVZqeFc5dnpodkt6WnUrYWtwaytEUk5CQkYzOGhBWWxyR01MdFh4dWlSQlJTempiaklyaWZQWkdCMllydDkvQS93V3NYMmwrb0haWERCeGNVcHNCODBBMERaQmVNenJKbzdERUJldFRGUTJXUlF3T3pXQTRPM294Wi9xbHlJMzRzUWkwbGtJVHlEdVJLaHNKbmZubUpDb3JaKytVUEdyUEt5QUNzUFBIMDRVMUlsaWMwV21KTEU0R1V6c3puY3lwaTlDTGF1TGdIWmZVazA2Qkd2cE1NSmdpVWNTc08xMU9OYm43QVJRVGtNMHpCTTBrWk1jaERLN3V5c3FlN3FQaFZSaTFoY0ZvQnA0QWVaQ2swOUxTeWQzNzU1Y2hQbnVGbzZJOFBmTUE2WCsvbjQvZE1kNEVWSUlhZEdJaUhkYmtWTll5cWhwV1l1bFpUWE5Gczkrdm1rL1gwcmZiLzVqWmEvdGp3WHFUazdybWM2R0Y5NVRkOWEvSUIwUUFicFZldXpEWGc3ekdGbEl1dEtnek82WUJ5bklhTzM0ZlpQSFI2bmpWSUFVckREZnRhQ0NlaEVxZk1nZlpwdVdsa2FXTkFzc1Y2NGVybGdPeDgxR3RQWm8veUhLMTd2VHkvMmVQWEpaV2VQQ2lMelljYWY1bTBEZ2NJelJDdFlRUWFCUlRhTGV1N3YxV1NERDJ3VFZDTUpOcDRkS0ZubitaTTJvL2tobmErc0pqSGRONnUzcDRaN0lMMXg3UTg5R05XNDI1emIvdXpJdmJINStUalhvMXdKK1IyZDJVbitqY0cxZmNuWkJ3M0QxczdOMDdqV0JjWXFmVWdwa2pzeHF0Z1IxajEwTEJ5M3RFcy9SbDRnaUI1U0NhelFBdTlESHB1dWVnOXBYbHR6MXlsM2FsNVowLzZsUjF4K1YxdjYvd1B5dCtjdGUxWFpUeSsyOUZEalhSMGxFSUJucHdFVVFWRTFPRVg0MFN4MjQvTGxoWWRMSHBsQ2VaMk5IOXZsb0xwUTNQM0RHNzNWQUJSVmpSanp6VUJ3TEFxZjZ6dTdmenF1SXVIN1grR1AxM1hRaGNNY1hNdHExeTJTdm9USnpiazdYZURvSExjb1VYQzJ3L1MvQjdxeGNLclNsMzZDUS91TVo1bVFyTVA3ZTdqNmZlWDJlVnFQU0F5aUQza2xVKzhqV2g0bDlVdTM1b1pDcWhxSncyczhSVlZHUytjMzdjUHBwRE1uZXo0eVZNalpVdHNBSjRMLy94Q0hEa3dVZkNmN1BGVENrKzU5UjNYMnNhK0pUVE1tQ3ozNFZETVBXejR6bG5NY3EyY0dmcUdCTzlXa0V2UEdKTnM1T3Y5L1g3NzFObDFwK09XdlpUNUI3d0t5a1BQN2NzTkZpeDZZSzdqOVJILzEwZjNoWnR2RTNkUkwrVVBEMzh2VHIvZWdta0I1L1czUXkvbUorWVhUWStZaERHSkVKcjlzUk1JZ2dGT1NLaU54WTBZeVpNa0pCRUNvU1VqNUZ1M0xRaTJYSkMwWFZjOWF2endtTW55L0tESnVrckdodzdQYk1tTk5HNXN2RkRoQlRjTFUwNXZ6L0NYWUZNWVB3NW01dGZHN0RrVHU3K1ZJMU9QSjYwYjIzZnp4UmNocllBdTFRdHpwRVVVQkxHeElYVlZYNld6dXd6Zm85SHFlekM3dmR1R3YzYnVBaXNvQStUUXZBTTB5YWRCNmQ2K21CNUNWSmdwdDJCUVFNY1JheEc5c3RxcDFyV0J4em5PVDBrSldLT1ZrTEJ3a3loeHNTazJJQXI4UngrQXZCdXhOUE9jQ1NKcUVxMlp5TUJNMkJmMlJPM3UzMjhyeGsySTE1REdnWm5LS0VZeUM3YlVOdXdQRjIwYkpyak5NdExJc3hIVndleG9QWG96RkRrSjJ4UXlhczFqU3gxN0lkVHd6czYzM2U1TnRTRWZnVEU4ZWw4UXhwd0lCbGdUV3hiSk05S3lHeHdwdDFyNDFnZ0dpSGNDWkxaemx1emhpRDZTa0EydmNTWThqcEJKK3FNUmJrZWNGZnNHNTRtRkRDeGxQam4yN3E3YjBmRjFpdC82L2FKSTkvVzF4SlhWMTRzRUtXRVlMOHUvT1QwaFFWaWpSRTFlS2RtajUxTkRVQ2FZOG0zSThSbnVDb2t4U214aWtTRE5vVm84NDc0MURBWDdIdTlySXl1YkxpZHNLcFUveUtmSE1HcTY1WFJ4aUM3OFpMTHkzcWkvOVBXdG5yckpIbmpibHA1cHExMFFsTUFMNk5DY1VNOG1KWnBqOUtuVktMeTUvOTh0OHBLeHBIMkU0SEdjS1cvWi83eDFBUWw1RXVMTC96Z1lGZGs4TVhGdnZlcjlTYlE1M3pmdm5QSjJtTUdsMElYekt0MCtVOVBmTHBNeUc1MURnMW4vcVRNdStrZVFxbFpSaXZScTNJemxyWFo0NVkxVlZvZWZYU1RDZ3VDNlNzYWQ2L3Yzbk5sM2N5ZEJVOVBibi8wTTRQUzZQU3duSzF6U3BwK3gxUXdUdy9vQjlJKzJYeDlxODVQZmYxaTZkKzZjL1J5VTNwZFJsTXBzZURRaEs5M3J1SFlkazhYMWp4VUhWMTdGV3JkZXVJZ0lUUFdxMFd2OVhLL2I0Y08vN3l2dTNWemN2VkZReTRKZmYrbVhBLy9TRVM5MTYyZEpYV2VxYk1adi9RWTBQK1J5WVBUTjRJdEFiRVpWY2ZPdUNsSEpSRW5hUjhDbFJrc0dIUDhSN3dqb3Fqb0p5RU5aRTV3cnJTcUFvcXpUV0pncFNMSFVVWFcvRi80MkFWaGlMUzdXalB5TG1QZFVhM1VUYStacnlPalpOR3Vtek1mckNyckN3eGN4NlRONkZUMTF5V2gxL29lQUhud1dLL2FISkd0ZWVLL0R3bUh0bndUa2syRXZaNkRLZ2JnUUkxVGtuSTY4MW5NZmJ5WG96Wkw1a2JQdzBoczlMQm1UczRjNXNjcEpVbU1rZVZFNmxwQ3c5R1dNTmpJZ2JELzIzdWtEdmhPcVkyMjhROGY2R2dLYUNCOS9GZVZ5L3d2Zkd0aVNZTENwYVhKOFNYbEF6YUI4Z0h0VmVhUXBiU0hXQjRsOGUxK3haMDVWTm1LdlMxK3lVV2N3aWVsd2FOVzN6K09XVXVDNDNiem13UC84MEY4dm5Pd3ZEQ0JaWlg1NnV4K1VhcUE3eG9EalpCaEo5bDlaSmVKQXFIQWlFc21hRFNma2xDNnF1QURZam5iY1VaT1dwbTNFcTNYRDlwVkYxWFlKOGZEK01vd3dESm5JRUJDK2F4QmQzM2NFeDQvckh3bUlkUDNmeXdoZ0FkczliZzk0ZHgwRitqRFZwck5pQ1NJVmI1eWM1blNYMmlCSUdEVlVieHpadHY5OHNHL1AyakRjZGxtZ0VyK0xYeFFBYlA0dXRyRjZRNndtN21CTUVRMTVpeDh4eExPMTJ5MnJMV0crNitvRDJaZmhMUnhPK3NXc094Q3hmUnJOTko5U3VuczFCeGVEOUlVZDk1MWdVQ0hyRStGdkdQaXM4N2lCaVJPK0lSUm1iamxxN2IrdHR0NGRVeGZiVzFmVVJCS01YRWEzTnpGMFk1ZFNEaGhhMHY5S0VkbnUvbDhrUGV4S0twN1hxSGlnQURBbTJjRXBhY001akg4QmdPZThmMkRMdVFYYm9BTDhNdlNONHR3MzFUbzg5YlB2dVJJMDRlK3puMTRTRlpIWmVsVHJuNHl1TjFsWXZEdnJRLy9sc01PcEpxTUJRc01QdFRrM1l2U1MycXRDMWFVTk03RTU1VVdCWDZRYjl6U0owZTg3ajA2ek9RdmFZdGdPWklPd1ZpZWRZbWVMR1hQNjN6RWpiOEJnRE8rMjNxcnpaZjFmTTZma25maXI0bHZNNG1JaG1GNUxqZGZMVDFmY3d5YUc5RmJXdk4xTlRhbXR2V1ZjM3NmRFZkTmtDcXljVDFJME9HL0NmN2tJSVIyN0dWK3BBUHZOa1V2VjJpV211MlBOYmtWT3hBL1ZGRUUyL2lvdUdKM3hEV3hrQ1ZjdmVRWGYwOENueE1lYzF5YUt6YmJWdXY3NVVIcXJKUXd0TmhXTWgvd1ExUlF3WVRpbllBQ1lKTjVzK3pCTkdTb1BxTktCVEJxQ29YMVpFblFHRUlwSUxwQlNlVVVTT0g1SE56Q0lZMzB5U0dJWGFKdjZjQlphREVXeWJVclY5cTFQZk1haXF1TjE1dW9WQ3ptSzE2RjJISzFQT2IyVlhHMi9tVWRMRFdmQWM5cDJWdG9UUGJTSlk0M0srV21McFE3TUF0WlpCVndEdHdxcTMzbm1vN2wvZEwreUtwdE90RHJxdy81WmJHNVdubC9GN2lEbTU1V1BjYXFhU3pxMDQ5ZFpYelc2R3IwUU94cnR2YlYvM2FxMHpLcFljTERJenY2U0xVVjV3NWU4VCtEMmFla1d0cjViMTdhbC9RV0pUVlNzM3B3WWtDZEtCV1VNa0NLbE0rOWRTNktLMUtHd1dmbSsrY2NzRWdSblJDR0l5ZU9DZ0xvTHdkMllWcGx5NFVDWkdaa1RHUmp5QlU2YnI1SWg1QkFPNDAzZzJPMjNVdDdnUjE1b2pFSXorKzE4eXFIMHBObENKSm9YTGs1OGRyWTZub0RsMm1ybE9IbmQ5MHgzRDk0dnJoTlcxd3pKNWgrbHhuNStyMkM1MmQ1K2dIVWN2eXFheTJ4RTVoNXRUNm9PWU9EWi8xcjF6cGgzNTlYODk0N0pobmNma3BPNzFubUdYOUNxaFl3ZTlhM09xVjdpLzN6bmRrTjFjVEFtdXJKWjZFUjFobjlxQVU2SzZiSFR2S0s4bzVNekNxZTNyYzJOdXZKcXhGZ3h2d0ZLTmZmVTU0QUxNYUFlMUxjVjFJSThGQ1ZDSndOUkRjMnBjbHY2dVliZFhGN1NaK2kyaldxTEYvdUc0UjIxVGR1TXJJOHcyYmUwSC9jR011cy8xaDFUTmxLTU5RUlBicUpFSElWTmRaeG5GL2Fka3JHZ1B3Qm1sbmZOd0xGVmJjMmdCUFkyUk04SVJOVWw3cUVpVlIwNmJiRllwR2N6NFdzM2dPNzdDRWdlUm9wdWk0RGNnRnpTS2xCNUlSNmpjQnBOcFJPNWF4L2RHREJ1OVlOZ2NmYm8wTmVxUmZXTnJlWHJyUVlpWWoyNFdsQWZxUGVWUXRieVl6OUYzNTBVYy9MSmZMNDh2L0V5TS96Rm55MTE1Q25hOXA2SDRkcnZpOWdUMEozdndwY3ZDbU9XVjU2N2sxMHBqSEhBZnhTQU9QZVhGQ1JyTG9kWXh1YTNsaUFvNVhnVlF4aklaU2V3NXpkOEk5Y292WjQwaDJnczF0U3hRMmN4UGJjcWxSeW9WNDJSR1I2eGtCd3RnWUdyTzFNZEYxalNLWGFJRFFCTm12MHQ1UGMxQTByWHZHeElIV0dERVllbjNZblVNYjNQcTZvYUYxaHJwQjFsN3J3cGVhS1dEQ0E5cEE3T2d6Zkdaa001UWpmVVRCK0U1dW8zM0l4d1VsNlhrK2FicVNLRHV1b002VDA3clFtNDZvam9neHAzQ3g0dy9JNUFqbWlUYU84TDFENGJjbWkrbys2bmxnWkZHWHB0WGNzZTJlazB2R1I0Nk1xc2FEd1lVemZHUms5T3ZaOHYxWGhvZis4Mm5RY01BUFcrcGR3YzF0SzJ2L1NERXlFZ3dPL2RISElBS2VFV1oyMlV2dlU1SEpnTU9EYVVSbFVmZ1JBR1RJQWhIY0dJblVKMHBneVd3dUtsVkVsVGgvUjZnbE84bFpHTUlFbW8xZ1dBVlpTMGdFNGNXek9qZHlIK2plVSs5bFdTeE5TRWlFRVZ2NnQ4bW45bDI2ZEdSa29IZmJLNitBMUx0dFpva1BRNGYwS3N1R255eGM0OTgyM0hNbjF2Ylg3TC9hQ3U5TWFmRzNSdTVpZld6VzlHaU5aaU53MGZDTDN5Zko0bW5TamhCeGRVMjhQN3MySDZ6V3R5ZFZpWlhWY2tWRlE5OXRjL2pibTZkYmQ1MzQxejh2NjBVQWhURGlUTHpNY3k1Ny8yazVwUFA4TllHeGhLY2xiM2UyNU5Ha09IZW1PeTdwMFJMMm40YjZSNWNvWDh0NFRabDBUTS9LMkVTWWhtVVcwZUM1RVlDdklESjR5STRRY1pHR0xvM3VhQTAydlYrL3h0SVY1TFp4bXJTenlsb0hlOXlMKy9lMUZLN3FpdUQ2c3RkbFA1YnpIOWRBUlU3VzJvUHF4QmF1T1ExTm1VL21uY2k0b3l6SE93ZE9oR3RQUG5LSUQwTE5qNmNxZzltY0Y1Nm1QYVdKWDVTVWMwVnpKZXlLUEJsMkc3aXBEektSSDNENHB3cTVja3ZRcW8vUTJXejJ3Z2t4cDdoSS9WUk1lckNiS1VrKytWTW9tN01JUitZa0ZhaStWU1RUay9VcVRMeHFvVkx0RHFoUnJDTVpkMWR0SUJRazRVcEhLUjNhWlZnb0JXNkhSQkNGSExQYmxXUkxRRHZCRGg5TS9kMlFRNnFpZmtGa1Jhc094YWsyaHhBV0V2bThlN0laZ0ZZZm1pblAwTHg0d0daV0Joa0VXVlhzZnRCWGZiNjRlSmJsNzNGMjF2dHdPY1JSUTZUQmNyMXMwYVJXaE5SbjVpT3VhcUZtcll5cktSR2FnZEU5NFlTczF6WFpsLzc2Q3RVa2Nvcm1tV1FXN3JtRWlxeW1KUUlxVGNaS3RtSlR3NnBBMk53L2dsRTZ5R2l4dVhmSnVob2swcTdKdFBveTIxaXJDaWdHZEJJTlhLcU94WTk5SDJaeEtyQUtQS0E0ZzFxSjQxaGpMV1ZreDRLVmREcU8xUXd2SkdubzNZUGNnMmFaWVF4eGJQM2VYUyswbFJwcmVDTnpoeU1ZeWg3QVFsYnBucktNR1dxMmEwdEpMejRoUnlYZUxNb2NXeStWUmcvRXI0dmVWUHZRNXBzeUtXWFV1Qnk2dWh4Ujl0eXJJaTUwUk13cTNBNit0aW5rYjJBWnFxcHV5amFuVUZJRHhjU2VtZkNIb1RMTWdrcGRjejQ1cVdpRlNoRnRaYWRZOXNIeTRWclpPbE9nL1VEN0VENlNIbElGU0pqZG4xcDc1ZXY4eVFlNS9BSjVlRml6bHMzZisrQ0RWL2tIbVdMUHUxUGoybEVxc3Z4aGxmNzl2dDU3YXNkVkp3Y0d4cU1peHdjTW5GU05iOTJxdlFFVG4xbTVVaDZwemZuNmNCcTBGeW9xMEdNeCtsY3VyclpjZTdKaUw1eVVrY3VQVktFQmxMdnRpSmc3WUlKRUZMME95SXZvdGZCVWNqdnplRDBjSnhNYWUzR0lMQWN0OE03NERIWXNZZkRzWm9zcjVSeDJvWUJ2RXdtaTVxZ0RIU1V1R2FxckxkV0d4b2d4dklNVWhFOGhFa2Y2N3R5RW1GbGVNQ0U2VHBXYWxBcW9ZcXNKVzVpK0NLNUloeEcyRVlaVjJwZHA3MHBiREVzemlOZDVHSlpuR1JST00zUTRpTXk2M1ZPWVZ3Q1NjM2NJVFQraUVkUUZNYUcybVFDUmpyQUZYNVRNSVhNWUVUQnlDdnd1MmpMSk5DdEFmalEyTWg1TG1QTWlWc2hZRld4Qi9UZkFJY2VsZEpUUDVLRWRjeU04MTAxb0RnT1RWMCtDMHp5ZE4wSVRBVGNmNGhoZDVwckZmamNHOVd2RzE5UnVDMjVsMkdVVDJrdTRXSWdYaWl4TjFZLzFHejdrdzJPMlFjVHdNQ3NTdGhqYmZscFFadmZnZ0ZQdEZrVW8zMCtmcU9DQXV3c3R6MHo5WStyUmpnWVRWcGpMZWZHVDl0NGxJanVMWnErTEdOUElweHdhWXl6VEhydkxnMnhJVHhWWHQ2TjJjZHJPRk95TEJZS0ZuV2NLZ2dVTVRjeDZwNHNlSXJrMjUwVVlBUm9zOFJLK2dMKzBKTDUrNVpFRVJtN2YxWEI0WktuMi9hNyt2QXZlZFEwcW90aVc0WWQ0ZGh6MWszUjM1cnBRMWZVbE8yTWZqNzJqYkVZa3hHVjg1M2JkaEhTOWJlQnc3aEU1a1dqQ1FWczZic2ZuVU84Y3ZiNXRCWURsTVIrVWJZUWpyQmQ1QVJTUCtPQ0VUVVdzOVh5YlRnVndrVjVBUk1XcXF5RUQ0MkJReWEzNVppeEJSRVI4RVZZSWsvZXVXQ25mMUN3c3RiMS9hVjY4OUZOTGRVTkNVVlhWeTVvNGI4Q25yTGgzM1I2QUxaaUhiRVZmSUcxVkt1MUNmZEl0eUp6Um5BbWJscStFWGFnWkJHOHl2ald2YUdCajdzRkhrRDZncCsvN1RmSktxbTVsV0hPeUNwdXFZQkEzNUNaRXBDblNVdjVxMTNSNGo1bkg4TEJUUEIwNzV1L2ZPdW1ucXVQdkZCdFl3aE5XRUI2WkNJM3UxRXR6RWZrb0pxWWpJay84T2pJVVZGYW5wcUxJTGlzL0RJUmtxSWhLRTdFdnBqejFsanVkYzc2RGhPMXYxaWVSZWUySm1QaUxTc3FlNkhCSE1yeEJMTS92Y09iU2lBZ2ozYXh6S3BLbURYUU9jRVFpazhjR3o3S2JHcVc4Q0xEN2hWN2VTNEplVFNVWmlKaTRwd3FlaW1ONlplMTQ4NHpoT0thV0NNMlY3aHdkN2NSMTI3ZlZZbU1UYjhUYk5BNnJpSXFWK1pmR3VMQUxTU3hxbWlWNmwvTG9SYzdFRnlzS3ZtSGp4dmF2MDRnckd4a2doeWVGUkJ6aWlmVURZd280NzVOOFlyRDFPdDUxbXBicDB5N3VtZkdPSVJsaGJzQ1JHQ0VaSVR3eGlpSVNFYjEzOXRsRmdiQkVOTmw1ZTFDSE1CSm5La2t3S1VZNElyd3NSQWpBZVdYdlJJWUlBMUUySHNSeHlvZGx6SXhGRGdlTWtWdzd0aU9hbTJCK01rYkV6YnJvV0cyUTEvZDZKZXlpU1RBaFBVV25BVzQzc25VRXk1aDJPU3I5RXBMbE1sRU95dGUxaEtNb2JPcU5VRURpTkFydDlxb0FwM0FkZUdtNzF3czJ2YVE3aGJJeDRxeWRPVVNvM0NsT1F5SC9ZY3ZuaUd5NmpoRStEWEM3SWV1NC9HQ25vOUt2SVVDZGVkNVkycW9tbVdzMndCelRFNEVSZ1Q3KzVjcjl5a0U1TUVtWXdEeHJLcXpoRTdONFpSQjJ2aGxlRTgzVDBNZ2NaV1g0M1NMSXMxM0pzL3dzVGNoZE1OSGVXV0NvQUtTSWRIWVY2VHpMbHRDckFaRnFCRjY2S0VqV2wyR1pReGE1TGtmOThNM0VXQW5mem1zSVR5cXFvZzA4L2QvejdTVmpNQkh4Ri9oVWJnMmlyQ0lxSHZER0ZBREVVN2lCSzhrTWc4OHlOeGxCeFc2MUROZ2dHaUNzSURTWVBVYTJ5UzJ2N3VuZmZodGJXVmVITUNWVGUrRWNZeDd1K0c1Sm9td0dnOWlxQmlQQVNGRUt4NGk3ZWFHeGRTL0JKUGR1YUZWWFk0YWI5K3NpRDBYa0hvS1R6WXpUTlIyMjQzUnlYSGprM0hkUmc5RWJSZUl0MzRNRUQ1RmF0ajVRSHdlenR0Y2llWnllYy9XYkY1VzZMamxMOW9KMUJKUG12a0VraUNET2tmQnlDRGQvRHlsTmtLam1WVVQzeEFyOVQvcVNxSm1JTzl3Y21Ka0ZSakdxSFZWVVJkVXR1cHNDR3MwQmlYaXhWekZLa2RNWDlFSDl6VUxINWNNS3FrSlJvYTNvdTBHQWFUNmlvRWJTczh0aSsyTHpZM3RqWDQ0bDZsUStGZ2hCUjRCSGd4dmx1Q0hOc042U0ZlU2RVOWdoejNnbENReUJpaG42QUZFTkZ6NWpBc3dZd0hoVUMwVEN6ZWFPY25QdTNMOC93VndPL0ZZSmpyQjNWWmlIdDh5NWx2VUVtNi9jSTZlVHpYdUd0WExCTXJIYlM3Z1cvQ1hIR0VJNGM0YUlCczZreFF3emdPT0NnT0RoWkxGTmRHRVhZeDQxMVEvM2N0cG5tMWl4Kzc1cldnYVlCNXFNYXFlSm51K2ppWldnTDdtNGVTeVpDOG12VzVySnZwdVJTWDBMZFFQenJlR0tZa040UlBoOEZSRzlsalVwSm0wUWdNQmNKRklnT3VBTHlvazlla2t4cmZodElsazhhYlhKVkF6T2VBeUVyWTZDcmtRbEVaMExOQjFIZzlxMGNTV3lxZ2p4bVRDMXFTWStnb2tJWjhKSXd1eUNBUWxMNkZhS2lwdU94UkJhdjZhNWowdXZnRXpMSWl6aG54clNZRHFONkhnODBmWDJzQWprRmFlcWhaZVlmQlhibW8zb3J1dE11QW04dUV5VjZoQVk1WWRFZG1aR05ZOHVsSnUydmxaYkZ4SWFOcm5hSkN3MGRsS2xqb3pTUmtYKzUreWhWN2d1MDJSWTNSUC9vMU9obTlWcGd6MlZMcG5jOXRCWEh0dFI1UnFmdnZMamFHVFJtb2ZNNkltWndiQUZVZHVwUlMxdVg3TUd0VHZrdldzZnFiSEdueTU2YzZ3TS9uOFdOS1E2N1QyblEyczhXeUZWSFpDS2oyMFhQY2VNYUtaREVUZGtFd3kzSFJmUithSDhlTTBSZ3ZhSGcwdjllWTIyb0tIeDhDMU91WW5yZ2Q1VFYxUjhpNlcyRlA2RzFQSVBKQ1BpTjNDKzJaM1RyUDI4Sks1aCszRXhlOTduMUlIL0k2dmMwY2Z6amtlN1Q3OUxiU2dualdNUXM0T2RqK1hZc1NCSEhIVDZqVUdPbUZqZlhIaDFJMUdRTjk2UUE5UVBhdW8zQlVTVlJxVVZoTWM4cFZMQnVZZFhyQjBwWFh2a2hScjZGZWVINjQ1OFZGcWh2dFB0dFRQTEV4cWZYS2FOMmQvN1F1c3BwV2YwZndVVTFPQmh1RUNGOFZvSWttUE1STmVVV2Z2dXFxSFpJSkQvZ3BOSytxTHhOWFVzR0ZRRUpHRFdTZmZKbkFwSTVRTU96ZzZoUnJVTzdVbnQ2SDRSV25iSlVHUFpZSXlSUjNzUndqcmV2Z0hHUkNtek1uV1NjbE1PS29uQzBBaFEwelJGMDlUNG8zc2lKdFE0UlRESExhNG1CTThnTjUwaFA2RkhuR1FSbXZGTVZYUlI3K29KdUg0eCtTQm9SSS9XaS9ISUpnNFNZNHpyM2xEeGh3TmZEVWJKbzJTZm52SUtrK28zZVorTDg3bmE3ZDJWK2h2NnBkR0txSWovUmZKVXRLQkRHcnhnM1c1SEdxMzczL3YzcGFVT3YvK04xM3Q3WDMvajhEdHVoNG1DQURYV054R21iQ0l0WUdLU2JLTE5oTnJEZ25jNUdESG1sNkM1ektEU09uRnB6VmxWbmRtN0tydjNKclVydS9NM0w4b3JwMFNBbUdkOC9neFhFalM0U25kM0xyOEZyRmVBTmdSTGRkSDNJM294bGNDTzNBR0hmTWlubzNmc1F6STVIdnY1TWlrQUd1QWtzeWpIa2kxNDltQ3daK3Y1SFBmOEdVN3lCbGhhMDJYTy9TdW5aM2ExOVlFblN6UG1HaktZdTFLeHorQ0lTZDBOZThpcnVpNlU4WFVLUVRxU1lUa096ZkNHckVTU2grQVBMaGtEVHdodFFoTHltTWhQMFZrVG5pWVJSZ2dmMlVMMDlZOSszV2tMVFNMQmcyaVY5WWNsZjRLM1JoZDJHY0w3aWt2RTlGYzF6UjNVTy9iWUtPVjRVblplZHZxUUF4aHhqT3N0OGdhZjh1dXc1VG4rUTk1MzQ3bnNqNGw5L2hFbDdaY1RKcS9oLzRabUZNcVZmZTlRd2krNzBxNDVRTitYZWNiZzZtYTZYWVl6bWF0WEhlK09vTSs4OUwzZFF3c0hta3VpYkVuNmtLSUQxMlorRFByeGR2VmVFemk4TWw5N1lHc2lMSm50Skc2TWlGZDVKeGxzd0JKUmhId3pNVUZFTWFMQWlwTVVSakpKV00yUk9DQUtzQ0drK0JMcG1paHQxRHlFUmlHT0t3ZFRzTEpWUmRrK0tjYnQxdTY1UXN2OVVQdGxSQ1QwZWp2WWkyYTI1WW9oa29SNGpLbVRDaVRtNHEwcGhUQkNIT1ZRU0lvUmlvOFRWWnlrNkJLV2QzMnFjb2lUQ1pJUU1jUnFwRzVGdHVpWEtjY0JRcHExemNQSDYzWFdmSXZtNFl5NEJKSjAzRlhLb2NoZ0VkUytGY2ZyYzBZaW1URDJYY3VWWk1nd2tlbEdURnlxK1N4bWFabzZxYUNYME9pZE5hVngvOGdpbCtTVTc4MHBUdGs1NFlJdlRTMzNSTXc4WDRUUFJQTVlDNDFIQzh4Ni9HcDk0b0FBRnlPT2QxUmJuTkdKQ2FGR3R4N3plMEI0VHIzeVFLTW42QlBsZGpHaHFPNUtPMitZMWRkdi9SWi91em45MjZJYm1kL3VFQzZzeHhzTzlwelprM2JlNGphK2ZQWGd4cHE3em0vRUd3K3UzYkh4dk44aDNRZS8zK3JYNEFhWFgvOVY3bW5NMEp1dENSK3JVbTk5SFRNd2VXRWFtcHBDYVF1VGR4KzY5ZFZiOVhGc2Q0TkcwOUFkRzVZTGdwS1E5SWprTjNreVM2T0gvbS90UkE3MTYwZzZRTGd1cXlQalJDc3dSVXNJUnZaZm5yQzIydXpSelpwbmRmdURncjJjaHppRFV5eFl2Zmo4N213Zm1makF1YTVXYm1xdU9UakYxdG9FSU8rV2VWZHdMeG1lcDVBNFFXUFNaMFFmT21ZYU5VNmRxQ0JCWTViT3g5SkxJTTB3aEtRckNHcTlMcnk4SVJ3MFhSWllSMytKWU14RjU1RkhSTlI5SWJBMGVJLzVRL1grSXExaklZeWJIRktOYjhBc2NJSkZHNzlOR2ZWRjI4Q2hCUUIxNERITHBJWFhpWHFZaUx3OTZwNk9qdEhrODVqTEYyVFpRamtvaTh5bCtFVWhaNStEbkZLYlZUdy9odVZBZ0UvR2FzdldCZTJ6TUN0Y1dGNjZzOHV3ZlBmWnMxWFZRWnNnVE43aWdZR2Y1cExCekhzOFJ4ZHNYMHhqR2kxMXQ4M3FiRWJIWitnMUtBRlVNWXRZWGZzRXNlQnFpL1Nyb3VsTFEweGhrU05XcFE0S2VNRTRHclQ0QStOck9OMGl0VUt6dm1iYkQyM1o1N2VjbytmVVl4V0dkcDZPMXRTc1RkNVQ5NWVxdWhJNHNDSWJhOEswdGE5cC9UYnJ5ZWM0b2lCdDYwbFlPR25rYko3MVJFR2VNeHBKSEZuZjl0VFJ5SG5hbUdrWjI3ODJJeFJFd2tRc2I1MkV5TDRjamZLdFdiSnI3THBxcE5PRjNkSmdQTGU5MVNxOW1YZTdyQTFuaTRSd3BJRTVMQ3JvdlJwQ29tZTM1QmFrNEMxRDI2dy9KZUljVjBrSkphZWdTSWZhbEJCb3lmR29VTmIvTHFlUkZpMy80Y1lUWnN5dkxER1hyT1J4dVNWd2ZEblNubXRxU3BFcEZBbFArMDdRUkpPalVUZ29Idk03QWd4WTNJZWpxZWdzSWM5aFN3R0l3Mlo4S3c5aUxlZGNRUzN1Zks1Z2IxUFR0djBBTndmMHlBaUdmSmhIUEpZSUw1S0FqTVpnU1NKNEpsTW5pLy9qS1ZEdldBQUJnMkJac1VnRXc5TG9ud2hvOHZFWXU1MGJDU3BjMWhDTXZvSzhaTnB5bDZLVWJ1cUt6YlhMeXMzZlJyYXd2MHJXdndSck16T1NoZ3AzSjQzcVlvWXJSTXU5QmJocjRpRmJRWlczU3EwOVVqdkZsVWQ4YWFtWXFkdzB1ZzNVbmtZSnVWMkphNjVvV0dsc2F0clBOeGxYV3h0aHZFcFNxQlNBTk1mWnllN0dwSnBBODh3NnQrUnAxZzE5SFdnM0JBRk1QWTdCNUJwc1Y5RFVyemRGS0ZoUW8rWU5TNTBGWi9pWUk2TUxveVBuNWJWcjM4M1N2SGtPdDFmV3htOW9ib2ovb1Q2K1paRU9UOElQOFEwdk5tWmwxYmMwaHdweGtMRTRiZnU3YlliRENZN3hxZlV4MmdhcTVJaDZHclRuRFBVVU4xWEhTTlFQZlg4Z1VZYmxlL2xyUmd2ZHg1bnFmYVliN3RwMnQxUEhXY1NxWlduWHpyMUxsNjFqTE0zT0RrQTF3RTRMUXpQWGFBMHJhWkRHVFpoYU5rb1JiWkFNMFFwaEJWTklJb1BmbW5TVTlzS3pJc1FXV2pHRHQxeGpwd1JnRFZaVDVxV01TNkNvVWRPRk1VMWZjdVV4c1dsSkpjenltUzNDeHNsRHA0YzIxZWM5ZmFmSzJ6Z3A3M2RQR3N0Yi9IS3Q1ZlhNNjJzN2lrZHpqNDZDMnZzOTMzNHdML0U5L3F5NFl1Tm42YlBHam8wZEhYZnRDSFRNNEIrajc2MjUvV1QzQm5aallpRmUvdzZNZW5IaFdyemgvQTU2cGlOUTlPT2NJM2p0d2h1NytZcU9qWTNKTU01bU1hVTdFN01KQXNjQU9KWkw4bUk5Skl0ZHgzM1NPdlA2amxTL3BLYkdVMy9GOExSVSt1UzJqMzVhbXJRekxHbkNGc3hjdk9UVW8rekI1ajVoV1B0VGRhLzgvVk5nVXBacDN3cHB4Y0pXOEp6Wnd6YkpCZ3JpUmRXVzZsZzFSNWhnSzJWZUFxUE0xT20wRDh3dnZ4SXVtZDFSUHllRU5MQWtqNi94ZXRMYVh6dkNiOXpRMTNkRGZmQVhMN05hTjFkYkJkTFNJa0hGTDFla24raVBEOSs1dGNDUWtCQWExSXR0ZVhzcnRqYnFscld0MXZVM05QWXZLVWo1YjI5KytTa1VlYkZkSVlkbS9tbnB6czhITE5VUlM5OTRXYkY2b1RWY2w1S1JHcit3dWNHYldiL3pvajQrNDlHWHFkUkhreEVkOStkWFZ2ZWtMd1I4Nmtjdy9RNTEvUHo1ODdTeHkrYzFoQndxUDB2di9MeW5OWDVIM0twRVpzeEc2dWxWdTByK3R5ZCtTY0ovWUdYNm44OGtuMFpMZDNSYnZ0Vmk1ZE9YS2RTUXJVcE4xQnhSUm1Sa3FCNWNHb2F5L291S0dROVdNWHdQb1BQTzBpb0Y4R1U3MUpVSVYzKy9mdDR0SVVTYU1iMGRXRlp3NVVxZXpzZzMvWW5zM1NzVDlhcTZ5c2VsTUNpZmFVNUIxZWdxUktIWDZyL3FMQzBNQmlZZldkNllHWGVub1hGWk5lejB0TnJKYkRPOW1DNHl4djlWVzZjWXA1cSt6OFNJNlM5dVc2TTBYcXRlMjNBNUxway9pQnRVQVV0dkpnbEw0Z3doZjh0NmZMRUpzZ29kbWFBall5UjhUY1k0em90Z09ZYUEzVTJjUVJMQ2J1U2UwWG5GZlJLU1NCS01rUmU4Y0lyd3U0bHgxc1lUM3VQUmtPQUlLd1crbzZrM0NBVE9aUUpETHNuVlNpR3JWcGtGY0owenl6eTRqRWs2WjVFckVIdVdxditFUTBhQ3BUNC9yN0s3NTFoZXM3SWhKemJ4aVBxSTlrSFVSU1dzalY5TFNUL0x4SG4vSW43bFpSYXp3cUVwSGZ0ZTI0WTAzZFFtYWRhRFdleTlrNGhNZjJ2Zy9UeDBuS29UcWNCWlhXM0RSQ0oxTWxJNGxFRXEyVUw4Skl5NFBrMzBMYnAzMkUvOHdPTHU1cTQxbkJjbEY2bFlOcmFIdnlmS3NRZ0kwanN3YW9PeDNyTFdBdlBXOWw3c2pSVWlIRU1mRXJYK1dMbVFnS1FRSFI4YmlLNWdaQUZOOXVyc29qeGhwQUU1Umk1SlpLazZHQ3Yzc0o5eEhGdHNKOVNMRXNRbnpXUWtUZkJVeVY1TzZVYmNYZW53Q2g3dnRnaUJ1cDF3aS9NMEQ4WWtyaEovV2RyT3U1WXM5SmY1aC9jZ0U1STIyc25oVmtzV3IxOEdycDQ5SHYvWnMxYXJYK2VOUHFTa3M1N2RSU1NMVnNZTzYzUzFJeGFESFVsNVFZamxINCsrOXNUaklRcWlxVEM5UXcrMkQ5NmswVzFNR20zMXQvNnJkYnJWdk9HTHcwZ3dGMTFrRkpPVCs1aTRPVWRRajAzVGNLcWtVWTd5VXBQRzVOSFc5eFAvYW0zN1d3ZGtuVkV0b0xMRDJITml2WUkrcHpEVHpubnptMUtmeW1pK042a3hReWhVWldSR1IvVEhlaG1OWUJWU3Q4Lys2M0lSUjMwS001bjVKaGJkd1FJREtGU3huTjJLeUNYT0pnSWlFWFUwSWxpNTdON3VpbWU2cVhHS1phVUFJOWI5VEVYM3cxQklYblYxUjNQSUl3aGhsSFdZdzVERFdUK203SDNDZW1IZmxqS1dpaFhDYlhIc28yUzkvalAvaXZvMWRUQUNJaHFNZGE3a0Eyb0I3QVJYeXl0ZFhQQ0ZxVW43VktyeXY0QXBjNHJ2ODlrV1JmcXNEUGsxQ1o5NTc4T1pTbVI4dS80YmV2NVpwRCs3QjFkdGJLL2lmWjFMM3hBajJUUnQyaFRlZHo5bWRNbzlWaVJXMDdrZ1BQN0U5dlVlcDh6cjc5djIyQ043MFU4U1FldHdYQ1JGcmJQVmZ6SVBjVXVoLzAyWURjMkdsaGJuZlU4ODkvVFQxNTVTQmc3ZUtDMHRydEhYZXRFVnd3b0FtRGVtdVdnR0k4S3dqT0IyREhJNlFjZDFERisrdWlWVTAwamQxdENLMVF4dnpaWEx0YU0wZGkrUFNCcnpLWHNEQ3JiWXFRbG1jRUtld0JLZW9rU0NKSERZaHVpZEpVaUk2c0lxaGhTWVRWT2tTVWNoNFFVYnJpZjhYaE9VK2lnem1ma1dGdVc3QURGQW82R3lsU1lyWW0vQ0xFaTNWM2xodisvWmMwc1QxWHk2K0dWVms4SXZEVGl4MHhnM2hzV1lReXpMSUZvSHpyUVpFOHZJdkoxa2htVVJMSVBGUkpOM2E4djFBcUtLKytYejU4UktyQkxMSkhSWVBSRHJpeDFRUStWQ0lqSkRXNitYcHdZQ3FVeVFpYm1PTWpmMU41blE2NEtEOVVqZDBWSi9DMlZQQ29mK1RXcnl4THF5Q1FKUHJiZE9neG1hR0ZWSGlCQWtZV2xoSVA0SzdLaGRjOFpIQ2hEaW9wOUlSMWlFTTRXZEdoUEpCSmowNU9sZTZJTmFXa2dTOVZlc0x0Ny9KZ3ZTcmFNWEVrOXI1eTFZY0J2RDI3VHc2ci9Xbk1YOUNLOXdHRDFQeU56ZU5vdjN0bmI1VmFYaDhVNlR3NG1qV0cvSXpoVWRLUUF3cU91VkZRME5PeXFwQ3FnT3NYTk4yMnN0MjJlMzFWa3AyRGE3SFM2RTVodnRXWEJVZGF3L1BMWVlsRlJjWWttQUVaMmI2emhlSDlCd1RDK2RrTzJCNENOY3dENWRsZ2FqYk5GajNEVXdtVDdwY21rSmoyZFNJVTV4RnNVa1ZGZlVxSGFVS3VkTmN1VjJjbFlpRW9BZmVtcEk5aUFrd3JMSkF1VWhqVWtoaXZoU3NlNVF4bkZTaVdkdmVlTkpyZnE3R3M0ekt2c05ZN24vWWpZNkFvbHNEODJhb0ROUjFPdlhWWWNSRVQ4eHdZZGdiRm9xTVBzQi93UFRuM2o4SDM1NE1jYngzcnJZVDlZRUhNR25YVnRhSEJVT2w3TTlReWRQSy82eVRjOGFETzFOUngwamxta1RaeitMb3FRVFBQZDF3akZmR2F4andCSTJKQUp5WE45MVk5eERYK2RTdWJHejQ3VnVHaGpnZTJyc0g2UDBmM3dOaklnb1hieGpLRlBVNzhDYTVUVWw2SlF1L3ZUZGdST21QaFFBQzhobVc2SDJKS1Z3b08vV1FkZzBjT3ZyMHpVVis2VDl6SG13QVdlUEIrVU93d01QRE8wbXUvdTJIWHJ2ZmE3bktHaXhTVVNxMWZYY1MyckUrcXQ2ZTRtS1YxM1gzY0F0Q1JLSm1EaGF3aEtSZkJLTmxRS2ZOWlF5NWpGaXlmeTlTUitsRkNOOEx6MEpoODlUYU1jcHhhZzI0VkM2WTl6TSsxUks4Y1VFTnFYb1ltTFlGVW9HQllrWGkxTFloSXZGR2xBeDR5VXc0YzBUNFB4UVo5TGV6Y3JVWi91clVVOS9kdW4zTmRIZmxMeGx3cFV6SDE0K2c2WExWZTloTjNta28rRFZPblJFRUMzSjV5Y2dmMjh3SDFpaDBOMURmbm5xOXg4R0lPMFRoRk56TDQ3STh5YTRleU5lRUR3eFF3bWhDVzRKOWxpTndMZFBxMzdDbEdTSHVkMWZmdWtQeXNEZGZ2eUloUjdmVkNEc0tqOE1hY2RSNTZaSkVCRExtcndzTWhXUHkzR0FaOEVlc3g3UDBlbVVpZXZxQVJtOUJCaVVzSFF5Q1lrQ2xyQ2twaTU1SDlLMzVnMUNocVY2UEwrbzdORm16YUxHeHN4bVVqQW9RZFk3K3MvYUtvdjY2aVFxWVVqUjlxS3lhZStUSzMvR2dNd3RLL1BicGJjdERlb2JkQ25kRldGdSsxbCsyc29neGpvOUhRdlNLZ2h2OVhTQ2lKSEhMNVd2WjZmMG5qUUZxcHZzbm5ENVMxOWlRblpFa0gxOThUTlgxd1lDdC9ySWk0b3h5aHlsb1oxb3Erc1BIS3Q0RWU1aHhoY0FWMGlLKzhDQnNySys2VTJib0pLdm9yNzgvUGt1L2trRzdkRVlDdHFnVzFBNnNROURYVlR5WmF1YkYybnJVK3ZYRXloZEhjZGI5ZDVQdUhLRDFqOE03SDVjOFNDaHk0djNVT0ozdGErWlNwclJndmZYR3pJeU1nOFV4K0xCV3BTR2lCTWdBY0NscUdtQWZEc1d0R2NPWlM0c1RXWVpsK3ZOZVIwU2JkTG12UmlVSDdldGY3dTJEQWZjN2dCMGowMC84VStIMThmQzdSelljVENpYWhKQXJERmtqNFY0N1pVb0xRa3ZGYXpqOEJpU1VoNFQzdHFmVFF3WEtYdWRJT2tLL3RvZzkyU2pCVWR6TlpLa3NiYTNpNkxaNmVvODNoa1hwZ2ZUbE9QRDJldm1JcTZZVWtGQUFvbUFaWmFiNlQ4SENTWXBwUWtpaWV3OFFlL3lTR3Bzd0t6Vmx1ZU8zM25uVVVBQzBrSXlrVzBTZGRlZ2Z1ZGh0OXN0U29IL1FYdFQ2bDAzajNNUWdvUWsyYU9nS29vcTIrN1NyODh1UVFiem5YSWJqUkdlRVpTTWNnVUZFRVFHd040ZG40aGNuTVIrNjBKMjRKS0Z3a3BvbjNSMDNxT2plcmJaVG9lakM5VnUzMTVMMDVER0tyeHI0bjRXb0pnMW5PZWlxV2dXNENtajFpM2t3ejZsakNYc3RGd0ZKR0VKMEx1NU1uTVAyeHNxRjE4N29LclBSNHZtVEYrdmlTa2hIWC9zVlJaR3QremYzd3c2V3ByejFHRXJxSEVLbzAzS0dESG4xbVJwOVNOdm1LT3pYd3FQS2I4dUs3WGNYMUR4M0RSd2VaSkw1Z1BEZ1cweWt2QzJOSnV3SVZxYVNsUEE4VWQrMUxYUFU4N3hpYjd2bmZkLzFwR3FsVHR5NW45UGJOUVBYeWhaY3EyK2ZpL0o1OE5qZGZWMzQ2dG43T01YMXFWVk9WMHFvbkpMa25YSjA1WE92ZWRIN3VsaFAwZlNNVFJNSVVoaDFHSFRvanBjRWJMdDFDamwwb2t2bmtBRWc3ME5vd1FUeHdVWVc3SXpZanBZSlNkRi9lVHJuQ21SMmRESDdXMFAxcGtlaU5kWEpOMlZ0aTB0cEdFTzNZckp2bjFEdzNkeGVDenp6N3p1STZTN3ZNS1lZRlM4M0ZDVThmZC9kQlVCOXd4WUxGdlMrUjd1aTV1T0M0a0xmalJ2eERYSGVLRFc4b1p5L2ZpYk1pNEdxZ055U05ldUtkZFBOOTlMMXB0RnBRWHg4aFFMbWJDMnRRNXcwZlkvTFdRNG9iekYydm5MK2ZtL1R2My94MUdpYXEydm84TjBNZHVDVkE3SVlwRnJmeWZ6TjJaalQ4VU9XaXlzd0U0MHVHd1NRaERoQ1lMSm1PNUlINW5SenhOTXgvTmJXWWsxbkgwdVpWN0tjOXVGRFJmUGFBYXBjWW9GNzlpZzVnelk4SzhYcGs5TkhwaVV4MnZHZzdPem5SMXhIUjF5N2JvdjBoalFxSWdxbFhKb0ovMyt5YlRKOTZldWRWQ3A3dlhzR09FYUowbGhpcnRFc1AvZm9rc2ZuMEw2K3N4R2M1L2xkV3FjaWhDTVJpR0NHcFh5MWdoQ1Vrbk1ybmlEWk5BLzJ2R1hWUjlQZHdZMnhPOGFXbjNOSFNvdk9MejA4anUvNzBKZGt6WVpRN3gyVkVyNWdYak1ZdTJKeW9EOEo4TVA2czNvWUxqS0ZnM1F1TFBGemptY0hKdUhoVWkrbHBJSisxZm9tUW5KSzJFSkJZUFlkdVdhai93WGs3cTVQckpNMjJsNU1MZkkrbzlvN01tbTBmK0l0K2J1dWVYam9BZ0ZRUGN3TUsvK25sazZpanJiRmdaRU1qUitjdXpKMHEvVlhyNTh1dzRtdUNkOWZEbHpJTzZJZ25KUTU5OGJ6S2lCTTVTdnlMdlJZQXJ0cTNLVTUxMzgrSnRSSWVpSE11d1p4VVZWK3ZKUEZHNEJ5K0pXWDdMVGhOQjJnbWhpbDV5S3pUUmh2MFJaSVlRT1VFSG9SaHhlbEp5MVpsRlJjUDN3ZksvOXVMdE5oSkp5WFNoMDBqUUVtUkxSSm9tTHdmYVhMRmZ0YTJkVTRSVkwwbFZ0ejBhcE5ELytxamlHcTFBN2JzOVFGL29LMVh0em5MTmdBVnoyV3dheU16Q1BNOTV2NGU1bjZJVlM3dXNvRDdPWFd1Z3JJYkJKY1dDdDFIVVZ5N09xNjFVZnE0aWFOWlV1TkJOTlpIeG9mR1QvRnhuakdTZi92U1hJbTkvTzBPaXIxdmFRSVc1WHhCTVJ4eWJ6aXo0c014U1MvMUxTU1FyaHgzNEVZUW1OOWcyaVUwWWFkZFE0UmZmMmxpbEthQXk1NGw2TGJ1ejBiTjR4MHV5c3A1TjMxbTBPdUZkVmtLZ3lMemVyd3VlUE5kSWtkcmV6RWpVdVBuR0J6TnozTmlIUDFaUVludmhRa3hyK3Nsakcrci84VUJaMXlaSzB1L1RJLzNLY1hEdmdYTGFZNnhlbnZwNnFPYVpWN2pLQ0o0L25LdUlaZTJxa0dCbEYzS0U4WUlmTXRVamR0ZVJKbjFFZ0daeEJuaGxUcTNYdDZqa1pXWFFNWm0xbFY0L1dCWEtnTUZmWldyRm13NkkwTWxPNjJudW9Gc1ovYno4TThsSmhUaUFqWmpGdjVtYVgvaklVeUlxUm03Ui80TWlpTG8zRjNGNDFiTVIvTy8yL3h1UW85OFdsMzg5UTJjMkdiQ3V6T01OTTB2TGszSWJYa3NLcjI4cm1FaE0raTE4U2NZTk5XcUdPWldLVGw2c1M0NU9vd08vYXRIK3NqSXl2L0Z6MlJLRXpFbzBsSk9HdWRlZ2pHMTYzblYvRFJRRzdzSTVqeDFpZGpYV3hzMEdMaUM0dEJHMmI0aWN2cUpDOXNvVnU5TU5EU2VncG0xY2VCU1FhQnUyam5sM1A5TzlPR0w2MWNEWTROT0pjdGptaWFlbTZwdlRJOFZkSzlVTzlSOTltN2Z1NHY0MVF4ZXJDcXJRYTU1aGxaS3U1M29rZHBKNUt0Q0dkVE95UVY0dC9sNGxVVmdsTjVSNU9xUmEvbW5JaisrUDJqejlPTk5UcmFoYjhPTVJxVFlnM3k0SCtTc3hvWWNWM01QWFd6dW1Yc3FLYmR6WXRHWTU1VU8vM28wRy9MR2JFM2NqemNQdVR6YlkrVVN3ckk5Rm5ON1ZrMDEzNU14aGlhSVlINzh6UjR2SVNlQ0p2Y3VpUGpzRkh2VkllRGU3MmIySlBxclJSTHY0RTNUUGF4ZkVLMnpEM3BoY3VJcWhFNndxMUltT0VDWnNFcXFTNlRRbEpubHE1QlJraytaeklJcnVBUFNadFJTejd5RkNza2VtY1JEN2tJcUYwRitxQTI0a1JrWHdEdjJsb1UzQm0zU2t5SDFleVltOE0ranZSeG9sdWVoL1lhblVaRXlhNE9EaEMrcWZlR1lGZEhNeVFDRWFBSGJtVjdKcUpkQVY1a21YL3NYdjYvSTUvOFdmNlByTzg3V0ppT2NKeDdGTTg1Y2IyTXVPNnFiTUI3em4zb2wwR01tOEhTL0VQRTZjSmdidy90a1hhUnd2WlFxeFBWQXYrenlzNjhNZzdnYktTRjlQWWlDNEo2K0xpeUhNWjV5S0xjVmJ5SXJkbjhTY0ZGZit3WGV1LzhWWEtWemY4MnUwL3dPZTJlOTV1eUdUZWZOTllGK3NQbG1zeWJHZ0x0clhWTjBVRi9iRjFYd01LeSswQTEyRjcwZEhBODNaSzlVcTZnUVhoMnlTM0RCMTVFRnRzSDFQTXVXVnlscDZpUGFjUjAxY2ZOQXd6MThZMFkwZUJsN1oyQ0VicWIrcnE3RUtEdmZpZVpEOXpqUUREUHQvMmpNUkx4Q0p3RytTNEpUZGMzTytWdGlySnN1a014QmhoQ3lkdzc1bkFIRThHMTUvZmFMcUdaVHpCYVRZaUo5YlBpQzQyUlJFeDlkNXhTT3BFSVI3QXNwSm1jd1JLYXVwellUNDBCWjVkWDM2RndkUGZoeXdIeHFtaHZ5WDVSbEFHN2I3UjNIems3U01qL3N5OS8zOVJKUWY4VllMSkI5QkJlTDQ5Y3RNSDZJTk5mbUdhRGcrZHJYdisrYnBSdFl3NzBvbjNXT1gwckNta0ZIUEhjRWVyNFNrSFZhOUp3RnYzSldqcWx6OFRraHVpOEpvMkh4c2U0S3ZLcjZlQ3NhVW45NXRhTkxYcnRBc2lLNnBNRXRaQVAwTEJHZDBXYmJZQzBuQ3U5by9ZTWo0NXI3UnNlZUg2OVlYTFgrM25MY3R2Zk4rOEJrcjArL1ZSczdXTVprS1Q2QjdNSEhRbldnWE0yclovL2lxMXI0VnhTdVlMeS80b25KczFyM24vejNoWmJNdElCT3JPRmlPNWY2MnByMStpMXQ5bzVxaUFYdjNTaG8xUFI1OHpPRHpET3pEMGpiNU5nVTE5KzNPTms1T1NSQUpaeSs0YndQbkhIMTkyZW84TU5sYXZXdVBsa3hPRGdwb3BxSU5JaVVxMElGeGs0T1ZiR3h5Q3Y0OExZczRLRFlzejBsVllqbmxmMTRTVDBnSytZMWdVdmU2YkNWWVk2bFR4S2hCbC9RcFJYQXZNbnFYY0UwUmlsaGFobjcwMm9qY3YxTitaNlFFOU42VXhTdHpVYzBIemxuY015OUZOUnZMTFNUVCs2MVFGNVVudE9ZRzgwbEpicmVod3hEeC94NzU1UXhEUXRGcjB2elJkc1hybXNlM2J6dFJyUHpaMGRYS05zWW5mM3dyUEcxbENGQTBOYkIxNEVOenNqSWROV0xjZzhTQXhqclBLMW9taFMweFdlVWFFcEJXUUZqY0E2SjNSRm9DSHVOQndyZ2R6SEpLZkZGL3hHUXFOaVc4STM3Q3NqSnJyUzBqNmN4Y2hlQzJtVlF5VWVONkNQU3NFWm4zSXgzS2M2S0ZPS25EM081UEh2S1NYZUY1c0ZXUUFzWG9pTVJSWXJjLytMTjFiTTgyN2x4b2VocG1MMXMrME41blpMVW1mWlFESUt1aTJaMzJSTjd6YjYrK3IybExhcXRMMW1VZmZ2cDM0VUVKOXVqNjlCN1NWZCtEVkt3MVhWbmtmeW4vN2R1V1BVNmFIYW5WVkNvQ1U1VmZmNUNIc2NleXp2NkNSNDF3dVhQUFJSLzRrYW13Nmx5d0Iva0VCSEFFMFlMamt2cENXaXB4VW9mSWQxUHVINElOTElrR0J0MklIZEJCU1N4b2FsQ2VMY0MxeHlQb3Q0US9XUEh3UUwxbFRublh0aWE4RzlRRW1QaEQ4SVJEUG1IZTh0ZlhaQ0twb0ZhT1VFcTRBQ0V0dUVvcWtRcnNxRElsdDJkSzY3eHFpT2NKS1NHS3YzMzRCWUxwWHZjZzc0ZjgrWm01SE5xa2R5d3JUT012U0p0M1BSL09ZZUhlSVV3YVlZY1Jjdi84SFZXY2JURzVMZGZ6Z3Y5dWZaRlM0U2FHUXQvVXFLNklEdVdORlN1OUM5V1dPWmYzZm1vb2NMRXU2QitlYzJ2OWxqUjJTQjJJV0pBRVFoOVplRHRlTDBBL0JjZ0haZDc0L3BFTWJaMDdQTzZYOXJqaDBJVm9ZV3J6TGRhcEVhWTdUZG9Rc0NsMFkwaG55Y25FbHB5NDJGSFVXNVgwT1hERnQ1N3hGZkl1c215amRzS0YwY2ZMdHlrcjQvWnhBZkVqMC9wbE1tVHF6YWVTd3BiMDI5SnBRY0VwRTVEeFBtZ2dpTENIcGRZZGdFSGZjSlFWbEM2NmJwWWdESlFJQkhxdG9KczVPVWlvZFE2M0IxY0hDd1phNmNCNG55UklRdDgvOEpQZGMyZlYwRkZtcXNPODVHZ2pIWjl4VDEzeHEvaTJWQTJib2xmYXFta3RxenRUdk9RNEZPNmZCN3EvN056ZE1aOWdtZTkxU0lDNGNBaGxZVGhGN2FldVZUQk8vZCs4NFRlYVZyUkt4SVI3dEV0dW11eUpOUXBLdk9qeDdCVUpEekVHaERLY1dQZjk4RVVydk9JdlcvQzVXZVNxRU9SS2k1M2cwNkhiL2UxcEQxMWJhYk1Gc2t5SjFCWVYxdFFOMWRRTzFkWVVGQ3dqY1Roa25aKy9jOWJDMzJsZWg2aFVIemV1K0hVcFl6QzlPR0ZvV2FUNjRBbFZYOWJ6MWYrTmtQZVNmVzVqNG16cjBkcG5oMC9UNmRaZlA4L1NDNG9VTG1uNGFYMUJpK01SUWRodDl0dlAvQUVNaEhTb1dOVGpzL3Q1clhPa3kvOTRjSS9FZkhCMC81ME5zM2F3UnlxWHA2YUc2UlhWRGE5cGFhWlY3OXV3ZDZqVUZwZU41VUJnWW9Qdmd2c0N5SVRqRHNjUkNHQVV4ckE4bjdYY2Fna0VMT0c0MWU5WHJNS2R3MTZ3emZQMjJjUDloWkJQUklZeGtUVTQ4N0NHRUJ3M0M1dkJXenc2NE0wNjRNM2gvUmxXVlB5aFBWclRpZHovYTNFRDZ6bGYzQzRGd1FoYU5MU01KMFdKR0syNTlqUEFFUzVZeGtRRWd5eHVXSGdSdUV4UzJFVjFDV1k5QkRHYUlzakl5UXJaRG5KR2c5NStpNlpReW1WbUVHQVJ5MlJkb3lTU3lNanMxaVdZSDJOR2dtVU9TU01YU1VLdWUrS3dQTWRsWWVDQjhjL3JBbVVpNi9LbEtRY1VSRmJwME1JNlZvdWFNczhvbm4rUkUzbEtBTEJieHdwTjgwM0VsZEh0eEZvby9laEdnL01WbzJKbnMvR1lFbXIvNTFQenZWQkhhajZxYTBUZDRrZGQ3Tll4SXUxS3ovN2ZaMWxzc0hkby82USswQmdyUGNBWUpRdHZHQzE1SmdPV0lVNit3MUErQnM2OWV5OGxGRjFoMTZPeGdPTEljbS9wWkhKNFdUbk5LQWZQNGxFUVhKVWxhd29vaHE2MGhCWWpyencyWTdKaGcyVDZyY0Nod2tEb3JZQVVSb0p2RU9SSmhQRmFNS09ZZ2MrdTByVHdobVRiMGIrZ0x1MEk5RkhpaTlMaUcwUnczdkJNUzZueVk5NjIvcHptaG1lSE1BTmlOWlpQbUVRSjJlWkw0QlZENmx6ZGFQcG5sdi9pZWZZdC83YnF4VjV2eElIZnR2bUV4YTRzeU0yQ2pqdkY5dGViTml6UGJNenMyTDNvenQxdTFHSnBTMEtWV3VWNE1RRHppM1NNa2pkNWJyNHg4Q0Z4ZzNzSFp1UzVEZkhkSnpKakdVcXRXNWM3bXFtTGJ5M05sc0xEQno2Q0JNNzl6b25qRnhTakhnWE9yb2V2ZVgwTXh3alJuSUpoY0N2VDBlK1lTZlhWbkhLZjRsN0FrdktsTFNNSXpGWm1VU2IrQlUyaUtCV2U5YnVKRklsZFUyRnJEcS94M3A4WjdZZmJGQ3JRWEsyVm5xQnREam9jQ2FHRzVUTjl6ck04UnRValpPYklQYnpFa1JMZDRHZXNhVDRhZ2w1V25vbncwdkwrQmdpaXExdEdLcUh0NFI1Zk5NREtXOWZqQ2JXR1QxSkw1OGJuYkR5bHJPYlB5aVdCZVlxS3YwUzFKZFcxdVQ4S2s3VjUya09PcnFBc21sOHN1V2ErL3E3SnROM202NnVFNWJzYXExZGNxd1hHd2VyVy9wZm4xWURQOTR0RE9LSXZoaVczbEhVdzk2bWV2d1RsQ0swcEpSZHpHRlpVVTlLQnk3ZnJtOWlBV2UwVzhXNnV4UjVTVUNEYi9GbUhmQUs1ODQ1T05OL0VZY2t0ajJKUllhNEhJaGpCcUZNYzkrcWhmRkRYNTdyc2hHWGtCVGpMQ0VLQWt3VStCWXpSaWZyMExPRzdUSnZSVUYwYk5SZ3dPd3FRQk80UUp0aU5RcURCallydW5JOGhJVDlGS0pVdXpPQzlOQXlLWkk0NXoxYXlQQlNBN2JZY2lOQTFnUXo3QnVrU1VpRTlNSnFuUG9JdTkyN3k4a1V3Z0hoSE8yaUk0Z2tSME1RRUpzZkZRWUFYQ0V6S2o5ZGg0dzJ6OUVtQk9sRTROendGQnNJRzlpYzlKYytLUFlGOHpNRGhZd1dWUlJYL25oMWtCSE93ek1PdlhQZWZrbERMMGduTDcxOHhYRVZYb1k4YUw4WVZBTkg0Zi9NNWtjbUg4MkpqOHQzWW1jNW4vN1BKYU9QZDc3WlB1ajFjb2wvbjdzMnNQT1A5MzJSdm03NnZVQjVxQ011dU9peUFjeUdHbFlrZ3hCeGtXT0IyQ0VCM05yY0kxWVZiMEljQiszVC9CaENVc29KUVZGZ3ZjTStOeFlkQ0llZXdMay9pcTR6d3dXRyt6M1JTRVdGSlhrREh2empKbFM2dDFTeE5YenhsVzE5ZXZMcXlySzh4bkNBaE5tMGtTa0lHVlgzbHFYSmJIVDFYVUhrK0lKbG9MUWRLYWUwSHFacmlCOTVETGtwK2RVSHp1QVVNMFZSbStJUlJLaS80Wmo3RFJaeGhoTUNRaGljY1NGcVVjYzhQTkhoYU5NVDFmMFhxaHp2cFFrYkhUOWlnQ1kwckhhRXcvSWM0TVFEN0dHbWxBcmVuUXpHbkhtRkhOaFFzMEkwQkg4R0puWVpPTk5iR1p0QSs4U1paNGlXVjlMT2dUOWN3K2RXTC85M20ySlM4ZUxmUnNUMzc3WFgxeDIxdWJTc2Z3R0Z4bzN2TE8yL3MwOWZSVGcwUjdidVAzcDIxTG1rNGVmY0N4NHgveXlKZUJmZWl4ckUzZlgwc21idW1IckVPTW1vRnlXQnByY2lkMGtDZkdSMWhZcE5IZy9wOEFvTUc4aWZCSEpyYkJHY3FDMkwvcmRYLzh1SC83ZG9mZit6RDJZUVVpODM4T1RBa0NIOTZoeFV2dS82WTlwdmhIa3BrSEFBQzRzYlFjR2VzWDdyOEhvb2IvQithaEFDWDkvNkJ5UVB0dmVlZUEvMVBhWlFqOHJ4SlEzV2ZHOWJFd3Bsbk1zdVROTjFTUjNkNkdKYUd4TlBudUxiT2puU3doVXE4b3RTTzc2NkVUczFvYWdNdURZeGFBRExIMkdrYUlyR3kvc0IyTDhoK21Bd0MwMGZZM3dodW00V1M4SUlJUFkwaSszMDdXaVBGVE93UmRmQ2pEeTUwdTdxWVB4NVJmV3lFQWRJdkZpeEdCWHl1RW5lYmVpZW5GcUc3VUI3ZzhnWlpoemZqUTdWSUFTRGVTZE9ZdzBZYnNuMGtpUmYzcTdKQlVSZTlXRXdiMTRPcmJoY1kwTFFLc0k3WWswdVo5dUN3QnR0dXY2QTBmV0VQTlJBR2lTVkZuWXZtSlFnYm1va0lGc1E5TTBBSllOME0vclFYNkJNV0tTLzh6Qm1oV3hDd3dpZlY1dk1DUG5RUUFwMkRITktJRWVCbWVDUzhrc1JONmNKS2RSZUpWZ0VlS0pzbno2WVFJSEE3UXdpNTFZcDBGclpFbjE0QTJFN0RMbDZLcDRQaHNJWnFDU2JVUVMwejl3bGlLd2gzYWNtRWRFU002dWJSSTdMaGFGSFVMTUlTK25YaTN4MUxKQUUyTkl1akRFSDlRaE5lRUNKVmZpVFMwWVNDM0tIbkZoOUNLRzJaZzRDRndNQ1pOa1FqY2ozR0lIb3d0OGRNODNjOHVkUUllNVdpWUtPalBxeU5zZFJnMlkySXRHU0FrWEQ2R0JxQXBpZ28rNnhOUWd1MGhYZzVBUnlnS0lrRXZ6Z0sxSkEybEV0dTlISkZXQURUcXVNQjlSZmJDSk14STdOTlozRytQakRZREZpNUthc0p3WkZqbUNXSzFQaHpNLytSRjU1OVlGUEw0N1d4MjJ5Sk41MnZaWFFBNjRHc040bTRvejRmeGhqOGZZVHRhUlB2UHg3aGUvZVJ4K3AvamJkdjM3TFJ0Mmp5Z1daNmJaM2hxbGR2eTVwdTI5T28xMWYzZDJkUkt0bERYTkl6UXJxcTNkMWZ2enQxemVrLzIyczZCalcxRGdOdXJ1N2YxaDdodjN6UzRwVk5VMGFDQjFkNjVxSmVGbmUydG1zTGNLTkMxbDJjdHkzQ1FQZkZRZTVjRlpKc29EOHZPVmVxczNKZGxjWkwvbC9lbGdtT01Wd0FBXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zcmMvYXNzZXRzL01hdGVyaWFsSWNvbnMtUmVndWxhci53b2ZmMlxuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmMjtiYXNlNjQsZDA5R01nQUJBQUFBQVB4NEFCSUFBQUFDbzFRQUFQd1RBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdvUmlHNEc3VEJ5ckVBWmdBS1JHQ0ZRSmd6d1JEQXFIM0NTRyszTUxsQjRBRW9vWUFUWUNKQU9vT0FRZ0JZZ21CeUFNZ2tsYnkyZVM1blFNbUZwZllLMnNwZHNRcUhlZk0xVlRlQnpQb0RLR0NaWEIwSHQxanRVOWVKUmNhREVuY0dkdnhIRGJBS2htYlU2Skx2di8vLy8vLzVjbGt4alRTNEJMOGcrQWdpSWlhbTF0YTUzZEJpbzBHaHpoU05rQ2RZTTJkVXJmUk5iTVZIS2piRHZYc2h5VWNkeFIyMWVTVTZtNUFsbHZ4dDFoUmthdTNsRmRrRTVZWlZUdnJKTHBraEpxSkgzVVdZR1QybTh2KzRad2pvSWh2THdqaSs0djJtU0dtbUs1WWxwNkxDa2hLVzhHVTh3UVloa2pjSVB2Ym1scHRCSHZhalJxKzZGdEoxUHZVVFM3YVlaUDFkdDVVdXBWNnl3TEYyYm9aT2ZlS3diVGlDL1JCQjJMU2ZLMk9ha3owbURJNmZzeGpDSUNNVXNUaGtrWXdvVWRpY2JaRXluTWlKcm8zTFNmalpHa0lBa0trcEtDa2lLb0draks1NStMWTBkWjcrWDlCeSs0ZEZnQnE4aDNFak9JMXpLZ3gwTjRnYy9pTFArSmVJcTJ5TFk2VC9XeUhzVEtLL2JsaDA3VnNDa1NCVmJkbFlPZ3VPRjNuYWszeFZyMWNFMGlVYndxNThmYk5zZmJ4UUtOV0k4Qko3YTNEMGVBZjlQZDVlRFpIM1IyazYxTWRiZEQ4OGhMSkp3OXpuTFdqYVhzNUVEVlNscW4rc09FNDJ1TWI1R0V1OSt2MDc4YVYvd0hlMm91cWZpQWwvS1drT1N2dHhveHE2eGNndzFxalZxYURaUm02ckJ2eTM0TmlIQnNEa0FWa1ZSTjF3M1RFbHNjY1cxUG01L3FGL3JuK2JtY2MrLzdQNWhWREsyWVVIZFlFNWE2czYxbnhTMWJGNFBrL1R3L3R6L252dnZla2dGandoZ0RSdldvRVpWMjRlOGkwMjVLMEFhTE5ocjlna21hbUFVRC9Eci92UXVkRzdOcXNUSVdXRmpwYjdiUDlCaWpwK05FbmJ2REhjZnBlRS9kY2VwVTlDSUhhSnNkWW03cVZNeWVtVmhnSWFpQTBSaVVnUVUyMmxnWW1JZ2RjeE56Z25QcTVuUnorODFsdXZoRnUrZ0JjRnZoYkRDT0NBbHhjWmltalVVT01ISVNJcEVpb2FGaTByN3pxRnkzcHZQRzlPNXpIczU3cGFYQkRUMGlaSXM0Y015R0taZ01aU2l1SzZpZVA5aTgydzlpWVpBRS92OGZzTjN0dnhPbUlVV1dCVUVGSWFIQ25ISW5ncVpORGlTMFBGVXdhVlhQSm9BN3RPT0YwVDg0cCttTzZEQW5DZ3dBMndPN0ZZZWxBUmx4WjFnNTFqTzZEUkRnaEJVaVhMTlFDVERWZllZSU5VWnNoTmFuUXlkbVFpOGpJQU1HQ0g1NE4rMGxzSFNwbURNcUxvZ0htclFFcXdsUXRRQTFWazhuU3JhVHdvbis3ZXZ1Nzc1KzdzdXNDUUlHQU40NzEvZmVHYkg2MnhQcWpFRlZwNDhjZTlZOEJ3cTdIN25Od2srN1hVcTc2U1NacHBrRHZMU2xBZ05SQmNReUFKNEJaVnFEZnZ5VkhPSXlySHZTQllDS0tuMjR6S1hPLzMvdFNwWWxHYUk0TWltSzQ1TWNvTG43aURzdVgxMFJmc1JVSDdnRDlFNmZFSUFTNW15RmJRZVlYWDVJaWlRS1Q4b1JHN0dSdVJGcXhtOHVtSTFFYVF5NHMzejhQZDhIYVd4Z0pNLy96eHZ1KzFWSUhNTUl5bGpUN3lWNWtyVVdKYnFxS3NCTTVIdGQ1UCtoNDJsM1p0NEdCVitQc01BaDlUMndEUWJKdXIrcDNLeG5FcUNhS2phcDI5TkN4UUlWczV3cHZsVU5WRDR2Vk9aZjBTL1BNMDExLzM1dUIzWEgvdy94dW5uQ3AwRExsTG9RMFpLM0lkZXQvdzJ6UkRLbHdpWmJWd010ZkZET2NvTVZuZG5YQ21rQitNYk1EYWNVeG9sNURKVzc0ejlwVWxKcVdqSWcwU3M5SGdnTmdJcXdwSUNWZnk3a2NNOGpKQmY2dnByUllsTE1ySlJJMmROdjdsNjMvUnB0Q0VKWWhOQ1FFQUszLzdmTXFoL0daN2lNTkxheXNyS2NTbXFWcG8zYjNkT2NzK3ZZT2ZWNXFNWG5BYk9QNjh6amM0QVZnQUt3RjdBZXdCcisvOSs1L3orQUFRd1pFYm1LS2QwWEUxYXZ0ZjIvNmw5YnJEM0hHZDUvT3Z1K1NnbW8wa1ZXZTFLSVA4Y2JNTGlOSTJCci9QeGYyOTFJcW8xa2RtQnZmd3huSDNLUVVJZVpiS0t6L3dvR0xGbkJ4cGk0Yk1ndmQvK2E3c3ljYXNsckpsMUR4d3Z4RTJCalZBNXlOZmR2d01GM1VBZm9xbkU4NGU1dGtsY2dvWUJWcDdwT1ZaZlZBOTdqVXBqNGR4UFRkZ0VRYmEzZjVJUXkvTXNMRFNzTEE1U0hyL3RYVGRyLzJsMDZXTUE2M2cwdHZnM1FBdVpqcVVzcTlqRFlLVmdqaHYwL1ZhdlNLZ0tjQnQyT0tPMitsWGIzREc5UDUweVFUYzhaWjVPdzhLc0toYW9DYUFCUWFvS2lEQ2xIdFJXbE1WS3ZJVUQxTzFMZHQwL1NlcCtkY1dGTHJmVStQdU9EMUlZK2kvUGpBWnA3dGNtQWhFR2gwUHZmZDFRZ2NCdExvRngvU21va0ZicXEyUWxqeHZQL2YrLzcrdmFZbHRDeXF3RThJeTZ0bkxSK0tkYWFSU2pvcFgzNmZ0OWMydmw3VjVnQ3FYdFZGOWVzU3J4THByaW5Da0RyeWlSTXBjeTVJa2xBZTFWc2pDblAvLy95UytuYmttei9nZ05ZWHphZnFRQnpoTHorbng1UG5TbWxjdTVwcDlBUFNya2NRa0kyWTY1bDFITHNaUUNOalFRQThUTG41Z2xhNDFmbm9UdDRxTmUrYUcrSTdlY3VMQkk2UkJxOUVrbVIrZGVacnZxbkVOTGJGWWEzZHhubGY3NUtzdXljN0NNTVcyR1dmZVN6UTBTYjdVTndnTmhKaVhBRVdvRzNya3VZMTA1cjk2RlRlZTMvbVdxVi90OU5jRVNBT0xKTHN6WTZhNE9zR2pMMm5JbEM2S09iSCt4cWdCSUFqZ0hFTVpTNHptam1qRmY5NnFiWTFhU1dBTFZHbk4xM1dwMnpQZ2t2Q1hhenl5OE1ibm5vbXphZCtkZlhtaFRycmxHR3ZvNEl4OE9ZbkdvS0tVRjVJZ1BvZjA2MC8rQVg3cFZFU05QV2xNV0VUWXRkcWxvdGxvdWRzd1JyUmhDZDJCMDl6NCtwdnUrdVpGZjZJT3hBRnJCT3RDNVE3K2VIRUZwTG4ralA1WTJybjRzRmZML2x2OUs1czI0ZG91ZlZwZzRrK2VPelJ5NnRzQUNXSUV2YS9XV1VPa3A5UnFFT1lJRUJHQm4rUFluSyt5R0JyYnNhVldQMTVtSlVmU2RXN3o2N1RYcE15aXhMR0paZ0JwRWFJNHd3d2doalFnanUvS00zaU51NFI3Q1lqUVpMa0hFTXhrRnRHbVhXOWp1TExVU0NCRG5ldXBUTXBTaFRmRkZHeEhseDFob254bGhMbFY3eTBGTWVLTzJ4bi9KNmNLd1lIakdBWnFDeVR0OWFiYis3ak0xSGxvWDJiNzJNMmdBdmRYcHlpSndDMnl3ZzYxOVFHRHVzT2F0ZGhyTi82NTU4a3hPZlEwdUxCcElRNkhhTXpmL242djJJV0RoMUxTWnh3QVg0bmozOS81TXVsclBvNHFudnFuRkZWVlZGUlJ3eDl6TFg5L0NhZTZXN3Y5VHRnS0FnQVpLUU5zbE1pbDZpeThZbStkTFNPSklPbDBFM0dHemNtb1M2VmZmejd3cUNJQUVBYkVzSWsxa0poRVNZQWZuZDc1Qk1tWkJzMlpBOGVaQkNoWkJpS3lDcnJJZHNzdzJ5U3gyR1JvMlFKczJRRTA1QVdyUkEyclJCdW5SQnpqb0xPZThDNUpMTGtHN2RrQnZ1UVByMVE0WU5RKzU3Q0huc0UvRkZuaGlUQU1VZ0F5ZytDZ0NsUHdVbzVaU2dWRE1IWlRrckdOblBBWlQ3UEVCcHBnSGxOMzlRSWZNRUZUVWZVSEh6QjVXeUFGRHBDd2MxZlRHZzVvd0FhdDVJb0JZdEVWVEdVa0I5c3pSUTM0MEtxaWsrUnMxdElMcVNIdXBSQnFoWC9VRjYwMStrenhYSWdBalFHTUlBR28vd0FFMUFSSUNtcXk1bytzcEJVNmdBelZaYjBCeDBBTTFKSjlEVXVvTTJVeUpvZi9nRTJqRFpqbG1ScDZ5c2w2MksxNi9HVDZ5Wno2eTVyNjcxYjY2ZEg2d2pudHVIei9ZWHNJTUU3MUNZamRXM0IrenZRei8zYjdBdVR3bVAxUUlFSVFCbEFOdENKT3l5eTI2N1ZhdFdvMGF0MnRPZDFheG5BOEx5dTIzcTFCMGZBcFRnSmg0OTVKdTlBNHJ2b0trQ3hhK3AxSUhpTDdSMW9FQUJpQkVDUUpEQmZ5MFRTTTc2YWVwQUJoQUFDSVRBbVE0SUlQZ2dRbGdzUlVNK0trS0l6RGo2RE1nWlVqQ2laTXlLTlJ1MjdOaHo0TWlKTXhkcXJ0eTQ4K0JKdzRzM0g3NzgrQXNRYUw2Rk1tWExVYUpjcGFVYTdkWEl5MVdvVktWYURRaHN3S2xFU3VqcEd4ZzZJMlZ5STRXeGlhbVpPYVZVV1hDTnJnamR2eDVlU0YrLzhJajJ1eTVOMU9WcXM5c0RJQVFqS0lZVEpFVXpMTWNMb2lRcnFxWWJ4L1AxL254VERDZElpbVpZamhkRXlmRjhUZS9QOS9lZmwzVTdUTXRHbVFDaUdRNlgyeU9Ta0pLUlUyQWdGVlYxVFcxZEx4Z2NnVVNoc1RnOGdVZ2lVNmcwT29QSlluTTBXcDNlWURTWkhSeWRuRjFjM2R3OVBMMjhrU2cybHkrVUtWVEJzL0xscUlMcXlTdkNDb0FBR01LOXYwQi9LUUQ2OC92bDNYUnJ0ZFprV1FQL0cvVjJRVjNobnBwSFJRZEYrMlVLUFBLeG1pbzVVakxERlM2MlBmQkF6ZVdmQm83eHFNOUhFQ3I1VjhaaXoxeS9ZV0d4WFY5SytyYk9vOFBJbzROU01MYjg3OHpyRjh2OENsT1ZwYnBSaTFCT3JhWFdRNmhDVlR1dlErbFN1MVhkK203TG9IN1FNcmd3UkF3ak1JQ0I4VWtxYXNkTlkrekJuSnAvc1hWbjUrbHpNSkNzWE1IV3dtdjgrdWVtRDRuYk5EaGJlMjg3OWhtTVB3UDBacTBiZWJ0UUx6OE5CanpMN204VUtGdzU3NlNvWTJ2WHNnZUIvYklQcUxpeDhoaTFhck4xdGJ0ZytqQTNGdU96aWJzSldKMWVhVzlhMm1Pb1c5RVhOR0x1MXpEYy81SXlDbmN3c1l6WmNiL0dBd05YUkQxbzU4QlNUdDMvMXM0UzJRVUhWU0ZicVg2V2lnNVE4S0plRkVDSlJVTFBxcUVJV1RobGFnZkU5Z3JsVkJPUXV3bjhIQmJ0UGVkR25IQmRHMVlIVGk2eCtOOUNvVFF3RUZtYW1oUENyVk5uYlZtM0IwNEdGR2twaDd3WHNVVXlnSHNDV1VselltZnRBc05CRzdBVVVSM09keDJjQ01SK1YwQnVySkRDNkVNRjlSMmNvSE5OM2ZLT2Q0VGk4YzNCUGROSGl1bU53alUwRkZEVVBzd05nc0RzNWxscnlGMUNiUWZtZ01IamszSXdxTlY4SEd1amdaREJzcVd5UWRmeCtFb3FmT1NpenRqY1hqTHI5UnVMK3IzS2dsUUR3amEwMndpUXRvZ0lNUVM5bHhRcjlsZ0N6SmZvU2tNTGIvemZPTDZDNklzUVNTbEdMQlB4YjFGSmFzMmtTR2R1UXF4TmFtMU1NWjJ0bVhGVUZDY3I0bXo5ME4ydmkwWUhxQjF5aEtkbXpid2RjNXlQazFyNGFkTWhRSmNMZ2wxeFJiU3I3b2pSNTVsMEwveG1pTGYrTmRRblBUcU5IbkJtWUdUaDZ3NmdFTDVMQXJYZyt4U240SWUwWjg3UG1VM05Md1V5K1QxNzhGZU8rRHVuSy95VHh6ejV0MkJENW9VaTY4SS9rMzI0eFpCekt1WGZSNDNDdTNVekpYZW5hYVYzdnlmSzcxR3pLdTUxWmxYM3J3ZzdTYUxEaWxrWVZzOGFhK1oxd2RvaDlHRmRSUTAyekxjb1l0TktaTnU4emcwNHRLR05PckdweldnYmZ5ZWMzaU54WlkvcFhnOVhKejEzYmZJTktLTkZYNllZM0ZPRzlwemh2ZURlRnJpL1JSN015TU9aZWJUbGJqMjBMdS9IT2VGSEFoOXo4S2tLOExrcWZLa0dvelZlWWN5YnN4b3dXNWhSeHU0SHh6SXVlWTlqd2tKTXFvUXdreXU5NENrMnY2UXA5WFhwVSsrMzhxWlYzdFdsWGRuMVp0QW1rMFBiNU5nT1FhdmU1MVJwSmVmM1hOZnhnclZ5cXlGYXU4MlMyanBGS1oyN3ZsSzdZck8wcnFQejNieXptTjIrbVRKNmVQTmw5L3owWGU3VkdidlNoL3UxWVgyNjdqcjdlN0VMcVFPSVFvRk8yRkVjb0NzZW9TM2hFOXN5Q1IzNWUrNTUrVjdRcmNBSEg0TFpjYTZXQzVkb1BIalc5UHpONlB4eTFpSlFhaFA4OTJ1SGsxd0hJbUk5VXFYVksxMTYvYkxrTkNCUFhzTUtGRFdpUkVuanlwUTFvUUxjcERwMUxXalUyS0ltclMxcDE5NDZoczQyOU9wdHk0Q0J0bzBaYThlMDZYYXRXV3ZQaG8zMnZlbkFjZUdJNmlhekJ5UlNIKzFNWXl5T2lEd0lvSUNSbUh1UFJLY0NHVDU0VWNFaWhEamV3VzhWRHJYcm9ZTTlqTW16Rjkrb1ZsZkR3ZDZvOFV6MnJTSDRzNFhZTGVRclZGbzl3U2U5WFI0c0YzWmJzaEJVQit6Y0xVakU0VStheU9BUjVaRFVKQjVrRkhTTS9UUUtKazJHQ3RhcFNqVlY0eHFhVGhIOGRCUGhURWxGM2JYQkcxT3RxWFdid1p1RGlnZFJCLzFYTWN5NDEzRGlRclNjc0VrdXZWU25yOVAzZnJndzZtb2VEbHVmaWE1VUdZWnlGU3FyUzM0MWF0V3A5enR1TmFpdlVaTm1MWGp1dU91ZSsvV0F2ZzZkSGhaZmRZTHRuNkk3THIrL3dkTmxKY0o5UkNJbUlhT2dvcVl4WU1pd1VlTmQ5L25lRFd5MVZ5OGJCQUIvVU1ES2k5NGUzbno0Q1JnSHFuWmNkMWduaEFrWElSTFZXY2xWS2xwRDcxT3Y4VnVhM1Z0VmF5dnQ0ZEU3UDRmK2ZJODNnaitKZk5MSWt6S3FYZFJCbXlubHhTWjdiL29ZZTB6RUd1eFpuLzNJcHZ4cXpqV1g1QW9FQWxwd1ZRakkrREg3YiswZmFhelFwZ1ZEeDE1NmdoMFd3dEIreGc0eWRaaTVveXdkWiswRTIxOFI2bkFoQ2tHMFdQR0lLS2lTMGRBeHBHUEt4SElCZTd0RWQ4VTFiOG5GY1pPQXlsTlZvR2ovdmVDckV0VWxyL1pMdUtTWnREazhSZlNLWkJPWlNxMmJ0aG51QkxaSUtYZ3pvaUFFR2RvK2ovRXl2YzNFT1VRdWpFRmtIZ3c3VjcwUGc2eURBdGJSY0pnN2U2bmpRUnpyaEREaElrU2lPaXU1dnBHdFd0MVlMTjB3M0tqeFRMSTFtTTBtNnhieUZmYjNwSlVTa1h1UFdWS041VEIxa0tCdGhsdnhLeEtBWnlBNFFsdlBIZ042TStJT0V1KzdLa2VEcklNQ1ZoaEgyK3NiMWVvaW5reGVHSmpaMW00aFgyRi9EMVFhRWZtbWgwa3FxN3pCcmc2ejRIcS8rczMvM0k2dWcwTkFRdkhsbjg1MjBlV0liMEhORTJqQXY0T0JGeHNza29yRWc0eUM4WXZkN2lxWlZlaW1wTXBhZGVNUEkwNE90dHl0T09ncFVhWThGYWR1ZytvYU5XbldRa2hFVEVKR1FVVk5ZOENRWWFNWjcrcEpLYW0zNmFCdnhyTXYrdHkraGpYTzVzSVZoSjhJT0ZFSW9zV0tSOFNVaVlXdFZsdDR0NGlKQkVsRVJzRlFxVW8zSlZYV3FodC9HSEZ5c0pQYmE5Q29TYk1XUWlKaUVqSUtLbW9hQTRZTUc4MTRWMDlLU1UzUHhCcG5jK0VLd2s4RW5DZ0UwV0xGSTJMS3hNSldxeTI4R3lDalE1RTluanZ1dXVlK0RWdDUxVFZyajd5QlFGRlFKYU9oWTBoM0lkd2JlQUoxQzFndDliWHY4OE83MEVNSUlZUVFRZ2doaEJDK1F0QWoramRzR1ZwWWhEOGRXSlIvczVpM0JHWEtVM0hpK05vVGRJRmFxV2hOYmRQOFpqeWJ4djdaVG9ORFFNcFRvSWdrc2x0RTA2VTRpU1Nud0ZUWFlkOGVGc0NWM29jS0VZYURKeWNEUFp4QW9TTEF2QVdMbGl3enM3Snoyckhud0JIYWVTNjdlSlBXV05oOXpZLzJDSUtwV0tseUJKRXFOZW8wYU5LaXpYYjB0NmppTkNRNUJhYTZEdnZQUVYrR1FTN0wrMENGQ01QQms1T0JIazZnVUJGZzNvSkZTNWFaV2RrNTdkaHo0QWp0UEpkZHZFbHJMT3krNWtkN0JNRlVyRlE1Z2tpVkduVWFOR25SWmp0NkZMY2l4ekIwQjRhQ1ZYRjQ2NUN5Y29pd211cmtNVGZ6c2hPemt5UXBHVGtGWmFlVTB4STl6WGcwdmpJc29FeGxWbFNsZG16enRGdm5sRk9lL0NKL2UyaGRuTE51SFdJUGNjTW5HQ0pFaVJFblFaSVVhWjFVZXBxZUF6TjFiK0FEbXhERjJMRTROeE9QU0x4TVlHc1NyV1l6ZDJwaSswbEl5Y2dwS0ducFkreUFXVm9lZE00Ykd4Y2ZKa0tVR0hFU0pFbVJGb3EzdnpNK2hpSDhxSC9vWlhEbzBoV0pKUEVnb3hSTlMycW5FNXdqakh2TGxKRmhERXRWU1ZLVkd0SWRFYko5eENLaUVHOXY3MUVqc1VDR2tDdFJIcXJlYTRwNnY5L25BSTJFZm1lWWlJVllrOTJLMWF5UmRXZFR0dHJyUVVCM2MwbzkyQ0lKVWNiNjkyQlVCN1NHTytsVTRtNTBET215NUlSTnl4MnVRYU1telZyRzdkcmpFWGZIWGZmY3J3ZXk2OURwWWZHTlQxQkM4a1RFSkdRVVZOUTBCZ3daTm1xOGJOcGI0YkJXRzhSdHRWZEg4NUp0RDI4Ky9BVGNCQnF2L3R0aDNIV05xbVppcldrcjdlRVI2WXNzOGg2Rm95U3FkOVJLbjVZaGNodFBtVmxGUDFtSWtaZ3FWbUtuT2RkY2ttdHRkN2J0N0NDbkNLSkEzZUhHSVFRWjN6bCtVeUlJTGtRaGlCWXJIckVvUkZUSmFPZ1kwb3RKbG9tVkM0VHRma25XRmJubUxiazRibGFlY1FXSzZtTnR0MU83THk1UmM5b3FQRVV3TFg5dG5qYWVOT0xqUE9NUVlKRVFpY2dvR0dNbVJ3WUpLNVZTbFpxN3VoSEMvUjZJdERlUTB5aFBWUFJlYTZqZk4zMUsxclRxbG1NVXFUOFNJMDRPdHR3cU5yUkVtZkpXY1hRTjZCbzFhZFpTRDdqcjBPbGg4Y2tUUkNnaTRrZ2dvNkNpcGpGZ3lMRFJObjQwTDI1N2VQUGhKNkFIa3F0L2FVeHJwUTI4U084b015cWlqbWlkS2ZxMDRXYlNzK2hoWklxVjJPbk8vNy9tQWxlUWdwTWhJTXNQRlFFbkNrRzBXUEdJbURLeHNPc1MxeFhYdkNVWHg4M0tJeXRRbE5xZDVyUTVQRVZ5enpKR25Nd3pQZ080bjJRQlUwT0dkVmduTlVWNDNjTnUyN2ZLSWIyV3FLZURxSmRaN0prbG9VeDVxemk2QjVycjBPbmhCZC82Q1k3bXBka2Uzbno0Q1VqZ3JER3QxaFllVVZXMGFhcW1QZHVNWnpIMjJjNFFIQUt5TG1tNjRwcTM1T0s0V1huV0sxQ1Vaa2lhYkVOc0pDV0pJS05ncUZTbCt4emZLS1dNS210TE4vR0hFU2NITzdtOUJvMmFOR3NoSkNJbUlhT2dvcVl4WU1pdzBZeDM5YVNVMVBSTXJIRTJGNjRnL0VUQWlVSVFMVlk4SXFaTUxHeTEyc0lUaHhrUGVtbk1MQTR2eEVNNUVKZmY0MDl4b1RjZ2ovSUVCQkNRK0ZGSkFTaHA2VFFNTmlNZ3JPQklvRUI0TVFtRG5CQkNoOTVBVWpoN2tiU29nSEs0VGpvUUVCRFFsRFVjV0dPM1R3VFJKSFlhK29SUjUyNFVhNnFZNlN0QnRNckZlaENESG16WDBjRUNHeHpxNWhoNzJNMFBsczNPbys5T3V1dWUrOFVQYUlLZmdJaE8xQVo5VzQ5ZjJhc2hvRmdzRm92RkU0VmpGaThCMFdta2ZpYXdVMTg1aStTa2dDWVZQUm5JbElXRjQ0YWJWWUJYcU1pNzQvZUQrQmVCL2N1ekpHK2I2YlVHOUhhZmhUbHlLRXNWME5XMG1jcWFEdVF6bnAwRituUEdnQkw5eC9hQUlsMGdwdzRTcURzOFlFQWs1SThzMTZIc1E1VmtOSFFNNmQ4ajNyblFzWHRld0ZBZ1Jha2wzT21oaks5SklOdFhpeHRnR2d3Y3RGVlBBNGRaaGxqSlN2YlZJR0ZEMTV1QkV6RDMrNEdzbGV5d05IWjQ3Z25HaEpZOUxGaUkvWHFiWThpOXFWYkFuM2crL2dQUDh6elA4enovYWcrbURBRmhlY25XemlWY25sSDY3aHZPdWlrSTk4S0NoU3o3MVZOWXdxM1JPbFBKMk95UEh1bHdJUVNROGhRb0lpSGJVMm41TnMrNEEvRDh1VWduNENXY0ZGU2sweHlUaW5QYkRJb3NEcFlqSk9JNzJtM0dsQ24ybnpMTUdxT1hZRHBaMnNYaVdJUGRpdFh1c00wNjJjUldlejBJNEhIN0R1ZGNiNGtvU3JTcEIrNEYreEpYenZBYTQ1eUl0K2JKbklyRXp4SkNuRHJKV0xKQ0p3eWt5d3JyTFh2L29zUkwyTXRLMzlsdU9iWXR0bU9KbENsdkZROFVhdHZ1K1BqVUNZaXRzZ0pIV3pzYXhIa3lLRmd3Y1IxSUtWYSs0Vkt0bmc3aDd0STZkd0V6TWVtWklydWpnS3IzY3V1ckRDbmFmbGF3VExsUDI5bE1lcGJaT1F0MGcyUkd6bm9XdTVmVjVYN0s1Y2FRZTkvdVBHNW5ibmN6d2FtOGdMQUhjdkgra2k3SGFsWjVWUGtwa0VKRi9UMG5mZkQyc2RMY0pvTDBWMFJ6NzVFazJVUWFUZllOaEJUcEt4bEI0Q2FpN1JuTHQ5ZmJ4bUhrRHFjUnhZa3VQZTd6VmJ6UkthN1BXQ3pnclJ6Rjhia1R4TkVnenErRGdpMkJYNjZKaUl1S05sTXdOdnNRSEFKU25nSkY5WjZ2aVNKaGxuRXIwVVZTNEpXYzVDRzRaMm5RM2hsVHBoZy9aWmxWb2MvUy9JME9SM29yeGVaM3J4RkhpWGRnZkplQTJFa3F5Um5XTFRzWHQvMHk0enZ6UHNmUlZTa0hjYXBCQXl5WW5yMzRSbld2NFZkSEY3QVR2NVllSmx3MW00UWh0bHhXR1hHdnlTM3U3cnZadkdUUDJGdlZMV1g1Q3Z0N1ZCL2NTa3RFeGN4MXptNTI2V0NDT0lGMDVCUktSdFJ1QUNicTZSQnJ4eDQ3SUlLNDVRWE5YcnNzMGpaSTlhblh1WENQL1Q5NjJ3dk9mUmdpaGxZUUdwS3d4TUZMOWkwbnVNN3BUQ0dLRkN2clJIQ0VlVlduNitXd3kybFByd0hoVUkxNEhKMUpIVjFjbkVDaG9oSUhWMEpLUms1QldVRGN2QVdMbGl5UEtUaHRjUFdNTWQreHdzNXB4NTREUjJqbjdmSm9ETWl4K0JRZmhpVis2aUI0azg1VVpMYXNVV1V6byswc3NSUEhGNmZ4M1BsVStVcCtoRi9vK1R5UDlnaEdDT1k1c1QwWVkwL2hDaDhtUXBRWWNSSWtTWkZXeGFKUzVRZ2lWV3JVYWRDa1pXa0xFd0FzcE1DOXR6aEZwNEp0djZQUEtYQ2l1ZjhHaGRJZVpBdlZmMWRjVFVpLzhyeXhySDF3LzliTFRrNDZHUFNBNDhrdWVjRjlUWGpaM0RzOGRtVjZ5RkMwMFoyanpESGdHa3Q4aW04T00wVjF5ZGhKWnhNYngrdk0xcHlTVC9hci9YM0F4dGxYYS80SkxkTHNxZWY5bFJVSXR0TzNsM0xyZGRRd1lXcTBOb1NtaUhXWEEwTjRadHRsNFZZaHR2SHFYUlJIVHBHN24vdzVGK29SNXVQaUw3enRoVVY0ZlpCbWFvZ3E3ZnA0aUNoUDNFS2NyTGlYTW9tNUM4TTJrNDUzdXZJelBTSEtUTitNZGpKOFlwR1FrcEZUVUk0cDdiVGgwemZqOTZQU0JDeGdNcFZaVTVVNnRNMnVpWnIyNXVCMEdrLzNLYi93TnpUNzUrRnVlYUY4by9KUDZEYUlGeXhpeitHQ0R4TWhTb3c0Q1pLa1NGdklyVFRoK1NYVm5uaHZ5WFlpMUl1TnM3bHZKWk9zb25NTUJpbGVabDZXM25SU3RqbmU2VHpjM3Q2bWNyTlY4d0tPaUhEU25CNzFJZWFvOWtuM1VXd01XTWVDVC9nOUdNdVVQMlY4VXRmb2M3emlaRGs5MkpWM0s4dFh6eDhhRWs4OXIxZHFZTGI1RzZDVEtmcjBsRkhDbnJhYzZRL0QyN21rMXFKWGFwN2dpQWduelV2UDlNM081Zm9CNmluNXZLaWVrcDZuWSs5ck42OW9OdTJTU0RZd0pNVHpqTUhzaHI5MDFIMFlZeDBMUHVIM1lKaWlzaG5INUhUNWxUTXBwU0czQXlVa01vMGpWYzcxTElUWU1YRVcweXgxRnRiWVpjVnFISFBXWmRQVy9KcFZRUERZN25BRzBSb1BxSjlBaGd2ZXlaeFNFbTUwRE9teVpEZk9ldTJ3V2VGb2E4TzRaQlM5RjYwUFEyWXROTWVhTzdYZDZkckoxOGR1RTdTL2ZwdkFVZ2xqL0NTNG8xZzZDUjduaHlpWU1NWVk0L2ZIR0dPTU1jWjRuOW1KT1hnT2hnM0cvNW1JWjB5VTFEaERxUGJoNytWZEMvaXdGL01pMmI5MDY2SHBlMlQzemoyWCtPWVBaZmd5TFUrNnprS1Q1OVVZYmhlVVkrZmFaZnVjWFpVSFl2cnMzc2ttSmk3RlMwQjBHa2tLbWxSMEdUSmxZZUc0NGVaRnNJUDZKV1B0WWdWamgyU0NNS2FQWlA4NjVpLzFRaTVTWCt2WHA2dFJqR0RDQk5tK20xejFLaTBERld0YWFSc2o1dklFREhCTVJKQUFpY2c5S1RBVXpzWEdIektBM3dIZ1hWQ0F3Z3ZkdXdCOVVzeWVZL09HTmFCYnpPNXhXVUpzQXNyWFJQKzdvd01KNDhSRjBid3hCenVYM25VbG9ISnphK3JGZ1ZXU3lwU3IrSzl5UUwwYVhRMXExYW4zTzI0MWdHdlVwRm5MRHlvK0h2bWgvTFhQUDZFN1FvaUlJNEdNZ29xYXhvQWh3MGFOZjAvSjhUL0dGWUYzaWNsZGdpYTl5YVBrMGhlOU53QURUeXh6S1hnZW5CRjRHckl4TFZ1cGtBT0FBRDlQdUtNcktBQnZDaFJrWDBMVEFZY2NjUXgyQ1VzVUFBQUFBSDRWS0Z3QWVCZjhMTGltcFRwaGdBQy9HZkJOZXhETXdiTUZ6UkZ0NDB1NkFFQXlGWHdsTWErVEtDa0tSOCsrRlhRbzFJY2JxSkVDa1Noa0ZBeVZxblJUVXYxcjV2RFpRdVl3WlMwUUc3N3I5c0FUNVBIUDQwa2RiMktja3poWGtxazBPZGpKSlp5NzNUcmNodFVhVTVObUxZUkV4Q1JrRkZUVU5BWU1HVGJheGdldko2V2twbWRpYmM0aHVIQUY2U2pmODBNRW5LZ1FFQzFXUENLbVRDenNmUGhGcmJiR2UyVGFucVlJZFczbVBocmRwdFdkUytPR0prTHJqN1BmZlBMM21MZnZ0bTBmaU5DSFJHOWhKNTVSQU16QllpWEtsTGVLWWRObTJyTi9BOXR4K09nTzU2Rm9aK0pkRmVXeGw1QlhlRGt1M29NeHhoaGpqRC9EaEhUbUowbjUwM1RYU1BlQXpJQkMxa0h4eTQ3bjJ0M0JYZmZjdDJHcnZUcWFoL1BCdHRrQkNGek5ycTJkZk5iMFE2QTFLQ2lva3RIUU1hUzdnRnQzUSsrK2pycys4b0RkWjVoMUZEdW1jWUozNWJUMTRhQTNNUGJndkxRekh2WisveHp2aStwZnNnMkdwMlp2VnZrMmVlQTNtQncxZ282VjBhSjE2OVl0VzdkczNiNWx5M1IwZE5ZL3N3d3A2ZkZTemhYaWZ1VmYrMmNCcXZjT0ZwUzM0ckVqUm5iSDJTWnMyWkFHZTVxWTBlTzE0N2t1QzdycDlGZ3lIcDlYRm4zZDZQeEdsemM0MXNnNExYdXlPakhPeWEyM2pJdy8zdW4vRmplMDhLaDE0TmJ0NDNQYlBTdnhlZTI1YlhmdEd2Tm5zMk9zZ1UxWWMxdlhNMlI2eE1LODVoWTF0N3oxY1NaV1ZMK3EyYW54RXZDM2NXNHZnZkFUMWRidFlQVTFTYlgwanI5Nnp1cll6ZjhuUmYyVGJVMlZOazIvRzBKOTlsNkV6LzlHbnZQS2IyYkJycWp4VWcwakRhSTE0dmJFMXJRS3NMMWxES2QxYlZ2My91alp1SEdwVmtMN250QW1zdTM5dFd1M3I3UHdaMXlpY3hoak1UZGhjVFZsOFc2ZHdxQ0NJWUlqRk9iRmxkK25SYWt1anlQV3czSGIzeFBxaXR1ZFJIcUtENnRpU3cwOXpjM3Boa2s0MEFKT2RTVHI5VGcrS0J2K00rYXREVWJ4UzFYRVV6Yy9hWUxSaEtHcTBhZk94dGQyVkN0cW5CYjN4clI2cVUwWHh2cWY2YUxXYlVvUHhaN2g0UDZwTjZSK1ZEZGhPalY3YTlkN3M1THNxTEVNMG0rVFJUbGF1TnR6TWwvSG1GL3FjalNXNXpGVys1enBQVG1ZeUhteXZiMUtiWnFJZmRGc2FCWHpjYkt6S1d0LzBPSDhrM1NsV04vNDI0T1FqckxqdlkxOXNXQjlKZWp2Yk96YnMvLzg1b0QydVMxTGZIRkxIUnc3clBpT09rMk5saWkrRGVPZ1hyWjFBMDM3ZGRyeUJoNHZUZEkxUlpkT3V4Ym85OWFnOVViWmwzTUZLMnNEWFE2eGVDOUJieE5jenRMeWxnY2hVdEhpWk1IcnVhRlJVV3JZV2JURlpiaFVEWTdSUGRWR1o5ei9OV0h2aWhaZmVFWXVDUXZTVVhGclMwWlV2S3dKTnRaMnY4cTBqZFVNRit1MUtHUkZPdUpkMTFKV1YxSS92RDBVVkxZVzNPYkRyVUtmSytNbHVmSGlBMitDSHp3djVkSjRKcW1zczFKVzRoVHl3SDNFOWdYLytHZlJuNEV3Zi8xdWVQVjR3YjZuRjVNbWpaL1ArV2VsN3JYR1hnYU1PQlpsTnptbnFjUmhFOWVMQ3gxblp2SXZXVlpqNk15WFRJeTlodFUyWnZrMnE5S2hhbnZvRE1ZRkI4Vk5UVFVIdlBnMUFiVXZpcHV5SFFDYjlRR3d4OFAxK1lpVGZiTWc0UDdSaXZQMDNHTWVHYzAxTDNGZlJFZzhKekdmVHFhellQeHNvR3MwOHp5K0FXQXhJczVzMVJLcmxPeGtaRlZpWlRYY3piNm41VDRyblg1TndFcVZ0M3JkMFZOSVFZNkpOdHBHMVE5TzJSTk90OVl0a3NYVSsySUp5blh1ZmVyMnZ0QzhtclVjQXIwcXZ6alZMUXl5QzVOLzY5ckNFcFN1TXZab1Ryc3V0N0ZnN0p3MDUwOXd4VmpsVCtDSjBKajR0VkUrSlFhTHVwakxnNzdaRnRNWjNvYldRaE5wMUdNWk53V3NxTVVtbXU3ak5WWmRaNmE0ZU1tVVgyc3ZzdUQwYWJPSUY5aXBRNHE3akUvVVJ5dm5LdXYwMHMxYWdqTFREbHZYVXIrTTU1WmNhZEZCMVFENmtLcTRpT2l0WXYwUWR6MWVkdW9zT08rMjhWU1hDTURIQU5EMkswM2tKbFJRaFNyVWFnS0FxN1VqdDlJbTZWZHJNODdjUk5mcTJtOEQwQXNzSWlNS015dS9YMUkzUUt2NkVIUFhueXRNYUZwZFd5TzNaaTR3VWZpRCtmUzJrdWFGM3NTNzNTVGlFMEVPTmV1ZUhoTlRYVjNqNlYwOXNtTTVQY0pBVk4wSWZsTzJsVWVNMjI1WFlBUmtLc3FjaTd3ZWRyOWtOUEFUTFRNUUlobFJlVDA3Q2cvNjBmZXdicVUzSVpvOVZMTTNOOXF6RnBDN1Iyb1V0ajRqelRka3VsVDdpaThyRDJkNlpHYTF6U2NZVlNjcjFIdjQ2WkVEVko1dTVXN3ZUcHdUNU13cWZXQW1ya0ZsdXhUN0t5UjZWOVhIcWhHRkd5ajVQY1RsUkhacDJqNmJVSDJ5NDdsNTJZT3VBdVFEdW1SZ1g4R2RKNjIzb1dYbDUzdUxHN21pN0paRElCZnVvYjF2K1RDb0VuNjFZRlFxYkwxcTV5bGhTN0gwT1JLVmErUHRlKzh6Vi9jcXpwK3N0aHByY0VEZTU5b0JTb1BvaENEOW5jR0tIWW9qRHdLOEJUNC9qUkRGVUF5aUZOK05SUVFtWithbW9MVXd6UXlXaW1KalJXdXIwWDUyanNWSlM1eDFkUmNacDlTNXptM21CbmUzeXVQcUhpOGpTQ0JUL3B6RytqMU45Yy83emZVZjhEL1Ewb0xJUXB1Q29FTm43L0lQOUJvZ0ppRWxvNkNrS3ZYc0l0cHVlSlhUZDROOHdNakVZdHlFYVRObXpWa28yempLcmgzVTB4SGttN2FyQmc0NnFVMjdqcGVkMDAybnl6Wnd5bWxubkhYT1N5YmNkTXR0ZDA3dkJ1OERmU0VHK2tNT0RJUWFHTXgzWUNqL0E0YjlnN3AzYnM5OTgyQ0s1MU44bkdhTUFMQjh5b0tkT0JuYWRPalNLLzJSQnpMUURsalZyYkVMdk84Y1VLTGlpYWRlVUMrTjhSZW9KUno0d0lpWkJJbHM0UkZPc3dVSmZRRGxDSklPUUxrcFQ0bFM1UllzT1c3WnFwUFdiZGgweGxubjdMaWNLeWhhRGM2NWNkTm16Sm96YjhIaXpSTENoZWluMjJUSWtGbVp6WGtJMWxHeWlSN2JJSFpoY1k0UWw0aFFSODQ5aUVmMGVVZUNUNFQ0eHBoZmpQaEhLaUJpQXFNckloeVI0UkVWQXpIaEU5OVNVcVNpcElVaFBUd21aSndwRVRBdE10TWpZRVowRklYSGlpQ05NYmMzaEgxQjlvZHdMQUphUXVucVBDUzZpb2RJM1Rtek11U2ljcStyR2dXWlREWE1rUVpqblprS3Brd25aSUFFakF4aGZBb0k1QXllWEdCK2Fpak9IZEx6Z093ODhSNGc0b1NvRlNsc0hrZ3Z2TXNJS1Z6SEpXVDZvdGRudUpLOXJtUjRlVlV4azFYbXR4UlZ1d0FNTXhZVHJibmNaWm56YzVsY0dtbHJwQSswOU9TQU5qa2ttTkNpVFEvQ2tseFdJcGJIL0U2YnYxcXNWWXo5ZVBrNkNHMDEveUMyTlJ2QTJlWU5NbEJaaXYvekZHbzFtOEhZL2kwUzJFRXdRZXdRbkIyRzJCRTRhNEpZTTV3ZFJXL0hNTmp4dHNXSnJjWEpQWTZXaWFOMVBkRTJ5VTUzMldBSzFycmcyeWxZT3czZnpzRGFXZmgyRHRiT3c3Y0xzSFlSdnZYZWR4VUZrcENJbkp3Y21ONWZpbUN2MnhwdjkwOS9EN0lQdUgxRTlnbTN6OGkrek5hQk9RS3FsbExKQ1FFQXdHUkN6Z1I4UWV3V0VMZ2x4RzRGM2F5aGswM2J3amJic01zdTdMTS9kRW1ObHJ2eUJZdmM4a1liNDBldEIrMTN0QzdKbUxTZ0pDeEpMbWk5WVpHQ2VENnNGNEZlak5qTElGNk9zZ3BZcjBTM1pZaDhKZWlyMEc4MUVsK0QyTmNpYmYwZzd2QjFBQzJZUXZDR1NXQzlIdlAyN2duZHRvVW9VMWgxRU9LSFVIWVk4NDdBK2pIUVQ2RGZTZlJxUWVLdFNHdUQ4M2I0M2dualhmRDhGQWFkUnVCbmtIVVd2cDlEMFJVRTNqMFlIU2wxbE5FYm93U3gzMmc3aHpkdmhtRjN3YkIrcUE5QWZCRE9oMkQ5SG54L2hIR1BFZmh6YW52QmVyMmt6RjlSN0crbzZTMTF2Y2Y4QTZsL3hQd1RxWStTK05nUkZnZU9JaVZyWndEaHVJTklnQUNoWXNDak92Q29GRCtxUnhad2NEcXViWUVZUkJqTW5rQU9zcHNBU2szQnFBcVVtb0ZSYzFCcUFVWXRRYWtWR0xVR3BUWmcxQmFVMm9GUmUxRHFBRVlkUWFrVEdIVUdwUzVnVkExS1hjR29HeWgxQjZNZW9OUVRqR3A0UUwxNFNMMGJub2JQNEh3SDd6ZFIvbk15WUFpQmN5cG9vb01IRmpMdzBIRVBHNC93OFl3WUx5SjdMQ0EwRGg2TkI2RUo4R2dpQ0UyQ1I1TkJhQW84bWdwQzArRFJkQkE2SGg2ZEFFSW53cU16Qjk0Sm9STDR2L0ZQQ0tUZmc5TWZDS1EvZ3RPZkNLUS9nOU5mQ2FaL2tzN0h4UE1aZkpwSktsOE82V2VKbWlOZ0NxU3JnRTlYZzlJMVlIUXREK2hHRUxvSkh0MUNGSzBrOGdkK2RCY0lyUWFoZGZCcFBRRzBnUUM2bDFnRThPa2grUFF3Q0QxQ05GMkQzem1rSGhYMUpqakJuN2FTaEFTY3RwT0VESngya29DU01GU0UwZ3RDVDRmT0QvN2NVaGUyOE1XcVdJcFY0UXQ3WklId1I4OG1QcnFkVDZ2TzlPSHNFWVdMaWhITGZCRWluSThyTUxSUkpjb2tFVVdnVWFlaFJZUzBCRUhoRHR4dkNrWUJLQ2xlZGhrK0tTTE4rUW1ZQzdrSk9ZdzdnQ0lxZHdncGp6dXRnYlVSRFJyanR6WTlXL01FbzZoVUR2UTBlVXFMRUxNeDJRY2tIZ0NTcFVMaGVJRVlOVkl3OFpDSlFoR0hxQ1RjTTNsdE1MUkhteklLTmR1MStoa2xCTHNSWDM4SWl1UFVoMGgwRnFpcHh3VW80blVLd3VwVXgvZjhoN0owTk5jR1d3QzV4a3BBRmtwaUpXVVhSUXU3aG55Z29Qb0FZaGVtd013RUFCUzVWQWFTdXR5Mm53aXYzK043Q1JORi9xTlNMSWhBUkYxeFJrUkdFU0V4UVNNeW9CdzRNVmVNb1NLQlFtRW4vbFQ2QmJkeEdoRVlkVEpHNCs0N0pEYWc4aHJMdWdLUVVZa1Q3d2loaTFUdHJWYmFnOUhJaDNWa0NpZUsvMkx2NXl1Zld2OWdqbWlyRnJyZEoySlo2RTlIeEN3VFYwUUQwcW1SaHNxd2lzdFZ1U0hrSXM5WHhJeEliQnh3TTZVTXRsemxJcVZLUGhLbHFVTWhZR0dJbFFnS0liM3V2SVc0RFlwTyt5OWJid0J1QndEMVhyWUpHK1FaOVBLRytrajY4NVJBSFB2bnZzTUF5RHBnaWtKRFNjZzJyQVAzbG93NkNNZUxSaGplckVPNGNKQVVjUkFhS0dRVldOd055QTNCeldWMHJmS3h3bW5qYkZuN21ub3BkaURRV21hb0hlaExyRFFHUG9WeXZtc1J6djRhOXl0Wk03Vm1XOHErUHZYbHZTREtwYitrL2R4YklvendTQzlOWUVsWk0zaE1QZFdFajJ2dlhtUDhWS0hob1VJRE1mNnFnZ045bTZTWE9MRkpWZVlaeG1FTHdOVDFXT2RpeDE3a2JOZ0UwRTdDc29vUXJUS0pRQnlSbUVvRjhLU1VwQVFnalpTV25ncGt4V2ZnaVVEQkh4czhVTFdpZFI2M1c5dGtwd0o5MXJiRUZHRGtEWjJpRnY2cm5nR3MyZTVJZHV5YzVxUE16MFFxOERQVDBjSlNmZ3BzMm1NbEx0WVN4MGJTMkVvZU81bGMyTXZ5LytBTlkyVFg1WGtVUWwveTduSzdZVmlDSHZUdC9JMHRrRFZ1UzhidnJNTXhKS1VIaVlocGtkQ21RemMrT0cvOWMyaWUrdVBwRC9kbjUzUGpzK0p6N0hQcW8vOVZkY3hpM0dMV0lsT1hCVjlydGVxT3BlbVMwdC9sMHR4WC92R0EvNytkSmZyby8vdG1lYnZjWUFQMXA2a3ZkYjJwVWc2cm02NnF0ZDI5ZE0wMzE0dG1lOTZ6bnZha21hYWJhcktKeGh0cnRKR0cwL2F5eFJXWWJaWTVacGhyNEY1bHpKUzVwWmF6OUZ1LzkwZC85bGQvOTAvLzlsLy8xMTFQK1FxRGlJN09DRU1vWVFsSGVJUlBCRVJJUk1SUExTSWgya1RudlYrMWVzb2NwNzRHeWpYVVNLVW1HdWVTT3RmY2NzOGp6elI1NVoxUHZ2bmxYMENCQlJVY1BQYzhMbVJ0Mm5YbzFLVmJqMTU5K2cwWUpDSW1JU1VqcDZDa29xWkIwTklaUXFJTUc2SFAvMlFHUmlabUZxUEdqSnN3YWNxMEdiUG16RnNvbE5yWUxMSmJzbXpGcWpYck5nQkFFQmhTQ3dLWXYvYnNPM0RveUxFVHB4SXBvYWR2WU9pTWxNbU5GTVltcG1ibWxMTC93b0pXUTRibEVDVVZOUTB0WGVDUVpQakh5TVFpd2txQmJsMlFLK3dENkFINnh5SkUwLzhaMTB6R205ZmUzK0ZldnBuUFl2MlpuN2taVEF0TnpveGJQNlprelU1a04yVXhMMjk2dFdsVnA5bDd4M21PWmQ4RTIxWjlva3VNN2dBazNqcmU5OTJXZjRVeDV0OVRqSnJpaVUwM09HdHMzdjdhME1qSzJzTFdkVW0wTzB3cExkMXVpNHVjM1NKbXlnajhDLzV0U0NYT2dCS1gybGs2NVZVV1JXK0FRYVdMWW9aVlpsbktPN3VTU2l1cnd1TnYrcTRmKzduS3V2djNyL1JIUmFDSGtpYVFhMUttcWpkMWZXazhySWFNbVRLMzFIS1dyTm15dDlKcVVHdlliTFE1STYvK0U1bXpyNVBKRlpRb1ZVWTdtdlAyK0hsNm8vd2pDYm5lbXBidHVKNGZoRkdjcEZsZWxGWGR0RjAvak5OOE9GMXVqOWVIWm5sUlZuWFRkdjB3UHB3dXQ4ZnI4OHVLcXVuR2VTWFFEcVdiVHN2MmlpV2xaZVVWbGJpeW1vYVdqcDQvank4UWlTVlNtVnloVktsOU1WZ2Nua0Fra1NsVUdwM0JaSEY0QXBGY3FaYVlSNVJQSlZUMi9ua2xyL3lwZmtWWklYQUFLVkwyUWszeGd5SU1nSkJDS2lDQWd5QUpGUFkzYkNKbVZvbldqNGt1MFM5ZzFkaExHTGxKaURraDNaZGRhb0UyblExc3J3a1hVcHpOTmxhQ1JPTk9BaERPamw3czhmWGY0RU9HUnYxeENGTTNOSDZ3VGIzRHp2aDhGU2hmN0VnclhsUDh2bzR4VkcwZmFSLy9mdkh5T2ZzY2ZpS2ZwS2Z3cVhvcW5qWFAvdWZDMHpkQzZqK25KM0VZczJ3NnAyZGU2dEIzNDNNKzd3czl2d3U5MG5mcXZmYSsvdG9TRGdreUNpcldIUGNmd3U2bkRxRnVKUkIyUFUwSU5XTWdWTDlPaEZvSURUc1E2aURVamlMc1J1QVFoMnBFVGM4RVFoM252WllDZHFyRG9UeW83bjM2NDNMM3NSc3N1eXkzYXBtVThGRVgzbVYzOUg0eThPUHJxMS95aFNqY0ExbjIwR3R6dSt6Vis1aGpZWHNOUEl6T1JzdTlpUFU1bGo1ZWU5NzFHcityOGRDSitaVTlOYzA3aktGYTJjeVVLSm1hK0dsOTdWZXpPZkwzYmhRaE92UXBOeHJXQU1US2p6ZFkwaVphT25CZW1FTGhDWGtpT2lsbkx2YWJpMzZOeStYQno1c3FrZEtzVGMreVBVY1RRNzU1dzFPRnNtckhyWnpramZ6TkNnL3lNbWovbHJLcWFnU285cWE2MTJxbFh2K3dYbHVJTjlTbVNZUkdPRkd2dFp3N1ZYYWZ6VjEzZzN4bkpmZTk3SFl3TUxVZm11MFhzRm54bDl2YVQwaDNCd1V2cU9YZVczS3ZkUm1JazR0L3U0MDhBTnVQdkhIcnNZbzZYUElncnBUbmRkNXNHN0t1eEJoRi93aStQRk1LMmtXQ3FiNWNjUGNENGU1emVXaDUwT0VKZi94UmJ5dHprdlF6SGZXVHFMcnpXU0tuTGlNMnNqYkxuanBNYkpsWS9SZGNkY04xYi9lLzQ1cWIzcEtMczYyemxoRVpSdEQ5S3I3L0FyYmhoTVdGQno0YWZpUUVDQ1FUSVlhK09BbU1KSDB0M3ppVjVYa243ZjlwUjQ2Y09ETTVheGVsU3FuWnRWeGQ2bTQ5LzlFOUlUZEVHNG56R2NIeDFrSENZL21zZ0JXZXd1RFhrQ3g0WlJlbXVlVENVd0UyUXYwSmZSWUZNengyRG9tT1k0aVYwQW1FaEgyc0VqMFJON2xWUVRKVGljUzJiWTlCakQ2VlNsSFZUTWQrZ2haMFVzU1RrR0dBaVpZTGk2WTdQUkwzakg1YmNEUDZKckptL2dRbFlvNDZUVUFZMTFtWDhRa3Vrc2hOWjBKc0VTTDAxa2VrQ1NhYUpNVmtVMHdGRVdQRGxnTjNudWRZWWR5cHRmUGtkc1V3OW8zcHBwZVFPVWJjS0Y4ZUNNNWttMktNNFlZWVpxaFJSaGd0VG93b2ZmWFRYelFLeXFWSmhrQ1JNUWJXWVR4QyswNHFvbEQ2c0luWmx1RXRHL1d4bm9hbjhXbDZtaGYvV3A3VytZbldQN1BHU0VheE5DcVdpQ1RPcWNiSWt0VC9WS05uS3VJellDUkcvM1FqbkVTeUFZOGJwVmlKbUtrSDR3WEFxU2NQbXgwU25lMHppdy9ETVZVOU9YMUdmS3d4cFhFSGRnVHVkUjIxY2M4VExWWU14TkpNNEl1MkZOaDhla1N2NW1obVFqMmNpRGtKMm53RlptcDlQWmVNbHNVR2Vpb0ZORk90b0dqVG4xQmR5Wk9WYmFvMDAxd0xMZDg3bXhERlFsc2dmL2pSVDNNeldManVldWdKQVRWZENEemsxWVFGa3Vtdk5hQ0d4NFQrbWdYN1k1U09Qa1hpUDZyUEs5LzM1ZUYvbHhrUURHSStqS0xqdTJ1QUNzNEJFUGErQmlxcUY2ZjB4c1h4SDRnd3dEU0xwdDhBL0trTHgwOXV4MnJ4ajAxcTFUbWgwMFgzUERONmxhZzdxOWxNdmJURkxtSEZLMWxqTFEzRzdVTnhHK25sWkU5Y1RXeWV6SDdWT0Y1dTg5UDIrNkdKQXIyTEg0MmxyQnRiMEk2TU9Nd0lTeDk5VmZ0OWJldFkxL28zdnRtdGZyaDRRRDkyL3duOS85blQ5dGt0K3lmbkVqajZHL29uU1F4Ulo4Q1lLWE1XekxQT0svSW9vQlNZZWtlLytkdFRMcTk1enc5Q01WOHczekcvbEpPcHJZMG9HYW8vV3NmL21iNzJQLy8vVVRCQWc0WlZ1OWZqRkEyMmtDWG43NEdkNEJOeWpwMXpKKzRrdnNYbG52c0pOeThTeU1GRVpBQW8xdno5KytVMXZZN1g5WHJma0sxN2dQdm1PN3JUdzQ0NDZ2TEhISGZ0NjF6M0JqYXhGM044dUhycytoUDQvN1dMcGRrQk81Z2FRSDlGL3lBbXpTOVZKZkdJU2RxWFpKRmZNVVJkeEMzMjUrYVlSd2IwT2NnLzQ5ZTMxRDF0Nm5PbEZlakVqeVlIN2JkWDlmK3ZiZWN4eDZUd3AvQkRQd1ZRTU51RTF2ay9ka2R2eDYyNE9UZjdwbC9pRFMrSWY5K2ZBc2l6QVJCbi92L3Q2UVo2WUZNbUd4a2hzWTBYNTdsdkRBUmZpZTdkN2xsTzl5RDN0dFZsVC9jU0IzRVUydzhaRWl1eEZLT2FLeEdWTEZpUjZyOEIvb0pmNTFibWx1ZEliR1lqSzhBbW5hK1JkMDZqRDczZ29CWFZTSVkyTkg3Yi9JZm9wZWpyZ1oxTzhVS0cvUkx3czRQMTNlN3NGUzcrSFRDTXZtSjV6a3huN3dMVDlFeExoeDVkVm9RZG5XU1EwYVo3Mk12cWxIN08xR3Q3blJBKzN2Vno4Y2ZwWjBsVG9hQ2JIVTZXN0hKMkJEbHlRUUY5d29IRWNBb1VVaUk4aXBaUHNaSVZVcnE5elUrMzRpL3VTMldVSVNoVFVFdkJXb3hSUWJPLzc0Lzl1Yi8rT3VPTVU4V0xkZm4vdXRlenZBbVdKYzVvTVRycEprM1B2eTIyY2dObm5HTk9PU2RrUk5HK050VGJVNVdHb0xhbVJudHJXb2w5azlnL3hnRm5IRXlKUTJNY3p1cU9hS3BxQ1dlUVF4bE4rMGgwMU13ZlNYL01tK2J2cml2ZDAxM2I4bXRncmZIdjJRbGM3MDg5c21UMEpqOEtub202YnQ1dFg4STZ1SFk5SjJHU2FkS1o5OVNxOTdRM1FHRzhUYkYzU1Q2bnJ5UURrZWFRNDFQcEQweitXcXNOWUZhUmlzUHcvbStkTUVWS2xIdlZadHR0dWNpUUVlTkxtVEJseHB6RmpNdFpzbUxOcG5mdHVzV09QWWNycnV4REg4ODlyMDk5dnVycVMvanh2K2ppOXZ2U1YyZ1lXQUVDQlFrV012MThvY0tFRHdvSUhrSklRcXAya1JkY3VNcXFvdUJFaTVsNWpkalZycFdPcWd6ait1dTBud05XOUJJRFVQb2dBT0MvdXQySGNtdG54SEl5Y28ydUZSN01IWFo1bVdlbHdmZFh2WjVjWWJWSG5PZFJUN251ZUJxR2UyYStncHU5T2w4dFYzbk4yOFo0SisrVzY3MDNQOElrSC92RWpUNzFsZW5IMTRlYmZUTi93YnpqVjdqRmIvTnZMUGVQZjkzcVAzbTVvd0RaeEtIS0MzWVhVTld3SzUrcGVqRUNOVGJ6dE0xdGJxUXRiT0ZxVzJiSDJ2djdUdmpCS05iTlBlUUxlOXJUYUh0cDlaMERIV1NNZ3gzcE4wYzUyampIT05HL1RuS3lDVTdSWDhHQURLeVhHWlNoOVNvZEdWYTdScWRyMWUzWGpjR2taeHF6bUl6eHhwdGlybm1tV2lObittL2MraFg2eDBQL2F6Y05kV3R6bzU2SytqYXg5ZDhOaWhJMlpDTXExaDdZeklSMjJwbTFIc1QyVCtEcEswck0vanczbm5qV3U3R1BhdDdQL29Bc2lWT1NwY05kbGc4dmxoV25WejdSL25vTGJteS9rWFZUdlAvOVp2UXRrb3ZmU3BaYmpwRmtHYzE0UmpDaENtMmlySTFQWWdwamU2cmNFWi9HZENiMERMa3pQcE5aVE9yWmN0ZjBPVXpwdVhMMzlIbE03UVZ5VDN3aGk1aldpK1hlNlV2WVNUTXNuY3NtOTFrdVo2YTE3dlBBY1Q4c3VQL0FhenpwUVE5WjVHRVBlK3A0QkJaNk5FL2p1VDlqaVdmejNPSWxQTzlsUzczbWRhL3NiK01DcndVSURQL3lXZER3VmMrQ0xWNkhjNnNGd1JzU1JkWW9WdXBOWmNyY3FYeVdsNjlVcUhDWHlxMFNBQ0FtdkVOcVNtR0pOR252a2dGeG5DeFo3NUVqaDBlZW92Y3BVY0tuUEpVeFQyVlRBUUErb2pxMXNVS0hyby9wMFhPS1BuT2ZzbURoTkVzMnZtZkwxaVk3RG43bXlORVpVQzUrNDhyVkZqZHUvZ0lEdDgyZHU3OTU4SENPSjAvLzhPSmxoemVNZjJGaFBSY3dBM0IrRHp5SEJKNkdvTmR5UWJCZ1lDSEMvU2RDRkVFNE9KZEZ6Mmg1SVVhTUsyS0RyMFFPd2xDR09OUGxBR3BvOWY5bHlLWWdSNjVYOG1hZXZFVkg5MForcWlvVlRIVU1qdnFoRkN2TlN5Wm9tYTFnWU8vdCsyS0ZEdEo1NSt2UmxkN0tWdC9zUjRXQlRKNlNJd0NFcVJ3NTVSOEFJRXc3S3RleE9UUDVoR3RXbGJud0s0OWpCVXFjbUt2d2M5S2FJdXM1VmQ5M09qc1Yydm5qd3YrL1hjVzhLS0V1NVdiOW0xdHVDVDl1bjBBUDd3RGM5WkNBUi9QeFZvUW52aER4MVRjRnZ2dEJ4VThyRWZONks0aTU5WHNDTHFnL2tHaUZUWUtwTWtDMWFsazFhblBlcW9kbytPZXQzMzhlVUQ3VjVTWnZtSnZmR3VyOVB2K1E5L3pwdjV6L3ZlSFljU284RDQya2VPbENLVkhxR2xXcVhhZFduZUg3T2xoaEpOWkxmWFdEUnMxRzJNd1dSdHZSanNiWk9idlVQN0JYOXE3RzcvdGkrRWZQR2c5Wm1vaUxYV3lTNjF4bjhyNEFkK0VaQ3kwMHhXTExUZDFYWUlWTHNkSktzL2ExV0pxTis5eHZqZ2M5bEhuZm14SU1MWGphVlB1NkxMU3VkUzNTck5uaWZYTXM3bWZmSGt0TDBGdS9MUDNXYkhpTmxkSXRCY1R0S3JkS1FGcWxXbzNWTnJTaG5IcjExdHJHTm01M2hDUGNZWUFCN2pURTBOejFmYlBuTVhSUGZ5NjdvSHNCL241aTZQNTJLK0dDSGdRb3hLSEhHM3VTVjN6MDB4TnNUUjIraE9QS1ZVTklaQXI1R0RJQkQvUG5YOHFJZ2c3cUN2Tmt0cFpUYmdZdytBSVBwZkFrRFFpa2NyeTBBOTcwSkJWcEx5a0ljbHc5bWx1TWJac1ZxS3o5WHYxVDVrNG5yeTBHeit4bm1wTkpvNlpYa2lkWGNkdmx6Q1Fub3laVHJwczBlbk5kNzdEQWNKMTJ6V3hqOXNnaHRZMkhhWGJpU2R5ZzkrTWxuOVV3dExaOWgwWXVXbTFKc1ZYdE5xMWNhN3ZLcWVtaEVSSFE3YmhCQ3pRdzJYWXcwenlUR0QyVGgxbms4NVNZSEszZTlVOElEd2puZHJHTmNxMkg4TWFidERTOXVJK0tOc2lqWkpQRDBUaTFIMit4TFVwU3RDbVNZVklqRkJhcEprK1daQ3ZXUkMrYnZYTFVhZUoyeVRxSjJaYjJhU0VlSGVpeWdHNUJNRWV1NngycVRFcFBFQ1JMZzBDbGpWdGNNUkVxZHpXZXBybGlrNk9Ed3IwOGt5aGFFZElTazl5V2gzS2tGR3kxeGNwTTFtNmhnc2JzeVcyOFZpaEw5eFlCNTA5cDQzSFJINXhmcU9SYVRnN25OdDU2YnhqMzhBa2R5MDF5cldQcmFXUzB6VzVGd2taRjVKTGtrS0pRWEVCNnBoR2l2YU1sRlZGS05uN0IrWFhBN20wQW5Ed2VvUGxEclBza2Z2d1BqYWluOEc3Z0ZHem91MXZ5QUVSQStTMWk5TkFMYWVBMEZ4cmtmREVTWHZuVFNpMmM1c01pSWhJaGVqbHYyeVRlMDUwdHVpS1ZNeEVsQ2tvZTh4SG1UcDk1R3RBdG9BbnNNb2Q0a1pRRkxJZjJ3NVYwVkZvRk9kYk55VS95TzFMRTZlYlNWZm5oSitqSFN0OGZXblZOWVZGSTBzVk9ydUNnbENYUy9XSjNpOUdLdGdVR1BseGw0MjBxSXpEd3V2SFh3RnV3OVI0U1Z2b2dXTFgvYWlEV3hjTXlHVS83M0VpeTJaejJjVFlFd3lhc1pHWVR2dVovaTVLMklYaXhyWlJXM0w0ejZrazdQenFPanFNa3kzWkp0R1NyRzFRZVYvZHo3azZ1M0Q0aWREOW03bnV1bnB6eXl6ZUl5L1M5bmZzMktQbm5rN3ZjUHZqTEpNSUZTeFBQK3dLdWFvRGJkc2VQbXpyT3JHMHBTUmtSN21GNUMwNmpoU1hHeFFJUVZ2N1BxRW5FUjQwYUw0cXNYWXJGaFNkTC9LWWhETXFSUUFFNHh5U25MQk5ObXhTd1JjT3BaTTJTeGQ5VEgweHpYTEV1NE50dFR6UHdMelB2S2UyeFMzbGlxQ2ptTndhSktaaXZNVGU2TUR0L2Z3dWRIREZPeEZrV3FZQzUxc09pVnlWYjZMejRiSWZOUjJJMmp0SXZnQXFRQUFhWU96UW9IZ0NRVFNHc3oxbkdpYy82dWd6T1pJZS9NZXU5YUQ5c3ZEMHVmQmpxZWxsNTRFbU5VNWcrWXlrcnN3NmFqWVVoZkZuY2VMZEVYWmU2NlIwdG14SWRSTFRmandwZW02TTQzeTh6RDd6cDlWejQvZFJHMjlyVTlvUWRkOXp3eFY5Y1FzaGR5N1BVV3N0djVSL05WenJUdGxXcVhXYys1SWp6bU41dTE4TEphb28wemVPWWt2dXlmdnBUYWw3bWNxS041bm1hRjlvUHdndGQ5T1BqZG4zY1RzZjdlVjIvT2dJQmtqeTB1azRPeDBlMXlGODcwRFFYdmdDUU5vMzdZMnVYN25CZVp0N1ZzVVNZUjZNcDdJa01mTXg1R3VMVURuN3doUGtEbisvL3d6MTFRL1NBR0lRb0szYlVIRHhXbTFUQ0pDZkJldzB1a1hYZ1FpL242c0x1TVhXV29hZjRjMTA2dEhCbkwzVlF1akRkdHZNU2dxaTVrMW91V2lUdzVUaFg5K0JiUDZhSDlIa3BSNXJwNkNGODNLeGRyek8vQlh2VlVDVU9DcWpxbDF1dk01bXBTVHdtSW1yWU1TSmM5L2NVS2prOG5lOGFTei8xWVYwRmUvQ0tHbGV6bTNybzVWUmtsMTU3eVRMU1FVNnNuaHZqaWJtaVpzKys1ZFBjL01YOVJkZkwzT3pYL1gwYWVHRDNRSzIzVXI3eXBmZTN5U2hKTG91TGZyYWZYR0EybkZQSmViM2RyS3ZWZWlNam12RFJSWHdkQzVaUVRXSVpqVWZ4R1JEVFFjRjNxWlhkS3F5MVE0YTNCRm8zU1d1R1NuNUROMUd4QnJCR01uUGtqUllDSHNVU2NneXROV29ZeE83OGQ5bm9Gbmw5djV5NFc0S1U3VU1yWnRMUVRrSElHNEV0ZmRiSmp3S0diTU8wcm84Mk5QdU12bjFsaGE3VFROVDh2LzlwN1Y4NDA1aVJ2aTFhMUZ2eC9IVmxubXJiK1FuVzdybDFyWDBteCs1b3pLTVRjN2lueHlNckNzd2pQMGJsODU2ZFVpdDVtU29IaklMVmh6Y2tMTGVHMW02TUs4OGJTNkhxUXUxWi9VRmRRb05Edk9MZEhjd3M2UUhWemFYLzlEUVJMdWpWVWpoRGdZcnVhcENBL2pPMUpBeDQ1QTlST0ZmaEI2YlRCR0pFUmZhYW9YVzF5ZTI0RDBGcitCRUJHdGJuWi9XSXErRmtmNzJ0Z3JDNjVLSzNnNmtvNHZBUFE2cHlIMUE2WGZxT0xIWS9JRXQ3UWVpelBLajJrSkNUVzhjYjdUREVnOWtsWEZCQXJncGszL2tJQ3pqaG5MRG9uTnVGVHQ4RzNRU2orTHJlR0ZvTDZiSHJmRzlzOWh2a3publJ4K3YvVDNWanY3R0tmOXo4UjNDM24wOWUrRytOdmVwWjNxQWJ2M3J5Yi81MWgrSmZLRnpRRTNYQW9rQmNvNHRBNmZWVk5raWhjMEVzelgrNjYzMnNSV3gzaHJiSzdSaUF0SktBOFN1c25obEk4M1ZkOW5uakVXdG5aUmdrMEVvSzRTVnZqOWIyUndGYnZ0SGlhbEFFNnM4ek5FZUhmdHFQTVJFSzZRWTRTRUpXS1JKeUgyY2UxRG0zMU41Z3NPU2JnazVreHl5Ri9idkNhVTdsdzFPdXpLcnZrRHZRemNybzhlcUpiNE5kT1hLR2JubVhFZDBrdHdIVmYzSVJXYmVxdlV0SCtyamhxZHg3dDR5UkFxUTJ6NEVuRjdVTXNrMU4vd1NEQWZ3SUVmRzV4QVZKakxzU05hMytublZ2ZXh5MWZ5VHNYUW5uVlBMY09PRWlRQ1d3dXY1VlNNYUxjN3BZVUhiQnk0enpnTUtTVDFMb01XVU93NVVLQmhNRndyY1ZWY1RJTWppaWpNK3BTS2Q5Tk9QMEYwVzhMamZNRjEydnJodXZRb2pIQnQzcFFLcENhWUI3M1NmcjRZcWlKQWlEdWdxemFzQUdTVURQWTdlWVYrVzA5bVlIUXk1b0ZNOFJVRUQrTjNuNVgwbGtRQmh0REQrV2FkNnRXU2U0VmR3ajVBeHFYOUovcEdoZFFQVGRkNUdQck1NejBEcm1ocnVrUysrTGdFSURQb1NPU0ZqUmdNZjVNZGkvemJLWDhYZE9rNE9DeHhzOVQ1KzlrWnZ6NlRuQmE5VjA2Y1p6UlVZTlR3UzdFTkZnVDNLQ2NEQzFvOWNCcENNNDJyS0J1UTRIb05ENU5SUHc1VUNpRG5zbkUwYnlSOVBRRStvbkJQMXZVa29xakJCamxXa0h4R01nVUJCZWdManVDUW5aRjErdGhoeFVzSTk2M0tjVFFHbDVnSitvQ0xJSmxQTGprVFdYQzU4bW43TDR2UnZ0WE1rRjlWbWdEREdGdzFZaDFvazJvYnBvUFNLQ2hEYUFQNTR0elIwNVNkVUxWOEsxMGtDbWpFRTVlR0lnbmJIVzh4OXN2L2VkRzQzVHhBVGZRMmdZakJpMzFSMWF6M1BmOE8vL2g1bXBJTkVQa1A5WU83U0VQUFpGdktmQXlsV2hyWU42VFpIR2o0RFNGRW5nZWxuSmRzTWNzRkZONld3cE1LaExFdjBIdnVDOUhrYzlDbGtxeU5LNnNzSndHbGtaOVBLU0hxc0d1SzIzTDdXODVvMys3Q2hWU2JucXlSUHp3akVZUk00bUY3NVUyVy9jTnkrd2R0OGtySDVxN2I5MVh6MER2RnBhL3VyQlFzMW9HRHlyd0w3WWlONFA0NnIzbGUyTWRIcGE0Q3JVSDlKNi9jaWpucW9jRUtCTFRnRy8raUYrS3l4WDFSc2tRMHhhQ2paVVRSS2ZxbVFWQnd4Wld3NXhYdkUzdEtIdnExRmJLM0hVTVp0YXpEV0pXeGpjVTljSldnbElaUU4zeUNOSlFsclh2bDFSeFZRY2hPb3Q1eXA3MWlNVzFtVVVhanhoRTBjTG5KWmVOcmRJditGenhJM2ZnRDNWUkpWQ3BkZGxaendjTWRCbnQ1ZEFQRXhLZFRDWno5elozSnllNmRrcFUwQXFJVkx4bi9BYjRwMGlyMURxM0lBdWFwRzNuRkVYenpLZzdJODlrcjFBZmVzb0dsaE9FNEwvK2R6UHVYK2xhY1RjK3I3UkZYZWlDZTJZMm1pRGtDYms2UFBrblBmVGdRNmtVQ1ZBN08yZVJaQk5SWWpiQWlCYXRycWR2KzN2ZERFM1FHV29QWEpwTFhvRzh1TFd5Y2p4UmUrTUtzeitqYXA3dFZqODY2a0N5WjQwNkFqMVVWNGpwdEdNZWxzRzVjVGNZNkRQNVdxQVNvZlpTM3pPRXh6U2MydE9YblE5QlJUVWxSTll0UW1IUTQwdVpIRkF2T3hWRlI2OGR0bjlvV3lHcXVtaEdDK05SVnNCcnhsT3F4Mlg3RHkzZnUwM1ZHeThERVNRNUJzYWlFdTJiT2JseDZRMmlEbUt5TG0vUXg3NENtcFRIUFF2UlZDUVlqdXdDajlnMzUyTjd6dXY4SGJzeHJ1ZElFWFVueGRqSGFoczRzeXpBQ1FKMUp4dDVOdUhiUzBoVExSdkl0OXhKclE4d3pjS2RwSGlINnFEeG1ndEkwQ2l2b0dJYkIxb3dKYzZLWWI1d21IS1VsU1FiSDA0YUx1M0crMkdpL2djQUtzSkp5eU9ZVWxqWkNrN2s0OFJpaU9Tb0Q3Y1NnM2JWai9TQkZXeWNNVTB5ZlNJYTVQdEh3VnZCZlJ3M0NZWW9NTDdqbmxFaG9DMlhUWGZmRlBvNTY1VlNUTXU2M0ZwTzZXK1c3M0FWL0xzVE8xTEJzUThvbityaHg5cVYxdXRZZUdtYXFjb1Q5S1M2bzQ5RW9VLzF1aFFja2w4MktYUVNnSlJQbXJTME5wZExwS0xNTHZBRk9KYzJzb1FWc0ZVYngvME90czNsVFM5ekVjcGFtV2pUa3VuTWVUZ2lDbVBmSWlFYkt0ZHZ1cDhCekIxeDdEUEdqQmtGZ1FIMERaYWFUbFhqMXAzODRENWl5UmJacG5WU1hlVFlRbkpUc2wwdmRiZEdTRXVSbi9iQ1VsMEwzRXRuSHZrbHlnYW9hWUlFTzA4c1lDRE4xKzFWUStUSDFsL2pxZlpLbDJTM0pXV0FzMTcyT0ZUM1JqcndyT2w3ZDhmcmRjLzFBbmFPdk1oNXV0bW53WjErNVN5OW10K0tjRkFkUW01TysrMWs2aGFPM1U2Y1ZweFJzNnRGci83SlNCVmYwQjRsOXVEbk1UKzNvSStZZi80L1F3eU8wd2c2ZmY2SXJZLy9mOTB5NzQ3MVR0RWtVcGM1UWRPNG9oNmhMdXlzY2Fnbk52clBOSGx1WDhTcEdZSDljZ3kvT3ZoZC8rL01OQk8wRTVKM0hMbndmdlhjMG1PSG90eGtBR0hiQmhqS3NIdGpyM2JrdHZvdHQyaUxtRURQYmFFcXhjMlM3dWhhZzg5bWpvb3g2MUFvdTU0ZlFpaEYvZytlMHZ5Rk1haTc0ZlVPcDNoU3poL1JmSXZBR3l6NUR2dlNJQXFieVphLzB5UHJQYkhRQk9RNE9obmQ4RWlvUEFpRSsvYWY0L2J1bEFiS0lUaGtwb0laYkVWTzgzRWo3bVdERDNicm03L016ZWxFaDMwT3FPN3h3MmRRUHpzU3FEYVB1emhlaWpEL2FlbTBZU2Y3bTdMYmxxdzY1WWtJUi9BT2tTeEhjYWtmY3dwOHY4Z1ZabDRLbURzSmpsbnlHVkpiODc1bWdyeUgzaDB3SjEzMDdUZ0I4a2dIalZHS0tDUU9xMS84VG1ISEhER2k0Smt4Y1JXZnQ0MzVLSkF3M0QxdUxjSDJsQUQvS2ozUmFWWjBsc0s1LzNUcFNlZDJkREhYY25DclhEYjBRUWdKc21WWEdma1VRWGY0QjVIcWNSdHNYZ1VQSkFWQkFVVWQzdWR3aTEwZi9CdnM1UlhmcVM5M2tnQ3RmSHRZdnpZWmNJZFA0b0RBaU8zaGZPMjhka1pZbEs3OG0xVE42eUxlY3RaczV5bXFWVjQ1ZHl0dCs5S3czaEIyVGRqc1RkWVZ0S29NRWF3cXExdWdHKys0elNsTDhlTVlic01OVGg1aVNJLzh6N0xPaG5FOXg4VkpIRkVnOFM1YmpSSklyN3NNK3ZSUlBYajBkUDNsQVowR3MzT0dmc3RoN2c5V3NNYUtQcUY0RlNmZW05Z3dGSERZaGZDZUJSWDlQMGRON2s2cGxGR3ByZExmcnhwS1ArdGVyT1M2YmRtUDJOTXAzVFh1K1N6MTA1UjBtbDc1Rk03blUxOEp2clRTMGd3ZmZ0ODc4OUVWQ05TL3dBZ2lsczdLZmtSaHlGZzJRNy90dnZsNEZVY1o2ODlsZkRmblNudXhXZGVOZnVzQmtuNnlqamZWZzN1dFBoRzlMcUpxekFIWTFSYmxhbHVLQmZNVzhQZUxsaWQ0emVudnYxOTh1TVJ6U2xZallLZDhZUFk2NmlkOWcyYUZWRVZvRlY2RXhuOFNzTlR0UUpycFN3TDY2RUluSmcrdG1UUlo4dWZFY1lCRFhnN2pDM1c4OGtKcWZkMG55eWFBN251d0hKc2FjQjlRSWduVXMwRVFtQXg3TFU1ODAwY1NqejF4aTNydVBWZFZJdGZlVzZNb0VDZktaSVdFTTVTYldZSFVGelhOaFVackFWR0ovSEdyLy9jTTFOanF6Tk15Qjl2aXlleHQvMzkxTUZjWllXbVRvTmphNkpGcHl4OUlBeGZCNW9iNU10RGZMRjd3L01oWXdIeExEME4rUlVhdmtHdmFhbFhIWE1uN0hrU0ovNUZ4d2JBVGJ2dnYyaHFsL0I4bUdBUG5TRDNTeHJLTmpBZG9oaXBOaDZoNzZjbXFQQ2RlancxdWRPNkMvZnZQRlM3UDJQRmZFNTk5WTdvdjhONmtRNEg1Uk85blc1ZHZpRXU3YlFXaW9zeGZnaUxZU3Z2OVVWb3NHdXJybzBUY2ZPVGVyM1M2SjJjRXRWWkZ4ck8zb0M4UkxjdFFPeU5jVFhnSEkvcVBGczdDMkJqd045K1pQaDZuS0lnQkRCd1pFUy9IS1ZET2VaZkJjZ2V5VVF3TGdFdzNJYVJJWUFCUmdWQlVUQUIrK1QrVTFnUEFBUVd2ZmEwTzRiSnF4ODRTY2JqcTZ4dmVuQWR0TGppL3lEKzZON21TYi9FMU1TSDdtVytPR1ZVNGQ5d0tKekFtbThZZnBsOHJ5c05VWG1rNGVzamZUeWl5YkU3K3R6ZzBmcGdDWE9YV0FNWEdseHpOOG1lMFdZQ2JUNW1WeUxEVEpmV1dZWkxyVStrTnBGSjVrejhkV1hQeHNuRmR2UXpva2lwUG5GYTRlcUhmNW1Icnh6UnBIelZoRWN2di9vSU52a3JqdkZJWG4xaUR2UFhITnFUZzNlTjNWN3h6ajA5bGpqUUhiNW9KbUdrT1dsTlNhNTEyeVR6dDI3UTJDRHJaTXNSRUVoMUF5V0wzeE1FTXUzRVozc3AxUklNdlFoMjRkWkFOa25vcGtwNUpoL2lGdDlpUlZNZURRQ0hCcURDblR5NDBsd21lcmFGMlVlZ0FkcHpJUkNtRXUvSnVubHNsMlV2ZGF4bm5JVHBWVEEvN3FtWjhoT3d5R1VlSzlmQ1l5OGxiNjk2QTdlc3VoaFBmaDArTWNDQWJPM0NPR0hUcWRXbVR5NjFUaGhqVlF4RlIzMEdOazl2WTBTYTdQNzJyRUsyaG1Da0JlUFljckErRElPSE93SFlaeVcrR05qMmtFS2FGK1l3ekN1dzIzUStzL2MrN3RkTXJDU0FxeXEwUDRPVTB2d2cwQTV0YUNIZVd6Zi93V1djSk0zL3FMTVNwN0REMVlkWFduWE4wNVo4MDNhZ1JtQXBTQS92VHhneUFzNG80VnVHcUpaUVk1OVk0bFVaTDZBVXJnbzd4eGU2NHppaVFmeTM5QWRReHd2bUZGRk44YVpHNzJZYWZFZENMb1pVWUt6ZE9TaUVPYTBUYXJEaFZON214S3dKTnEwTTZIaXZqZEYweFRyMCtvM2tJdWRhbTN0TnZGeTdwc0o2OUxZcFVwN3RyQXk5Z2hqYVl1dlFDYnVHdmw2MlNQT3EyVUlJNmkwbklidE5ySk1TeExRWjI1b2VudXFxbFZib1NXeE0veWVPazVNRDlqbllxM0g5Qk1ULzlmckpWWEZ3b0ZOdEtlN2hEelA2RTJ1RjR0M294RXlLNjJYR1ZncW1QVGpKVkgwUnJTWis2REhCdmNJUjZ0TG1HWDRUdFluVmNpRk9McThTVk1QS0NYRjV5UXhEbk5VR2k1cWRlSEYyTzR0U0hLUXBVbUFLZGxxL3E4Zk1rOU9Oa3MyVWVVdUVtampuZU1iQVBhc1FnNWJvZTJJYWNFQ2VpTXVFSW5obUxXOVhsTVgvcXVZSEI5OFVGUHE3dUxiejl6c0FpNVMwcnFkc0VVblF5dHVRSmVJQTB4aW5zVHoyL1Fzckp1ZmRKNC8rdXJyOFNOa1p6WERPY2dZN21zL2NPU294clVkR2Z2RHE5a1NxK0VFL0o3R1hWYVBBb0NJTXdLeEhzN2ppRXpMT2hueXVQbEd1TEYweXhzZHNDeVNSaWt3REFFdVRrQmxLbzhQSGN1YWNKU2tZV284L3M3TzN4cnhYN3VmczZKTEp3LzNBNk5YMFNuUDFaZDhGdjhwcTBXUGdqTG9SRFlxQUhaeDZ6RUdqT3dYV3F2ckdNQzY4R01hUjF2ek1SaFpRYjN1QXlWVjFnYmUrWVJ4Y25NM2ZOb1JHRDhFM3p4STVXbExGMWFXQWlZTlZkbnkxaGk1eDExMHE4TUx5Z1VDVzZMKzl6NTZES2R3ZGRONUhhVHNQV0YyM0FZVU55Rkl2SU5uRWRkc3hYdmkyanNGbkw0L0s1ano0ZWZhRnZEeEN6bjBUYmlqc3FCdUNkOVdEVndwUXllcVQraUszUXlRSmpPV2M5c2NZMGRpamtQY21ITkNNYmpaVTRzQTRkb2hhM1VhR2crVWF2TVRmOW9hM3BYV3JQMHhVTzJqZmNHaGR4MWUxcTRXTFZUZk04dUR5Q2U1QysxaEFBT1F3b0lPTG5Lall5Nk5xRUZoNnU0Tzg2TGczby9UblNVUzM5QnA0Zzd5eEk4U2U1QVdaUGloL3I3bERjN01LSnRZMXU0VURKNzVENzNpQ09TUkRiUjJoQ2oyRGlhRkhRWHc2LzN4QkY5bmlQSnVTejJkZVRIZkJMTVB3RW9WS3ZBczdaU3MyMU9EcTM4aWpnb1RvNDcwcXdBMTNWOXlYaitOTkpFNThaaHhOdVErQzdQK2JlTmM2NkZOdG1DK0t5eVJYTldRYmp5d0JqeUZYWEVWc05nS05VOU8yelY2SWIrVGdIMDhuSFlOMldkZ2pQQWorSlcweDl4a0VWMlJrci9RVkFGZFVIbUVPMm9URGhhQ0MrSXpQMlZEWEF4c1RvbnpxeUloTnlPK25GM2xaMUo5cmszbVdOUCtXYmowZkdnWkRvSDBHU3Y0QWljRG9LZmx2OHZxQmxPWG5RV0RJMGJWNGJKWmpVLzlXaVZjK0xuSjJxbmNyT0syL3Z3K1czc0Z2ZUEvby85SVEwNFNnc2YvbkpPQTFWdjVIa250NFBwRTRsQ3lxbjBrK1F2YjZqZkkva08yOEY3S3BtNVdrTzRrLzZhVUdUcE9FZW9jQ3FLcFE4Mm1MOVI1alYwazJ1dld4V0xKL3hESGpoVWYrQlM5OWJEMmp2UGJQemR1Rmk3ZG1sT1JmOVFxSVdWbGVnSTZXQ2VtSTAxU1FodkNEczA2dUZaaE1Sc3JkZ2pQZ2laY0g2bDQzK3ZnZjhCdnNJZUtsQlI5MzFYbWRjVTYvQ1cvYjBucUZLazNxY2VydEVtdGgwY3Y0bWVtVEgzczB1UFArZ0RQdE5hNEZidTdVNC9TT3BGbzloY2xsaGdCelBTR3I0QklVWHhHdkZDVUdLRG1Hc29maS91ODVPKy9pK0kwdEpIb0h1U1AzSm1jNXZsWGFoY2FvYk1vTEJuc0YyTGtJekVKQUhNaVF0ank4KzBCNFpQVWlDVEVlOUVnRml1MEFKQVlkVEhjd0hROHhtU3p4THZWT0VLZkwwMUVRekdmeUZENXJRL1YvQXhEYXZxNHZiaCtGS3hRRTE5OWlFY0xHdkZFdUpyRWJDM3psa0dCcFNJaUc0Q3BpZ05LNHpLdXJlc05lWTc4eDFQMkllQjJsK1BtclJzUE1jcCtPSjlNVUkvTmZpbXR2VTVhRWpPdXhudktMM2R5WEZEaS9XVE1ZdHpQZ0tPa0ZzWnp5MllnSGFUNmFZczk5TnpxclUwUTRzL1BUbGZUNGV1ekhUTzN2OC9Gcnp6ellvOXcwTXhubnVvRlA0UDJCL3ZnS0lrUjJxOE5ZcmwrdE8rV0FYN0tqRW4remxnc3hTVC93VC9QeXRMY3RHUENHclpBOU1XOFJXb3JWTStvS0ExeUtUVEFuOEx0dk43eThqQ2pUaXJ3TnBVSnRHYko0RWJLZlFIZ3NaL3puZldZcTlKYzdSYXQ0R1Jvd3lRVEJNZGV2YUJ5dTdrYTc3NFAzalBSS1BkY0NxQS8xUjdlbzQ1WEtOVnQwaHBlQU0zT1Y2dDc0WUdwTnhOcVVOSk13Mml4MTlGU0xNTnFUYTFoU0JkREN5YmtRYlVmRFhhK1d5ZmxhUkx2SmdTSmVwNWd6ZFZyZWJaRVJoeXJ6M3lVRXJ6RWFqWDhuU1gzOXliZHBqazJKbisxa0tYQ3I2b1JnNFYzdU5SOEZQajZHUW5PcUs3UGorTGhzcmtBaE1qMWZBZk4wbnU0MUF4cnNYMmN6UG1YL1BaT0pBdE9PVUt3Z3QzYjg2OXMxQ2dFYmEzNFBKQXQ4aU9XQ3NoaVRaUVh1MmY5aG16TTJjc24va3ZGNkJkVjZzNjAzYzFlUHpGL3c4SHR3bysyR05wRFI5SGFzU2VjVGdKanMvWHF0SkNuRWIwMTdrOW8rM1NQK0k2aVF1ODlKV0ZEL0pYY2I0UnFxL0YrMDROTW5Ebkt2Ty9JMDQrWVAzUmVPOXgvU293UGhDQ2NldytvNE5kQjVJK0FDME5aQUcrZ2xoY2JwTVR4dkNVY1NuWHJaMWlkZlVna01ybm1qamN2b0JvNWlkRDBZeENtaTJlUDZnbldqa3diOE9vL1VPSzVPOWpVaHhZYksvd0QvOWIvbktrRnJCcFlUUmRWWm1nak52NEFmKytaOFNHTitCaURlbVdLZHRSRit6MXQydEUvWW5ZYmdsWmxhd2xEcUFwTVhaWTJuL0VlSlAzNHlwRTgwTFcwdnNHTGtjWHN6MmVENmZOOEx0SzZzK3ZhTTQ5VHNaV3Z3WDBsUGpJQ3Zjd2xERFJVRGo3bkN5RHpaUDV4UnV6TGd0MEUyTy9oMWo5UGIyZG9HMEJ3R29QYUVjRm9qa2NEK0haTHdJeE5KYzlRbGpvSk81b0ExUlVsNjhqNmxzOVJadG1OemVHaUtvcU1rUXdwNVM2NW5kYTU3ZEVvNzJvd0pIbXBQSmZSQ0U2T3M5ZVVUZUdVUnZVNm9rOXRWRThNY0JSVGxDbjBJOWtiZlNSOEw5MTE2WVAxTkdMSjFyWUVkdjBycHB2c0RJZHlKTWNCRHh0ellnZHlHVVFQNUw3ai9QQllCeWtsQXJ5QVhZM2dneGhBSTdyVUpvT2VpdFNhSXptS3Q3Q1RRelNOSDN0RXZhTkZaMm8xRXh4V0VZS2I5WWZPZ3dwOWtGVmhaSG5wQXVxNTNJakhXc1RtT2NZOHZvWEoxSUF6eWtac0VpUGMxQzZSbFRoRDR4M0ExZEd5TnN5bUdLMitSVlF3cFNrQjd2UW9KMlhnSzZhc1ZHRDBld1ZUNkZYTTRGbjVXOFpROEJBRFFCdGpQZTVCNFZZUkthRW1SWjllMVgrUm9rNnBlN3Rjd0VCcjdHc0hRWnhRRVE5TUVBZ1UzZVBCZnhjT25rWXdKZUR3d05hUnFXQjJ5TnB3RkxIaWZMZkxkditoZGs2aDVwQ2ljZkFlRzc3aFVuelEwMzRQMEhkYmVWK1AvVzdvRmpRRms5WTdUNDVTMDM4VWIzSnZ5WXE5RmR2cTNqZHNlTDBqRzhKYlF0bU54dUFkR2dXVWh3SmM0UGxyZFI1a2NXUmdvTDJpSWdXZW9xcUk2cURRS1BCV0ZjdGtRRGtSVU92ekFDLzZka1pBT2gwcyt6empuZ3Jwd21Tc2tFcUt6c0oyNkVKVUxVR2RBZVRrSE5TdHllK1dubkVGZzhMNjA4ZXUrSlQvRnFhSStTMms5QVA2bDJkYWRtYjlTQU9EaUpvRG1iaUxOY0FCYWhOZmZLK2M5dThzZUdRblNaNEtpd2ZhUlhlUEFrR0FUQnpiSU5DV2xNREkvaFdJaEhaS25SazRIdGlNNHEvZU5pLzd1Wk1GME50N1Z2UTlqOWNRTFlOUTAraHNIUkJScHNyeUFXZDNlRmgrSC9WSWpOQkZQczNqaVJXTnQvWEp4cFVVZFZrT1BtdnJJbEliK0xQNUo3RlMyRVB5NnV5WXlLTk1odHlnL0xiNGl6NEl3bFlQdHBVenVkRmZ4TmJJYklaNkJsVllJRTRzTkRzQjZKUWtuZEFSazVRWUVVZkpDbjFXTVpmbjU1Mlpod3BqUVlTUVVJaFFmZ2tTSGtObWdNVkJuM2p4Z0xJZHBmQnp6akF0UTBsSFJtTk1nbnhCQ0NBb1RTa1Fpd2duQjN3OHNIcHRrWlNUQ0MwbFZTVmt6STA1eDJmQkd4TmpwMnB6RTVxS2d0K0hzdEFBSzJvUGhVZGFmL1c4cCs5TDNHVU1ISkh4TDVlTjFjSDdrUlR3OW5UQWhNcGJQeU9sZ0lYU1dEWjBic3dNOXpDMURYVDJJNFg2QnNXblZoNjdIQ3RpV0FUTllua0QwRTlmVTkxcStYbnIwNW5UK2VaWVRnTFovdmJqMlpGYXNIclVDbVhmMHRSYnJiWldIVHZnUGVnRSsrdFRPYlA0SDhQcXBLN29XUFdwR0dIMXF1Yzg3blMvZFlySVpONi9wbVhKTWJVVjFPOFZ3QnFtbTdWYnZ6bkI1UlBNMHloVTlJelVOOXpnVFp4Szc0SzU0R1NnWEZnL1Nza0JFTThDMTQ1V3hab1J6SWh6cWE3ZzF2dWc0aThhTUdZdnJSek5ZcWlXRi9mcE1waVRJbzZGVXIvdjN0OVpuNVpCVzMrRFRkN1kzcDY4aUhHdkVYd2VNUkVmNURZUFRGN2RDNXpCaGdZT0l4ZnZqY0w5VDZBUnY2MGw1YTM3bHR4dTJ4Y0Y5SVJrMXpZNjFIU2tSVUFmaTIzam41bERwS08vRnlyRkpOUkdpVlIwRGJLdDBBUDdsVVV4NzN0SGZTODA5NitOTkg5eG5rNHh6OVJnelBwdi9scnVBNlNyWXNhM0d1NHFGQ2ZEcHJvNEQ2d29jOEM4Wk9JWW1ITmllYW5CNnYrWEM0WFlMUS9mRmYrT3F3eHY1cjQzckthN003WFdtdWZrRHhBVHRjSmluYm9iSHM3RTRwNnlsT0RtT1ZCTG81bWtqUXJMNU1rczhQWXI4MTQvbkhBSzJHeGJZaCthUE9IdjZrWS8rUElzTG5RZ1U3SS8rMEU5VEQvRmNHSngwODJvNGprMk1xZEZ3RC9IUlcvUTVkUTZyS05CeFMvYkJwdHpuakVtOE9jMmlZc1ZsOWU5czM4RHZ1Ym92cGF2MkZuSG02Wk1weTY5SGFkU3RVVmJIMlB5dXpwK0p1Tzl4a1FIKzhWRzhwc3FwVlZWTzZSWE1HWDZpQ2NPWVdqL3h2YWN5RUJSWHpDOGdQd3FOczNuWjZSRjY2N3VTc04wa3BpcFE4R3pLNFNYazhRcnZqK2dVbWs0UWFxbDMwYzI5bFUvQVJsSGY4MGlKbE5OKzAyV2xDbHFzcGZJM2hSU0h6WlFHM1dIdUErNkhMZWRxRXhBbmJZM3lXMnlOQ3RhRlREdEJPWlkxZmtHTUtxMlkxS1RVbktUNGd1UW9IbWp3U1d0Vi9RQ2p0SmljYTUzc2crMVlWL2g0ejRDQ1VnYS9zdStQQ2xldXlHWGJhdGNHb2hxYVYvbTZ1Q2g1QWcydGxnRWxSaGhYYTBPWjUvSDJkUS9SNVRLQjN1M29jM2RheTEwT0hMTi9pN2JXWCs5L1YyRmNwdXR3bzB2YTh1Zkh1YklzZG1WMm1la3FqM2U3UDB4bUN6TWZQYmJqak1TMmh6dW5rWFZpUks5OUxYeVUzZkhXV3VHeXB6R3pZT3QwUzBuTzZlR1NsakxSM1c4NTJwTUFtbnR2ZTZlWmF1N1lRelRLMW1RdSs5TC96SzdkelJGM0NlNEtkeGVSZU5pcDdjMHBTc21yUzJsVWZldGZkbEZzUmVMbk84UnRlN3Y2OHpHeXJDTXphOElJK1NXYVNPRlljbUpOSC9ldnlPMFc0YktCdkJqeGNvUzJhcm9iem1UMzNRTGE5WHY0bmZUODZHbVE4eFpmOXM3TVYvNS9PdC9YK0liQit3OEVCbk1GcDRsRUFNMXRKUTBPdVdnNG53b3dLVjhIME53cVV1dUJpWkwvZXFOcWtxZ0ZkNDQvaXlNTDd2aW9XaVhKUHhWY2t4aW0zanFsdmRIS0JRQ1hIYytlYWt3Wk5IK09DT2lSc3NhV0FqVHlESmtLb0xuckRqTU90STh1cHhVOGVYT1JTMlB1LzduWlA3NC8zVTcxQ3EzemQybHBBNExOeFVabWE3YkUvZXdMN2wxVDhOZlBNRjF4c3V5Wkl6cnUyOWk0SkNiSFZhTlQ3b0lmTGUxM2VJbHFUNVBqVHc3aCtRenRDUVFSUnRXOU5tUnN2S0Z3dTE0N1N2aTQ1b2R0bVJ5SmZzQTh6aTFnbldpNUMvNW5PUkQ3K0VEZWRESGJST09qNncwZ3VGZWdkcWxQQVBIRjZ0ZUFCTVR2NUVMOHZtL2hDTlhwQTBOcGwrdXdZNGhsNmR0L0tSRmR3ekZoL2huSlVRZ1NCaXN6ZVRYb3Btc0l1TlBmMWVvemdoZXJxV1VKMnlSdlo3Z1JBQzhJTlN3MnEvL3NrM1RxMUZWcjhBdjF0OVhwekpPdkxMTWpvWEVkL3RJNlNlSTlzZXNYb2lmaVBhc0hvbkhBZVdJSTgrdlR1UjU4QWQvY1ZPS0dvKzk1TjFwZ2RpSWhpdVNaSHNISnA1QXZ1QnNQcDg5Q2hsWVRrUm4xMno2MHdDWjhCcDdzY1FQclJFSm15MXdEMERLTkFGcG1rR1J1amhybHpnRGRBUG91dDlTdU9BaWFuMnVZSUJVV2tUTUtDa21UaXVGL3hWQ3pWNlJhU3ZLa0tybjlkeGNZNG8wR0JUTEk3K204OGQ4dkZLczNjNTFab2drSmNtZjQ2T2VFMHVUVElGbDZNL0pvN3JyZVJROEd6dlJKWi8vSTlKTFpuUVQ3dmRIcHJ2NTVLOU5ySGhNVGtpYk5HbFRKZUtYeG52VGRIbml2Ym96bGtqOHY2VnZrVTgzRi94c0JKdVlhM2cxZ1hxYnJDbFJ5Uzg0em1aWkFnTVJTZDRCNU9iOWpBMkJpYmx3UUcxbXBueSs0UE9KejZVYitoWHVsN1FtNGhCTW5SKzZrZ25xelp5NytZOVVvclN4UDY2ckE1QUx3eXdvZGZHWUdqVmhKUlBBRE1qaWJ1bDlXcnNMSTRVL1ljN3BTKy9XNjNSSGFpQWV4MnR1Nmp2aENkd0hlNzN0WHFkMjJNYUtGVXdBVEFMblkxdGJPWFVJdUM2NDJkNGRWcTAxZTA4NWRDSXJ2Tmxka0VGdHpSZlJtQkhIWjQ1c21OdmRSNXdISnZzd3ZZeUVKVlh2anpJVXp6SWtOVlphc0xnYjFURzFueDBzRHZSK3ZyemVldENtemdRQW1JRTgwTTYxNnEyNUw5dnN5MDNKN2IzQ0pldTlIVGZ4MEtLN2YvQlhrSHYrcFQ5cmsvTjlUVVg2RDY0SkkvL3ZJMURsNnVIRTF4Z3BPRGF2ZTVYUGNzY01OOGNhcGM0bEVWQ2RadjhqUGo4NjNQY2FyejN2MGlCWDcvNjEzK0VSQ3hvdm8xWHl6V0wwL0x5L1RXbTB3b3JtVG1nUGY5d2VjWjAza1EyUFRjbHFtUXhKeDRmcHBKZXNORzlMUXAycHNYMGl4UnQ4NzdhU3BFRngvc0lEVzhYek9HVjJFLzNtb0MzQ3lTRStQckk3Vjh3ZERBQk1Bb1VKNFVHaGI0bHBxU2xGa1FVcXltK3dDdE5wQjNNV1MvVTN1QWN3OWFFVkd3aVROMWs2NDJTaGYzcjZqYTZFS2p3ZU5jN0RFeDVUbVllZHhaNTI3andRMS9oRW9LamVuYm1kUm85RDI5WFJzRGtuSTlUckVjTExNS0Vxb3pqL3c4U0xjc3JWYXBkUWxEMEZkSVF0UWRIVkI5MW5iM0lDRmFrZnE5eGYrbVFtTG51YVIvaXRCeXZzNWg0bWI0cEgreldOWkdCdVBpTXljYWl2TG1Zb0l5eDUvOHZnSjc3ZkgxMmd0ZHA1aUVJQytrOHVTUzYwNzE3eHdqbWtaZkx4N01EUkhpeTBVMkhva0tHWEF6a0R2MzdwQkM5WEdWeVJsQ2tEZmdWRHB1ZnpOdFp1L2w1bjVQWU5CbWY4MXkrZzJEQVVUaHo1ZnltUnpwS3RnWFFBRXJSQW9qR3dhdjEyUHNORFM4S1VHS2pxTkJLRXpzWldQcW90cmx1b1Q0RmVscVFReUxRemhrZVFoNjNJa0pEQXZyUGxGRWVUZjl0NXVKSTRuaUt0TnlVZ3FEaVlwWnNPRUdkR00xTWUyTUxobUFjY0g0bFZZMUZhYjJoTGR3bVJrVlpxY1hIeTVzS0lkb0ZPaDJxL3RRMCtJRUFoYUV2emhKMC96dzNwRkZTaExNUkJhNzZBeThDOEllUitDVkVBVHBSeHRwTUEyaVJBS3RFWWl5T2pRNmN2WXVLOUZ1K0ZqUmtJcDJqZCtKUHhJR0xVK2paZS9vYlhOeGQxOHBWVmM3ckVwNTlScEZmRkVpRUdpcnhiSklGVlIxMnpueFQwT3ZUMktxYWVsNU5kcEUrQ2RtOHExTEh0YTEzWTRGRHQwMEFkV0hac3Jrem1Yc2Fza3RyT1k5WFlzNGxrUGdxLzdzWXlIQkJaZ090bkd6L2R6NXhFVDY5UnFoZFpDd010T3NUNmxjeGxjeTlKSFFNMlYzYUhZb1VOR1hjVjhrYlFNK2pNcmlUOFc5cnpFWnFKVlZjY0lIVVNKR1FBTkhPL0d2S3B6S3g3NFFYdGxrQm5yT1hra0J4Z1NhT0xBK3UzaHBIdWZXQ01acE5ZOGtiY3pRa1ZuMnFORjE2R05NcWsyOGFrelF4MG5TalFYb0Ztc1VPTlZORGIvYm9kZEhkclV6OHlUU1lydjdnTXBvcjMrZVpZTVVLd284MVFtTVkwRjNIYTAzZDR3UFZqYWFGVmNrSjVVMXVrbGlueElMUEg4WUVjcTcrOGwrUVdGK0FXSFIzenMzdW14VFc5SjlBdUp3eEpkVHROSnJ1ejJnTkJFd3VlaDgzUXpVa04wUUlnOG9xQWc0MnF6MjBLenU5MFZEMzhFcEx2YTBVNjdPRng5TERXdkpNdTVidE9MOXZJYzlTejBkTjlRZWxEb091cnFKV0p6YWN3K1RrSUJWbWlIdjhJaXo1cG42aUZ0VHd0RU5Xa0N2TFZrMTM3bmlVTXQ5VDhJWk13bnBvUm1Pc1ZGc0JKM0ZTdk5HOU53WGVuOFJWMjRoWGMxYWV6QTlzd2FjcjRiOGhydndrU2xPUkM4N0RGVk1IWE1CSUlhNTFpcW5oZWhnRkxHeUtCSVh0NjJtQXE0U2dEWEh4SkU4Z3F2VGFrUURvbVNNZENaNWtlTjNQcDdCWFd2VHpxRTZUUVNzVzZneW9aN2NpQTVMVDhERzJjU0V4d1ZrMXhUUU10THJvbkI0WUxJZndNS1VzL3lqY0trUi92UEZrd1JwZmpHQnRQNEtYMW5IQ1ozWUQzVWxxL3FGcXkzMDFLdWk5cHRiWG5SVTZuYm1iUmVxdU1iVXBwYlZwQ1FQcFk3bldKVFhlaUZ0clVlT0pod3BDd3NpQkFWckdDa2hJM0tOdzQ3ekcrd0N3VGVQckNPU1hkNjdBS0xWZzQrRkkrNHBkRWtZMnNHWGcyUStYTjZwQXFPcEp6aTM1d0JOZTVyUmdiSWRrNzRleFdVd09pV0FNSGxQeUdlMkt2UUtlN1lESEJ4U1E4Q3BBdTNRL283azJxUHlpd0xwVFdtaWJMb1VpMFN1ajhsdG5SWlVscmFMSkxhMnY0SzNrWjZPMEtSS0R0N0ZEb0ZoYlEwYUExTmFVL3BHeWY1NGZ5STJRSUNuejN3SGo1VFhib3B4a29wWkMvTDM4NHZ2WDBkZXpQR1dsazZpOU1TS1pRZzlFeFQ5SDlTN1BoZ0ZNTFp3dlRsMDNzb0s4TmV3bEIrWVUyM2E2SzlWeVJja1cwUVRaa3NaRlprZWlYM21iNXg4dkQyY2JLbWRZUEM2eUd0d0J6N09heU9vQTJVRHFUSGQyZHRLK0kwWVdpMmFBYXVhaXBlM2VjNmh1bWlFU3dhL0p6bHo4Z3c2OThWVGdETk5ZNjd0U0s1QTk4NGx0R2djSEsrUXl3TzMwOXRGS1pnUXEzTlRYN2dXU1NEM044bEVmVnUzdlVsWk1uQVJTakV2cFdtcE9SYWF0YUxmajVOcm40ak14MU5pcU1GQjhWa2tOSEVPRnBRUUd3cXlOQmRTa3JLZHh5d3ZGZ2NtMzE4bmMxWU5qVXpJNVZVU0kzaWdRWWVkVmJUaDl2TEMxT0xyS2x3LzVaMUJRQ0pUVTNFdW96SXBnS09YSVkyRnd3WDdxQzV4L0hsL0NOdmNENXlNaHM2dkhsbkphWTgzdm9nTVFoMFRyNFAyaWNtUWFDUkdBYUZuWXdkaEplbitmNGFjVjBOMFN2MWpSWkJMWkxPSS9HZThTTXMwdDlRR05SVGhCSDNqU0owbEpua3RERWg1cUcwdWtTVnZiKzJGaTNTamQ2T25YTmFDQWx4OVlSYjcxcDgyZkJ1WWw1WjVMdkhCOUJjWHQxcHdZYitSTmVDZms0SW9LZkNDOXZ0MllBcjZHV3BYaVU3VDJSUk1TdU5PdFYrL1R1bFZSb0x4dStOdWc1VkdkOUtwa1lIMmlCalQ3VDhWeE1RVVh0UjJ5Q0JFbjdubkJYNmtRQzZldjVSeUdQOXlQSGFBaHh4b1hCNlZzY3FOVDh4cVM0MTRMaE05TWVLV3NlWlFNdEFWL1RSMEtRcnE4QzY0eGhUOGRFR2JJS3I3N3VISWIydWJsU09UeTlTN3UyU0U0aEpEZkpQd3RtQ2JSelpVenpoeXBJVmxYRU0yU2R5MzBVSTBYMVp2MGVqZzBNbWZWMGZCc2ZiL3QvajU1ZmhTak0vRlJFeEh2K2NzTVlJZUxka2NiZnYzYTJpMmpyZjUwVGhBQWtGamxvZlhQTmdRM1pFVnJPdlY4Zmptdi9jcjd4ZHFWbjVjQThVTlk5bXNBUldyWitIeHpJYWdpTDErL04vejRWSDIwUWIrclFXa2k4MEVSNzFGZnlaRFkyeENORkdzZ3VKTzEwSk5iZWJERzFDRng4K0R4OGZONnRZK2k4dGFDYlJ2VzVzQWpKeno2aW5zOG84d0x0dFYzNXFtSTc1aTgzK3VuNjVJNUpzZ2g0SUlWR2NhQWNQWDNkUE9hejlrZnFyNnpaVVRVMENOUEkwbVFZOEhVL1RUazliUCs4dE9FdzNUWC9XNFVOaHRZWUxWdDJMN3p2dkk4N05Obk9zWGwyM0ZHcjFGZFlxdXVkaE9kZnIyRng1eVN2UDlBMTlvZE5tUkdlUExEYmdqT2piSGl1d0FML0V5SEVCSm5ET0ZKU2lxQ0ZCOEhkaDdqNjdldTNUcCs0QmY0VE53aUlLa2dVVjc4dzhlcjY4dWhka2NGREdxcE83MW1PS2lWTE5xVzhZbTVLaUdXeUZDUXcxb1RZQjZxV3lEa04vc0JndUlNKzJvSmJuRHlmZGN4THl0UCs1UUNIbUNrNC9lNlJDSTB0RXBVaGFIOTFZQW52dURUWnRKQnJxRCtUOW1RaU5DbXQzVWlEQ3lLY2Q3QzZ0LzlsMDZtSEtIYVlIMTdra0k0dVk1Y2NoWGJZUGlDNkVMYnZnZTh3My9pNnpITzhmeFlTbGp2UlVwWTJGaDVDSGxmcEdUTEJEZ21HU3lsN01Oa0phRVpBelU1OStYMHRXbnBWdmZmeCttbXdONUtScnVGZjJQalBpVUh3Nk0veGV4L1VvWEcvWS85ZE44akRCWjVJZnlTMk9FWE9uVVZ3VDBxZnZEQ3dhbkFjZk9ZL0lIcTlLVXVTVmFMbW4vTmc3QVNlWTM1anZDc282Vmt1K3J5VXIxeExoZkFSOHlyM1RTWTFSa3U4RjFuRzJJdEJqT2hENzZFRCs5RjVTMGdmaC94a1YyYStGRlF5UEFNZXJTSUVld2ZyZXFPRWFReFFNU2JGQWUwUENub284TkNubG5PbVJlVjR6S1FTenVqTmNNcitXbXpWQlpFcXhQSlVUNHhqMnd0ZDVNY29kZG1BelpMYW1EcFQwMGRqOWdkWkQ1SURnYzNCZjh1QzhWdCtQcVlpTFMwVjZjY0VVaWFSTHVUSklXVnNWa1lLWEQ0YTJUdVdXNHU5TEx4TkJyTmRXUThsOXpCVG5sUis2MklKdm94RnVRTi9hbjNXbmJxYnNnYlpRMkQzWnA3Q3VrbWV4MHpoeFdDQlV3dFc3eThLQzlJNk4wSmFia0V2ZytNSnRaNk1xRjlJMm1jYjJoOWYrSnk5YnJ5YWJhZEJOTjBvTHgyaXJhN3UzTHhycGpmWkhIQmE5cnN1clJ3NGw3ZXpTc0lLc0tGeCs5blErZlRtZmpnb3hkL2V3dFBDQUU5dzlMYTNnWGtiRlBkVElVQiswaGFONG5wZHhaRVI4UW1oRVphZTd2Wlgxc3lscjkwcWM0WHljeTdUcXBUNUxEMkdydkxwb25jeFlSeTBOWXdjUFU1amU5WCs5NHRkelU4ek9qRjlQZFBMNitOUWtEb1hBeHlLOFkzRklQM3gwcUtlT20vZS9NN29mZGM1QmJGUXErcU1hY3hJbmhmbGxzNnBmM0J3SDhDakJKMnJvU0gxZlljdTJUdk1RRjMrTTN3SGc2WFdOcDB1NTBxeVAvN0ltZm1IdHVkTjJaTVZpeUVqZWVGaVVpYVdxcWNzelQ1aUtoTGlkRlJHUjdScDNFUFlRNG1zQVBFTDdBT0tXbUJpUXVWTm5iM0ZEWUFDNngwK0piWERUV2FCVnFFUEkwZTk2bENMejVHeWYzUUh6ZUpNOGVMR0JiY1B2aCtuYVc2bjdwWkVhMGZzNjZaRTZ4NTJXdXNXOUpPM1NNMG5NUldlNmZlbzlRTXR5c2ZzU05MRlNBQTFBeS9RSWhLcFhYSXpqeC8vcWJuTDMvanZ1VTUxN0duT1JOQVZmZVdDaisyMEFBWVExL2tnaFJmMzRHNXFCbkRsVi9CTjU1L29IdHVkYngrZTFvVXNDdkZPM3BtdG9iYVZJc1hMdzJqbjVtTVZLYXNlYlgxbWMzTEdSSmh4TWxpKzhrY2U1d1pOYXZMOFZSK0tpYkh4YUVlSXhGSGdqUXVVRjBrZEdFa1FvRy9wejVEQXhnZ3JpWmZBcTdWaXo4Y2V5L1Y3S2hSaVY5RGZFYVV1elhLdWhkSDc5bVQ5OTVMVGZ5WkhpaUhsR21vdFZFdmtlY2NuZ3dWUDVrNkE2Tk9TcFVPakhGL0Y2Rk1ySVplcWkyTkVobG5rRmV1ZW5OS2tJNnljenpVMGhoUnE4azlvckU4RUpDejducnROcEd4TkY3L0h0WWFiNUpveFQvdDNmZDdvclhXTE93d0I2Tm9XK2N2R1RlVVY4ZFpWVlNoc0wrS1E0My9qQW9Lb3oxZTlMM1lpMVFHS0hUbDVSVG9vWVAyKzVmcjFDQmVnMlBDZmMvTFArTHVlMTQxQUdxUmdUZEJ2czU4aDdocElRcmluOGpoNE9WUE1GUXZhbmljRFlHYWJ6QnhLWks4eU4yaWlDUHFYT0pZV2J4Z2dMVGUxb0RjMlo4QlJoRG5jWm5UVDNiOEhuMExwU0EzamRmMnRhdTc2VnhNTmRqM1YxOEhRaysza21BLzVlRmdVOWJTQWxVNnNpVVFQNzlJUzVkYlNEc3kwM0wzcXFKczNzYWRBNzk3Z0F4YThJZFFYdk1EUklKZm1JdXkwKzZLbU10cW1udFg5WXZFbGtSNWwvN0VQdk5sV2xvZzUvU0FXVXJUcTMrMnhESVIzby9COEtZQ1lYbE9MS1FyWDhwZmxRYmJoMktmeTE1dXprOWt1a2JMZmk1dXZabVExbHBNek1sWFAyZStGN29jR1l2Y1d6UGVjdVBJdjlnWXA0RHk1Z2hlbnlsOXpTWVJiSlFLS1hEUExIK1ZPR1VpSHZqRjB3bWpIS0N5RldXMmMwaFhCT2wvMzlkVjFDVkRIUDFIbjMySHRFS0VLeHJ6NitObjBNUkhacjJ1dUpsdXNZc2ZyTlErNitEdXBJckFTM2tqUHNHbnU0WUFXNm45RTNrMkFKWXdoblNsRGpRZGNMdnFiUFpITGdPWW13anZUbVlRYjJtck1obzkyd0g3VDhOTlpXUHdJQkdleUplbVFMZzgvaENubElNeGtpNXhLZXgrZ0pvaThkaXJMOUFSN3Z6UW8zbnJiM0VJV2ZrdXhlZC9td0tEc0V0aHdKd1RZMWQ4Zk1CamszM3N6VjA3bjJwdjc1VUVXeFRTWER0cUpyb3Z3VXlzMjRVczlJRlJPTFZTZU1JVjN3d2MvWW54cDdHWVhJdkpiOUJneGV4dWY4SEFsOWlaZ2ZQTkVXejh0YlQzODFGUkl4d1hyOUh5YysrK05ZQ0FaNGRGdkc4SGovU0RpR05OWlprTmFOQ1NOMXZsRnNIWEZzcjdRMEZqUDA4N1dtRkdXMUFMR3Q3em5NbDdKc2FJaGxoMS91anlyVWMrZFRwKzMyaEptQkIzZWEybWJCRVp5aWxkUS9JVm1yWHhPK1RNV2hwSW9CRE90K1ljVlNwbWlYWlZnaGpmRW93dThiOWxEcW9xQnNOMVJqTmluWFBFMUJUWXlNK2lzRnhsaHV5cGROQ1RjdGxhRmV1SW1kY3Q0VVJxcmVFSk50Z3pyK2lxSnMrWi9EQnlBdGM1RXNVaHFoNmdtdFVXWjYxMm0vOE1tYU9qMTJyZFlLeUtCT0psTm9qN3VZZHNMRW1vTVBoZmd2M3F6N29MMTkwV2s0TC9mRXhadjhHbFd2M2o5cnlWd0tGTTBDWFZuYWJ1LzgrblgwR1FUQ050WWxlV2FWTmVPenhpUTRsTWJUcXVIRTFGSjYyWWVuei9pU0F5b0g2OEpPV2dpMnhDZlE3VTk3Q00vOXZHeE1DUXZ6Z2Vwd3RpODgxVUViTUtHTnpoZXE5Tjk0SE40K2czVjZGazRKTXNTaDhQT0RvUS96ei9EV1d1Vi8xTnpSM05uTHE3c2hzT1pXbXRVWkxRV0FZc2hjNU5hVEY5dkluUE1mRnQ1YVVzZEFneUlySWlBeWRZd1NHdnZZUWRWTDVzQjJ5bzNBZmQ2OU9lU1RiUkRiall0SkFGbEQyUFRFc0d0WnFEZWQxTDVQSlA4TlNDbmU3T3ZPUmNteGpYRkRvb3JranhGeFVEY1h1QzVQaENKb1h2MnJlZk9zNUpibGZRUjZ0N01WUEpoR1hnUFFNb0FvVEZMcXJjNFJaalRvUnFUaGhFMG8xaS9aRGs3UzdqaGNmZlNoZnBBWTZKdVNIQWJtS3VnNFhuU2hHbjk2akFEbTZ4dUJ0Um5rdFpTTEtXanFPcnU3OEkvOVEwTi9wSHRXZTEwWW9oSkZscEhpOWw4by9yay9qcGdhcFBVQU9HWVFKVGZ6VXBQTlV3YmZaeEY3RUYyeVVSZlNBNkFocjQ2cTZ4OXBIM3RVbGVSa1RpNTgya1A4U3pkYndQVVo1SFVBelMxWmZYL21RMk1menRlamd4VUJ4dUJvNURXeVhQdzZnTWlOVGtvalNReEoyaVFBYUVpRDE1Ynp0a0MrK005UFJ0RW9Sa2NLbm9yUFRNYnRyZjlybmxuMGR4bk5XM2NsTVZ5ZU5CZEpaSURlaDl4VE1jeWFZQko4Q3lJczFwMjhqKytaaCs5elRqU2JlWXltbVFNNi8rZzZ5MGV4VytZQnF3RlV4OHFPQ0NJYzZ3b29DQzcwbGNjaTJvcXlQYjZVM0txdDhkVnJKREpyckk4aGN4L3dybFJoYThNdlByVVVndXhuLzlsVGNxdldqaEZ4ZVZaUm1IQWhYQ1RZMG9wVXJ2ZFdROUJ1OU9XZFNuWEpFWUM3bmNNMk9vYmpQSmc0RE9yUVlmcUpiQ2tjaHgzTk9TaUZHei9SQXcrYjF0MVo2ZTRaWDJvVSs4aFBVRjI3c2NGb0gxbHYxbWM3VnFPMlF3VHBmNFV6RFozOUtybTM1dFY3QzdVajhqWS85a2NSTTMzUVprWUQvVllWUWtHT1M2V09QV2dVSFN5c0NGVEFLa2Z1YVVzcFh2cDQ5RU9jeGNHVkNBR2hTNklDSTk4amwxcGJ3STE1eEdVQXJaZ1VHYVlUMjlCTDA4V0FlQVdkbUc0RTE3cGYzMXZaMkRxc3QrTGcyd3BaSDdOTE1FSC9pWmRQeGFRVnRuT0N1NG9rbCswZWZwaVRsU3hTdUNHMEpJejR2NFJ0ckVHdUk3WWpVaFl4TXJFajhWTjVKZTd6RUhodE40dXBuMzJKZWF2ZjZ5eXpQNlVQMFIxOW14WGJQeDJsWk54Uk43SDdUOE5LS1UxOWwyZmxzQmRBY3kxbGYxUlFVdU1BTVZmcG5wRjRFLzNNMzExSFBMTzhoT3dQVTRFeEU2eW5qeU4xZnNkK3ZZSlJORUs0ZFJSUjZ3cFVhOVFwK3BSbEVVSkxiaEV1TkxVcW5hZG9nQkVXbnRwSko2VFZtUFpDczI2dEpNYTlqTWdMMDhETDUxUkd0OTBodHQrWWVDcVRsUkdDSG5wM09mNDk2dWF4NEo5WU9jZkJ6MlJZdnRERW4vUHdUWEtkcEFMUERDOERNd3c5T0hTRmdLRWIrOTlmczRFOFN0R3VzemY4UjZBUi8rdkRHLzQzOU1YbWhCcEwxaUdxdDhqYUl3TTJmN09OMkd1SE1xOHl3OGtFQnRscm1iVlpYdG93bUk1VERhTmpkVTY0MWJVdEYxSnJENnBTYXRUcXFVbVVNanc2S2dXZHlldnBxRVBWMkFSQ0lTZ2tKMmt0TjllVGYzS3ZLeVFDTzMxd3N6bzNsODk4U1hyVDlaRU5GTW9mdEpOalN3dHgzbWVnVU1NZUVXS3ZWdzc4NGU5Uisza2tqUFI2SVE5QkJQZjRmZVcxZEhWNTBMMElBTHE0M3dQTHc5ZjNoeUVNeUJzOElNUHlabzVPNEpIa0VSN0ZsTU9VTVJIbDdyOVZIZks3RnhwK2NqcG0rZkt0cysvN1JLdnhuaHBIZURtUFZVT1dka1dQUGFuY1haZzVqNGQ3M0ZSbFQrYmF2WnR6UzM2MTd0REh2REV1N3VXMy9WZzM1ZUhoZ3d3b3c0OTNOT3V4bWZNcVA5Uk5vL1Q4VUMvWTZNRkRDdTR2K2JwcEtQTVJjaVRvY0QzQkowd0dMSzhOQStTUnNndi9TREx3MWFqQXdudlJEN1FrL3pOYjlEam9laTA1ZmJJWlpxUS8vdUdJZzFqUUtOR1JhUmxFa0ZISTVwN0c1Q0YzTmhTZStuZHZFVDljS0Z2T2JwM1VOTXVYVEpxS1FyblIyWk9uVFQ5ZFJkMzhxbUdQTjA1NHhlNXNkb2s1cTlZOHQvTTQrd0FIbjhEWjNGWVNwSk1tS0RES3dzUVk0anpKOXBRMWxqb2crbGw1dUc4alJ5RjVpSGV4WW14Y2pISy90VFI3T2lJOGV6eE53UWtLNVk4Sy94MXA1NlorUEpmV1IySGZyNENBNlpkcXlYSGh3UG1FQXgvcEpLSytEVThkUWY0TGRFT2xKaFExSk9OTS9MR0JabDRpallxN2U4S2o0Q25GVUxGRUNFSUFXUWl1WUhUdStHbGptd2VJQzRCRWY5YlgwYUFuQSs0WGx3V2pzNFMxaDQxUFlPM3ZLRWhWUElLbXFGY0tYS2xJaUIrb3JVTGNKR3ZJajBJRXV2Y29JSHc0S0ZqczFaajRGU0d1Rld0N0NEa3JNVFNBRmtzQXZIUUdQaElnNHVseThHNUpJbTRNcm1ldzdiUEJVSGl5eEN4N1gyQ2ZsR01XTGRvK0dZMkx6b2Z5NVR6NkYvbDBESlBYSXZGSUVWRHZoQkN1ZHV2Y1pQUG52RkNMY092dzJWRGE2bzBKb09rODdZd0hyWWFRVWNiMDFOays0MVZRblVTaE00dTA4WkhYNU1kTE9scUtXdC9HeDdSZXpHNXNBb3J2UWRPQTJidXNJRUphYnNKdGVQeWphUzR1Z3BRRm1FMGJYU0pCNFZoRlB1aHF4NHZCdmlyRURmbkc5c1luZkM4NHJIaEZ4cEthUThLbkZSSkJUZ3Jsc0cwVU5lNGN1bmQ2UmVTZjhBdkxuRzlGRHdvOUw0RlRGMnRsT0NkT3ZIVGRqdHZJYnVlNmx2bUhhOGF2SFhyd2w3bS9qYU5VdENmclhjUlZLZ1owaVo1Yy9vUG1ucWIyd2ZMdzl0M1lwYnlxdWlvU3JyTGwxSEJKL3FrbjNET0dlcTFiejNYZlhIUTI1Qmw2NWhpc3FsQ2dxU3BEOGczUHFUZDhvQXJoQ3VGaE5lSFZFSzJ3a3ViWXlxbzFpTld2bDIvRDZxeFdxRzNHSzN1ZEcrRmF5WmplVElkNWh5OWZoS0h3V2RmVm5hZlVFMktrc3Y5NkVESHFUWE1Gb2d2S09zRks5NlNOTHkyaEpEOTNjRVFGMVJzeHVqbDRlRG1rc3N5d1VrcjB4Uk5YemhMeVFrZC9QMXBpcGxGeXBwdU5QZ0QyRnNLbFlITkdhZjJ0OUZtbzlxMXJmVllSS0dHVy9GNjB5aXM3KzR3clVJWk83R05mbFRSUXI2cThuTWs4V3c3QkNldk9JeUhXVWxwRzUzaktZS3VLd1dtdkJQb21MQTgvNkplWXZreDd2aFdndEJKUTNNeGFEenBNS1VZMlBTWFZWbmpqR2ZSbzJjZlNZUWVUTW9QUWFYODZ5OUtjWElSQWFsSVovSjJxSjkybWZ0d2tmNFJCQnVRcUFWS3JtK2hqUVVKSDhFUDIrZEZFNUNDcXc0OVZxNzNzS0taY0hKZ091a000ek5qT3hhaVNjeUoxYmp3dVpoOFV0Y3Mway8wTHp3SzdtbkVqTmJkcElDWHp0OC9URlJEaXBxSDhuSzFxbzl1dk5qUVpVYStHS2tmVkpUN2tSd0hrdDI0T2R0T21wWTUvekljQ3pLOEhtQ01vR2lORFFoQXpaMkdXVkJVajhhVGhhc1FBNzR4cjBlQUNWMHVNTkdlb0pGd3BXN05NMjFjcXdFMkdVK21Tc0F2a3dYNUphQ2w2Vms5SllybDl6eWJ1Q3hFVmlUM3FyejRXUERzczI3cDlVbkx0TjErOEgwdGhTTDRlZ1JtYVBBT21QVG50eC9ONUtzRkZCVTdINlVwa1A1ZjR3c3Q3ZkJhUmZ2aWs4Q004UzcyMkVZL1VvcDR1UGFzL2s4RWZxMjdPSXpWb0pSNTRvdjFPLzhyZ3BSb3RPMTQ2VDJQc3dqVFAyTlNGU2xVclhzcTgrdGo1cVNmQkJQWHNDL214anBkTUpRazhQRjZUZGlrenptN0hXQ3FlRittL09GTTd0anNpUHpTMlcyczNHMndkWmgwMkUwemwzVnhGZHIwWUd0MnJKNWxRZTJvVUltaGRNMS9mcHpjSzNNdHFIWW5wM2ZYeW9XbDlwSVFObnl2WU1xMXFqSk1palhySVY5ZW1PRG5OQUNGMU1pQkplUzBkampGTzZvMjNpc3lhbVZMUjlaeFltMmlTb2pXTzUvUVpKSmk5NkVZU2h0ZDdrYkFWclhFaUI2K0pxeTdVTG9oaUdveldYME03Z0xsdEZqNGdZMW1rVlJnQ0NaamM4cm1LS2RKWUMvZ3A0cEIraG9EU0RaSFNTNWdVbFpOMG1MOVpZdDlUVitScXJrYzBwMGRyVmxlQlR5K0xKb29xVE5pWjFlMStkaXNUQVlwLzZhUnZpUFRqd3JXVW0rTE1JZitPTEZMeUgyblROMGxtMEN3TkpDN2trOU82a0VOSEREb3FCVnpvTzFqRW8zTFZCcytObnlIa2ZCOEp3NVR2enVVVW16WFVtVlYwajFkSzVyUk4rQ0ZTZmNOV05mTTk4clVuRng5TlBJbzhsZWVScnp0MXdWcHF5cXRRZTJybHhlaHozTms4QkYxakVuTERWcWRvRkFDK0ZRZXNLTUFZbjhpWW5HMXhjcHB1cVNRMXcyakQ1anJUMFJtazRKMlNwTHl1K1ZUS3duRDBua2Q1dmJ5akgwejgxTEg4S3hnMEU4QXNlb2pmQ1B5czdaQndNak1obUdxbWIyR21hM0ZmUURzeklUbzJLejZFWnVsaFpxSnJnZmlxNHhRZkhYc1EzN0E0ZlRNYjRjdk5yeGd6VTlZRFY2VTJ6aXlOYlpWSFRuUHVheTBObDBiTkk2YStsZXplTDZRSHhubkZnU2xEOVc0QkQwOWpWZDkxdnZJZ1JIajdjSjJlM3V1T0cwV1NEenM4UEhTM2J3NDY4TGgxZUhycWJWOWVCT085WUo1bkx0OEdxNEd0bm5EdjA1ZnZRU0NHWkVXNG1XVzU3d0Jhc2JHamtRYlRIZ3RBWWw1V2QwbDBoR3JCVHlaS1czejc1Mkh6OUtLYWxQamFEbWU3Q1VVeFhWZ1VZeVFsQm94ekNpZDRxcWJtcFpKRDRVOTRkeXdUMHdwVHlhbjU0ZmFaTW5uUW1rdmtqTlQ0aUhoTGZLNjdyU0pZdUFGcDgrK3NPbVFucHpQNGpRekxmM2VHek9rL1hTK1huYmh2SVNXNkw3SUV4alZITjNVQ2pNN0Juc3BVU25CSHhGanZrUTlQV0w4WFJ0NDBOdHJPRFhLU05XOHUwY3p0b0RmUFp1UHQ5bUQ1d2hoL1BXNWphZDJmZmYxSTdIN0NrVVdVWHRmWnp3SklBRjRybFJLOVJxQWFvQy8ycndXNlpKb1Ntc3g4VWExbXd3bkRseEhuUE84Sk5IRExybFBGU1h5S2YrSXZ2OTByVkoyZHJjL1NzLytGZHNQa1pJTE9qdnVuYy9NRnpMdlNtLzVDOGE0ekRvb2RSVmlEU3A0aG42RkR3eGVrajhQWENGbURIdXFrZXRVK1AvN3lHSWdiQjJ0Y3RXUTNRdVhBZHlua3pYUDhRN3R6ZUxFYnpRVWErVzFGTFN0WmFaUkYvL1lJbVJ5cHFYcXo3RGtMUGowblh0cjNlTE9nMUVucmNub2dRTWxwL1RPZXRiVjVzZEc3TUMrdVhEWnZMK25qNzdxSUwwdlBaUCs4SnRtSW1jVWtLTkVaMXZqY04wNnFlRVRDODhnZnBhNy9tUmpSTDVlbHFhNXpsTlhkZFlZMzFzOGxlRXVQUTd2cG5NbDlxcmpwbHJ1MG5OMnc2L0E2bWRkZ3ZXQWpPcUwwZTQveG9rOEtXaGIvSVdlRTVFak9FSUN5R1Q2OWVWNzFnRnUyY3FXaVMzc3VpQWI2dGZ0NXhJMkFodUEzWE1GTW8yZ0laRmdHdDRuN3dYR1FBV2Y0OG81bVBqYnpsOHZtWGdRSXpJQzAyMWd6VjNFWHpTV2xiY2YzOWxyRjRqdll0ZTg3WThqeFVmVnhPUFNKVEtCb0NDZW9tSU4vSHF6dzRQa0tEaFNKaW5Ea3RjUlVwSlQ1MkJvQXpWMy92OGFtODNzMEduK0EycjI5NjlwdVZ5QmNtK1FsL0xDR1VSMHltWnZwK0hlWXdsRElBa3ZpOTJBaVF1Vi85NVRpNkh2VFg3dktNelhOR243M3k1MEdSNTdVR2k5YnlpZlJFQjlQWk5FODlwKzVKM0tPVnNYSG01cER5c3JiMno3YnBkTU1vc2ltZVdQaVRMcjZuV1VmQk5ndE1MdDhFK1F3L1NuNlhYd0Z4RFZGVXp2QWp0YitWa0FndHBoNFNxSjd2a0tmdUpudmtTNWozdnp0N2twNFFTd0ZuR09rdkFvN04rY2hyTWR0NllxanlreW9RbDV3UkR6dWVwY2ZyZnFrUUFVMDRQRS9QaSt2Rks4Z0xka2l2R0NoaEVqQUhSNWt3NUVOMEp0c2pkSnhOcWMvR1Rrb2gzTUVOWksremhmZVp3VjRKandlNDF4YmFXM21XSjBMbnJCd1htVlFIWkk3UFdxR1lsMTdSeU5Ka2JoUEZxZkpycDFrd0RueTNTRDM2bHhMTS92S1RPQ0ltZHZKY3RpK3Q4K0xOWnpncG0wbk10Q3VMeW92bStseUNrQnp0WlpZOWp2Yi9tN01JcTJ2My8xUVA0RDE5U2VSd2dETlo4OVlEanRhZ2EwRnhDZVhEUUF0cHd2WWdQYk5Bdmxnc2xzV1gxRFpqQ09RQ201YVdtM21TWEV3Yk9oTi9Jc2pCU0p4UkZIeWVuMVdXekw4ZVd0Z1RFd3VtZ25pWEVMV2dYbXdtMldBT05sZ0N6UUQ1ZVI5SHdzSTIwZSs1aVV2M2lXOC84Smw2NlpHNVdCSS9NeE1ZVXhEYUxabWkzL1ZIMWRTTndsc3lTLy9kY3V3TC9rZDhHdTNZMjNMYUVJRmhWVEhCRWJDTTBGQi95RnJ3SHpZVFZoSTE1d3ZVQUwrZlh5eFRZbVo2eFVzcjZyUkNUQmZHUUoxWTlOQnpsMENUSEFIZkhUaGFwQ0NqeWl5YTJXM0poakJUQmYyUi9UZTZnYXg2MjdBNS85UUlZVzRiQ0UwVnJFWk1abUZKOWFxTGxvalo0bkg4dG9uTTRDa3drb2hPKzUyclZYRVlYL0h3cExKOUJNa2MrNWtnbEhjOXF1SFNRaHNoc1RuNUhtQnFVYnY1bnFYdUkxcUlQSHVHa2llT3haT1BEeUZzSW9QQ2F3WXJIOSt3Z2JvZUpYRU5zS2ZlNldZaUFqS0ZQZE0wQVJWeEN6Y01WVEtsbm1PR1FYNVFUc3VQQlBENEhRaGEwRnJydjJRMHA0MGdjMjFjMDI4L2VWVlVJV1pOV1RRSzZMU3E1bUhobnA1bUpUOEpmQVVlQmEyVXk2b1pzNFZLQUFSa3AvVnUrWWRtNnNHU3Nqb05xNDJHWmVHcWdTMVhrQkM0Q1g0SFJnUXd4dWRBODFCMmZrL1IvM0Q4NUFMeDVuNWh4dEc4TkY1STY0aHJrUk8rcitmM1pBOGRPUG5DRFJyK2o3TFB4bmtzUUNlQWgrQjdaWUphWnB6QmZMQTY4dGN0V1BJdVNWbS9taU5BRVdraXkwTVRrc1Z0NTVrN1JtZEN0YUYxbFFxRDAyUGdBTi9BNHl1RlR2UjZrRnRIWWhLZ1U2Ykh2aGNtY3c3NEIwWWtuOTIybG9WV3hZTDBzT0EzdVpEYUhNcVdFQUhpVCtkVXpqRkxmMU5IWmY5ZlJpRGdUN0FqUnNKanJYbFNaUGxrdm1qRTA4bG4vRk5rbnhKU3pXR1VUUy9TbERySmViUDhEdlFveUFJL2lnN3JPUWlsNWFZVnpES3B5bm1uTHBFSzE5aWRLWS9GZlNsUjRBSjVyZ1Z6bDN5Vks0N0NPNWQzWUZ5a1hQTHpNdVlzT2E4aTdFbHlaMDRwNDJBaVBvLzVrUWhwNldXZi93aHVlYVZvMmFiWnllWTR2ZE5NVHpualkvVXFMaHNXc2lYN09uQ0lkQW1pVjRDTGhSbEtNbXlNK0diZ2pNS2Vsb0JFMUVDN3BoZ0graHN6SXFPdkhRYkc1ZndNYi95QnlPTDFBcS9KUUpYTEJESHJIR0tqOXVXWW1YTFd5QndaUUtOVGRYK2dJbmhsbFNFc29WUFpMRkFiQTZQUkNhY2srU0pCK0xCamJqaUpJU2ZXOHdHYUZndFhtOWlnWWhrQ25Ud0lJbzE0Y3JVdzZ0bGh5bFdjYnZTU2g2RGJESk1qaUhFZk9IbnNQMXNPQU53V2lRdWtvM1ZHV2wyRmFjemtZMVRMSm9oR0phV2pvdWlwVVRyaGFXbXhrU25wWVVyQkZCTWNYWjJoYWFtQlhaMlVVcldOSEw1V0U0QS9sVWVPcSs5bkM2Z2FYL0NtMXpmM0hZR0F1c2JzZ1ZNQldTZ2J5cjBlZGxJYm1DenVsRDgwNC9zQVhnWStFSFpEdW9COFk3cUZrRkdKd2VTUG42RUlOOG5HMndJT0JWUGZBODZvWFlPVk04Nkh3QTVYOEhpNGNwY25IbW1nd2FRQldxUVNrL1YrbzBteHM4OWV1U2tPN0ttQlFVOW5scEIxTEJzakZPc3BqUzFMUU51cUNHVThWOFBPRUpscW1nTVhEM2sxU3UwQkFMelU2Z0tWeFFHRGducUNzbWNmb2lmVGZBYTE1b2VySkxXcUd2aitQR0VZZVZSVkhWa3RPQ2E0NkhGL2JqV08venhGeEt1bHJlNzVDeWFJWlZTRStkajkvTFJmSTQ2VGdCV29ONm5TOUg4VmMvcldzR09XeENBNXRKM3RocjVLeHVaK01JN3F2TTJWRXg0QkE0ZkhCa0FucytTZDd5Mm9UdEpNNTBNd2VkY3BQWGo5ODNtYTNRZUwrdk8xNWcvM3NKM1hhUmw0UDFONzFMZlRlN3JUSmFMQjlqWmFXL1UyRzFZbjlrb1AwTXJrcUpaREp1STJndko5NXYybzI4SktlODhiSlpoVWloUUtQbUhYS0ZBaThlcHlJWm9ubDhKS1RjTlVDYno1RVhZMEdub2lTc3RQZ3Z3S3VhVmdSdVU1Z0l3M2xaR3JSUjhxcncvMDRtc0JlblBWY3Y3ZnVLczBNR3l3cm1hTXE4NU1hRVRFcDhwd2VyOGd5bmFhU05jQnJxMnBLaTB4aGREdVNlL2ZyTVYxMnJBYmh0SG9xV3ZBbTdadnNFMVM0bWZ3aTEvT25aU1hyS09qMmx6VFF5TmlKZ1dmUHBDSzZRdi9JUnpwc3pXUTNXcHJIUFhpQjI4cFYvS0o3ZnVjK3p4V2dDZVB6eUJaSXBzbElkcEwrVEc2aGRtMGV1OXZaYndZVEFKMUI5OWwyVjBSajFaT3ZLelRSblNoR0ZqZXV2Z1Q0Y3lvQW5OYnpwUHI0TE9jck8rYlRJL3BLMmNRbVhvSCtlMWd6TkVWSXRHRjhTSU9rVTZBQnB0aFZvUUo1aFNIa2gxUVBxLytOUWdhNUJlVW05WUw3RjNYSFNEZDd0em1HbGxIOUFQdzZEMUlyc0hZeU44eG51aUFFTTdvd3AxbS9aR2oveUI4YkJuak40OEQzcDNrMjB0OUxtZk85eVBISWhFbzBsd0YxOWY2S0ZsWnBsSVA2NVlySndYYU9wZjN6UVNUK1BTWXJSMWdkS2VsaUJYem5UOE9WcTNYUjZGMEVXcHA5NHhmaHNjdis5eElkRGNWejlCb08rak83d25vU0doMWptWlYzOFg1bWZvOXk1REtTUUlKcWVqQ0RHVTBHQmNFdkRCREI5RENRbU9vUkJsUGNrWHpnbWtwZkVBTlBmOE9SVWE3ZmlZNHJJVXBrWU93d3g3cDBSdGJJaU9zbE9LM0crTGIzL2ZucURCU0lQSHhTelJWcG9QVTRLQitNWm94RGRTWU5CQ2VNQUJJdG9WZVA0bHRXc3ozMDBCYklTajArVlUxVE9vWkNrcEtTbWQwMy8xTS8wY1BTUXdpYmN5WGVQS3V1UzVPWUtaNXUwaTZxVXRNblc1aHZjcE1SUE1wNzlLVHYzalhzUkZrT0EwbnJ5K252QW8wdmRKeFFjcUVmMUpNV2pzZFFoQXYyVUE2TGNRd0ZUcGZORnVEdTY1V0lrM2I0dzdiOWdmSTRwM2ZMSnEvMkN1VHJuZFE5VmNSWG1CWFMrMVhCSjU1QWgxM1Zjc25EdlVXdlJ2cGlrc2RydGFqWXVkZTEwWkV6WWQ1Zk1QSjM4a2JRNk4zYXFTdUQwS3ZLdUo2eEY4OERrWjRKd2RuUXgxV0Y2UlRSKzdMRXlnclRVYllxdEdKNkVQVk5HaTBaa2d4NVVUY3RrTmx3WGpzamFqUDJDWkk5TTE5aVRLMEhBMjZWNjhkTXc5cWVSWkFLMlV4NjBuSzJqSktyQlFka3QzSHpJUkt6LzUzMU1LQUtscXQvdkQxZEZWNUpLVDhTbVZhTGo2UUtDSE9ocWt4UEQ0QlN3ZCtNbUxaOEgyODlERVZwb0NkVjI4SDkvVEFhMXRHNnRJYnVTUC9Hd2duN3g4TEkyZC9UZU4vQmVQam9IbTdEU1RwZUwvVnQ0N3FhWnlwaVFpZml4NkpESitaSmhMaUV1RlU0SFQ0V2RlNUVia0hXcncveW85elFLQlNBRjU0MmI5b3RCem1neE0rSHI1Zi9GaVI3M2RsTE5FZDZFbExUZVJraHh6UDNvNlg1VVBoU3RsMGNRQ2lOL1pBU3VjdUFDUytTUi9BUXJXcWt2TmpKd0I5QzNJQUZPdTBLUVprdEZFVWtyTWcraVpvN01qSmo4T2tvZjZDYmlhS2dCbVFxS0JXU09KdjBjanlITTdrcDFtVEhiSDc2ZFp6RGU3bzNQMWFmcDM3dW9aNSt4OE1mMU10dlpQZGVtOUkvQ0R1T2VVaitMODY2THJkRExJV1lUd3FEQnZKL1ZFM1hTMUFqL1F0VHNJdFBiNk1BeFJNMDROTER4SFNZYmFXNXRmTTdwbFk2OForK2FSNGt0eVFmclpzVVVGaWVSanFOMzk5RTRRYUQ3K3dVRWFxdFplcHQyN2RzKzhrUDV3bUJkN1VTOXgzR0UrdDFXblFRd3VINTJJQ3d4UHdRWkZSeVVhaHBnUVQ5KzVUOXVoMjJ1V0F2WnRETnY3ZERzTk5kdXN6VnlEOVZ3bk83WDBTYWd5YXJJNElTZ1FEK1lvUjJYSlo0MW15V1dOWk1sbWFZNmR0UmVpamRMa2FDTTBXZHJCWnJyK0Y2eGhyN08reFVkVCs5LzIzclNmOXB2MlArd2ROSXZUZjl1Q1B6OXROMjEvMlA3cmdBY0hPbjIrMU5rR3piMlA5dmJseCsrbzZrZFZvVXJIRXJFeHFlRmc4WG0rZU9ON0pUYXhPS2RJbUZtVTM3bDNqRHpHaTNKQlFSUnd1Yy8waWVZUldHdlY5empTLzgrMjYvRWNhaStNeENUbkE2a05HVW1GbUVoY1B0alR3N1FlSG9TY24yL0NCQ0lYZkI1c21uNCtjcXh6cEtSaWFSRnVuZjJ6OFBDaHRadXhvQ0ZlSjE3NGhvc2FBLzFRS2JDY2FKbFkzSkNTV2xBYjdBaU9EQ1ZVQmV2aDlUSmFDTzB2S2p6L0x5T1lVSnZ4K3NGNnNaV2g3T3RGeHJlTGtyUC9ZNlNtSkpja2gwY1ZFOU5TUytMVlNPaE1ZblJNYWx3QU5nMS9NcDFBZGhiVWxhclFiWlp5M0ljSjNsQUx3ZFllaVRiRWJEVW4xd0hyK3ViWTJaR2lrcG5waHFiMW4wTXZIN29oblM5ZFVHZjQvYnRZeTh3WThBcTg1UjVFSG5iM1JFNE1jZWllSXBobkx0L29yeWliNmFmbnI1ZHdjT1k0STB0Q0NOUzhNaHFscmpnekNXNVltMndkMER1REsyYmlDL3NJT09qcXlKNStzQnYwbTZRZTI1V2ZVMG9JRGtxT3BSS0tJLzE1OWN2bDVYWGpSU2xxSkdhazdyV0gvVWxyRUsxK3ZTd1JVbU1RVXFqRitLalRBdmFOTzBZQlV5bm0wYmhhZUdCbVlneTlJajJaUDNyVTNWdzFER0UxQ0VlNzBwN0pGNGYyOG90ZkVQcGZVY1FlUTJjL2ZoOWw2ZXdZUjRHSFZUL0dVSXpPRVJDeEEzRWhYMis4bnM5Mkc4OTRxZlhjakRPTEkzZ2FsdWMxZHJyU3ZTRkllL2Zkd21NY2xKNjkwU2Q5NGJaRTJiM3d4eDJvZTVmaHcvQTk3SXQ2K0YydElqMDJ6SHZ1Z056UlF4NzVPK3hxNGlia1pSa0txNGhIdVUxUWtLY1pXOGlYd0tvMlZOSlJqRmFLa2dVbmI1MUlZQldlU0dDMVNUOGFZWEVzL1pqb0h6Z2VRRlRLVm92VEcwcURBcUs4QzhRVkgxNDlpajZDamlJSnd6ZGtMSTJ3ZVdGNnlCQ2pVMGJsalFlbGpmVHZiU21RY1QyRlRxc014OEx6dyt3eE02U1E2cWpXVHpsdHZUeU1kTmk4azFaZlhCWVpIYkV1VElNaTg0WlhvTHlsamJlU2o5bGF4WFcvT29lbVJKTXFVNHMvbUR3SjFCMUwvMlQyNUdhcVI1cHc2LzlQbjRyZEZIWE5MUlpZRFV2Y0VKQVJXUkxheXU5UFNjanZRZGFFbkNvY3hhZmtEclNwS1MwdVFaR0RYZnV0T1hucjlTUENPR1hQNmlSU1hIVk9EaUNKOFJyU1JVT3UvNzhzSWkzaWlwQ1hmYmJPZHdQMHR3cTFsZCtmbkZnMDNLTFVYRHlDUzhrWmFIditkbGx2ME5xYXg0TE9EWDcrdk95bE1NSVNjV3hVMUdyOEdGa1R5eWVndUpjVktqS1l6c2ZUdkJ4cDZNN3hhUWV4ZUplR21lSlliandXZE1Xdk1TSnBjWVlKQ0hyODZwSXVhK1UrOFNxOXRHbWlpZ0liVU1rWnVOU1VXTHNBUGdzKytaYjM2ZjhES0JKQzRzQlFzQWVXQXcvOFh4UDNUdklTNk5jN0pyYnpCMmYzYThVcWxzK05IYWRtZHJkcE55eVBwRldwSTkrSnhsdzJscHY5ekhJSVJmSVN3aE5GbFYzOXdXTXc4ak81YjJNbjB3VmFhS0d2M252R3Fjd2M3c2ZZZVlodmhwYmcvdnRHa3VYbG94aFFrSEhIaGczZ0Nqc09vT1ZGN3dGUFFBcDlBSnd2MU03WXJLenU2S3lHN0JKeTRxSVRHc0ExNEh3MmNmZlY3NGYwSzQ3WDNialBxOGpreWR5SHBxT2pyd3o5N2w3Nzl1ZTdRZnRLUjFEa0wxa3R0d0QwTXE1d1dpbEtNVnFrVjFuUk51REhQR0VlOWRuMTdZd20yNEpmOVZZQkpJWDhuTjdCVndJdjRaNWYweEdtNUNOQmtJajM1TzgvTzRJaTRVZHBqc2lCWVVKWWpQb1NkckZKdDVPR0hQQ3lGSlJmNXVEKzBkbk45K3NKaHcwdjdTVUh4MjlHRi9ldkZZNHZ2Rzh2THJwS1pYU0tqclRKR25aMFppYmdXRExheFViYkRGN0FBakxKTmp3UGdZUDlrMlBDVW55Tk1mN2RFNmlQTDJGYkI0akpOVmlmM3hNaTRmMmcrM3o1MFVaaVNqNjFXcW9yWXNaYnN2Y1VycmdzUlY3aW5kanBGMnZpWjc2bzNwcnRyc1ExRzRnTTc1c1NhZ2pXaGh5TGxHdnp2ZlNHcGZvNVhLUjNTbDU1WVY1cEwxWmFocGZtQVhLRDhIOTE5ODl4blVmR2pPUi9Yd25CZDMwZDRJTjV2SDcxanNXZGcwM29valY4STNKMmdCWWJFbUVEWVpUYXpxYU5QbXR0QW9lUDBybTZEcng1ZFp6b2xBL2NCNC9zZmtDcXI0cUo4b3RMTHVsU2tiTlUrdFZzT1lmeUxHSXNJejB6MzczR0J3d0pDU2txSlFmUGc1emxUVDQwSVFESDhoeDhWQ0UxVlNCQ3NYemZ4SzcrdFZpa1hadnVRRkx0WVZKMVlWNkpOYmNJSCtkUlF1YVJ5MWpROGJOalNOMHg2SnZtS2VtTHk4MlpsTVUyT2pnY3lRNFpQTmJsaUNHVmphOW85MzBhNHYyYmFaUVRML0lsZWd2UzlnN2lBeHZYbFhBOUIrMTU0cU9kQTc2YWZJVy9tc3AvZVJXa2puZDZkT1YzeEIvNGo5NlYzNDlNWktvalhzWGRETUFHMStDSzBrckRNUHlHcllxNndlM3N4UDlTNitNTnNuV296VkY5ZjhxSDMrY1lkN3UrN2VXaFFoaXhkR2J6aC9BTkFOWGJrYktEOG9VR3NxQkl5RWsvS0d2SCtoMzk4dW1yMHJzL3BvRy9aeG55R3hxN2xzb2tGZ3M2U3VjcUV0Y1pWaTRXOUFSVEdQckNhcjNpajBYME1mczNydVpDcmcyTG5WblJmWTVwbW1URFl1MkZXcUlFcFo5Yi9GVEs2QjlSVVlGMUhPWGR6TlRtdm9SMjRLY1BvYWJvR3hrdWxkNE9JbFlYNVMzTlErRGlBQzBxUUlaMjhQeDlndFJ4MUk1anZKdFoya0VXQW9zTjYvbmowMGIyMnByQmtTTjF3b0VsK2NBTjNZOUR4NVE5clFXNWNUeXNMTTExSlZDVlczZGY3TzdDT3lRUTdBcGgxTnRVczhndzAvSWF2Z0YxYktnSjcxMmZLVjNHNDRPL0RuUXQ4WndTL095Y2tmdDlQaGpiKzZlYkh5N0NCMzc1bmxyVEF1SUhQNDc5aFNLaGIyT2NlL3lDZDk2L2p6V1I2bHJpZEQxcVQrTGczZEkyc0Q4U21yMzU5d0ZpOFdiRk02UzRwL1FIWXZEdmhUL1FuM25jL0k5ZkJLVzRKNXBQclNMMVRoTTJzclh6bmI1NDduMHRlQlNRdHRLM2thT2QxT0FycmZzck4yS2ZKaXdwQkZRRm5SNkVsK3MrN2tub1VaZnkybzN6eGZJcmZLeUJQL2pISkxCemtQam9jR1hITStWRG5UTGs3M2thS1lNL1h4Z0FpTVdOcDlxbDFucVgybTRMUHlrRlZDNjg3a0ZXTG5jQit3N25GMmYxcFhOU2Y4dk51VmFXU3R5ZHhnOVJ0bEFLZU5FLzVId3NGa0VUcjNLMHN5SkpLMnR0MkI4S2V2R08yVGNqMUJDc2NONWZZSU9IVUpQeHFjUURyZGptV3RhejdRZ29sVWNzaU05Tk9MQ0gzVFpuTTlXeTVHRkZLU3lvaVhDVEVCVGkya09rcENVZFhUTDdrS09VMUQ5cHJjK2piTWZQNUJBTVluTElCMUZ4Vlp0cnZsSGZ1UVdRak1EWjljYnFWMVhxYW9jZG1vOVhYMmNsU1RjdTBOQVpuZUxrbzduV3VsbTkzeTVLZ3Q2RkVnSU9OMFBqdXhHUUJBa3B0VG8rK3BsVUN6TllNMk5oUTJMbld0QnA3TU0rYlRyZnlOaDYzNVBnQUdhSGtyaUhkdW1ZN0YvMW8zcDVKdlgwaUQ0ZUtweEp6R1EyZjZURTFpUlZsV2JhUllNYjc5ZGlmSFl0eTN3dDY4eDBJOHRWbDlpcEp1YjhXcGE1eWRvdlZlT0piaTBDT0tsR09sc3NTY2M3bW5qd0h2T1QrdDFHcFJDNElYcWZSdmNMZjA1bW40T1g1Qkl3VGxCUlptZXJwVjg5R3VmdlRIWnJUMjJuZDh0MUhrMzJHZ2FyQzdERFZlaUE1S0VPZWs5cXo5Q1hSL1hYb2t3L0MyQlhJTG02NDhucUhhdVZPRUpEVlVvNktpSTZLU3c0T2hFWEdCbVhFQlFZRng4ak8rOGJRV3M2a2xHT1dPQlhVUEZVUGYvT1dMMjNaYjB6SjNPQlVZL1UwUk1BOXdRZEdMa0VVam1kS2w4bHVzTzZkWWFZaFRGS1ppUlA5dWE2Q0pubENaRUxYczVLc2FQU0daYXhEd0wxNVNaaHFxalNobEMzd3Y2bVlMZXhJaUhUYmpGQ0dSeUI4blQxOTBNaHAwamE1ZW9CMHV3Z29ZbG5yekp5cXBwY3N2bzZBekZabVRqWnZ1bkZMcFJYcy9VcjQwUGEyb0hCYmk3KzZFSnYzNEFSL3YvOHNmOWJ6dmhiV2RlNjUrVFkxVUlES1AxNVV2MTVGSGRrM004dnQzTVNPTmxGeFp4czVobTUxNDZ1YmloSEcxdGZ4MkpmeDdyM2Q1WnVYbjlodC9yL1Y2L2poeW93Y2s1OWpUZDlxTjh2TEptQ2FIVkpxZWMzTE9HVUcrWDN4aGg2T3dlaE1jNU92a0VlY0tSL3RNVmNuV2Q3b1l5S2ZNYnEzV3FIc2h0UFRlSjhQQW5SU0VSY2xMY1BNVHJZVTBkTFYrZUQ3bmxhZzN0emxtMkdwSUJMY3J0dXBEcUJqSllOZzBQRzIrOXBBUmFpaExUUlUvcXVHQjlaUnhpV0RxcmVCcm9Ub3JYckJ3NC80QzcvVFhJUGlxNEpNaXhHRldZRUhFMDZ3MDc4MEZHcjdnMUpOL0VVZFhQQzJhTmF3OHRidXV4Zm9SSmd5YUJkUjBwUVhYNVNRZzA5WENhc0p2ZEttRXNrMitIVXgyUTBGMTVlTzZzVklQV214RktOcXNLdFBVVE50em40TEZoWGZMV1pZYVYyZ0lsOVp0WUdnSjZSL1BDenYydDV5M2hhQllWT0FkWERuQlczTWhGSDZsenJHbnp3UFk3cFBSNFZnRFNDcU0yYWpjSU1iZ0QveE45K3UxZG8ydHVibHAxSHZzY3d3QVRBR2NYUUkzZmR0Z3BmM2RXMlgxaVU4OGttaElOUTlUR0JYcmV4L1VydEUrb1FCcGdVNFRxd1pucHY2T0R2MDZWWDRTekxvWitCbUdNRXlmLzM3VXNpWW90SCtoUitTeS8xRWJXdXEvcjUvNzdkTVFaUVIxbnQ2OEVORHRQb1dsWmkvM1I2c2taTVVaZ21RU0dUVGU2N1hkZ09zRWg3Q0R2UzhTR2JtOHdScjZ3OWdvTW1ucUsycmVUd0NxS3A4cXRxUjZ5c2s0R3N1bnVGemEyL24vRXRPWDBLaEJJRWJKZzgvOWRCMCtKbWFHN3NPSzJhbVcwZjIySC94aG1KUUx2YVJ0eE9zajFqWmdqeEtrTEZKbnJiVXVHS3NqcFB6bXZKK3NaU3ZNMUxVU1k2bi9Rai91Ulh6cmttS1ozN0h5L0ZkQ2FIbEV0cWxaRmFPTnVPaUl5MklWMXF5U1htRXVsUzZBNXFjUDAyMkxaZDRhZDVkSWdPNVhJTDFhMTZBUDR3Y0s2V01rc3dxclJTRittRWhDOGR6SlFraWRONnliMTZXTjYwOU9CRE5Od3UxZHRBTFZyTlQ4WXRGZzh6S3ZEUzEzQldyVFpwb1VOOThjaGVLbGxiK2d3djlqWWhvOFhjMEdTVWF6QkFLNjlJYzRodXNWVjFRWHI1T3R1ZDVRRThWTUdQRmRTY0JvUURtbHBmdTF0aG9SN0NuT1lRaUJSRVNna1NzTkVqUEhNVythNVVvbnp3S2NCUUdVeFJWWjZiMjc2T1ZseWdDYWVmekNaUzErVVE5dVRVZjIyTlhvTXpLYUk1NklCSERVcHhxalR1eXFYeThhY0MvZGNtazE2ckxDN3VuMXFTR3FlZVRPQmhVaW8zejdCK0JKNFU1SW9OWUlJY0ZoeFR2YkhkaDZoekFKbzdTN3VUejcyUDNIN1FWL0JBa2JzRGNtRmxuQjl1OEYwQzYvNFd2YkQyWE9kVFV3OVpUVzE1SmwraVpsUVYxSGFuTytPTjVzcVJRc21hb1pkQVp3TnFLUFZmYTROWDNwa28rejlBc20wYUZkUWU2N2F4SS8rUGFDbUhjclJhSTM0MCtidGFmNnBUeU5lQWhwOEl0TWgza2RXMFZxZUxUc0ZMVXhjYmdJeFVnRFRKVnJUZFg0ejFvVld0QThxeXJaMWdQU2NwcTBrdi85M3U2U0NtcFJ0Y21CeWZ6Mlk1ODZpNUp5OWJlYTg4cXNhWDBzdmRndkpDelR6Mkl3Z09PU1d0czhMengrVS9aTS85WTF3Mmw2MGQwWjFkR09uSXpLK2hVQlUrQnJod09TMjRGbFVZdWZmNUdrbHIrNnJ5TjdiZkZhOHFNNFZORkdXUE1HNWgwdHpZb0cxd2oyMStWL0xreDBkRjlvNjFaYVpYQ1EwOWxHaEtaY2luTEVldHdBQTNYUjE5b1ZTK25yUGJNM3pPK1d0NngySUhzcXVxZlpheEhEdFZOeCtFdFYyOVdCQnRDNXFETXRIK3BLL1ppZUZsNGJPM1pqd2ZnR1hNZHdFaTdWQ0VadjJPdS9nSDVXMkhyRXNLN0FQbk90UEgxeXd4blBPUTFKbUcwc2xEZ2JFdkZzZXYvT1ZmU0hGNjNlOFYrQnAxQmhUN09SWDdSTHh3SnRYWlNZOUZ0M3o0eTVJVXBSWEFQcE5Hai9OcFA1V1BUVzkvWTk3K0JjaWVMTWJkbDVib3VhY2NkbXI5SW84VVJFb0tBb0VvU1oycTBMQUt4OVB5aVlUcTRPcmdtamZuWDdzUXJ5TFpmdFljQS8zMDRRNnJKbTFUdkRSeVFuSnhLTGhncExQU0pjRWkzcWZGV1VnQitrRDBQc0F2SzZ2bzhrRGtQaURBRTk4cG5TY21sODZDZExtT3lxWGtwSklwc09PK29wNlBycDRQWHhldE9Jbkh5U3E3eS9Tbi9Xb1A5KzIzVFpBc0hhalp3cU16SFh0WHdXWGhoYUhoaU83TTVDMkVwNCthUHdSMTN0ZUhxRXUvTlluWjN5ZUM0aHZCTjNaMU4wclY5YlMvZktmWFQvM1ZIZUU3RFNkWklqZXRic2VUZ1hINkNlQ1cwYlBqbytIRkduM0RlMkprMXJENU83MnYzNlJidTJ6aUpVdDZQNEU3aDRpNS85cHVQN08wcTNsSmtsWnJxeW5PdVdoVHV0SDA0ODdSTWhOM2RBeFRyRG53V2pQbGFCUmx4RWRQdjZmazd3SW1abHBVOXBja3NlalhFaVl1ZWlIRTl6dElXR2JsSHB1T2pDcWNwUmVYekVaaWlxYnZLbXRMOTZYK2FndjNRN0VFbmNwVm1ObTBROXNXWW4xWmZiNWtZaUs2RzJ4RTdvemRPOTB2WDJXNzZEWkJFclFCbmcrTmIvK1ErN3JNZEt6QlJtVHB0RWdER2ZVNjREN2JRWjZkRmpyd0JIaWRYTEEvRmVZN3ZBcnVPVTB4cDJ5MEVkSmNJaHlLR1RScG5SMUhYRDhQVmxPMG5Fa3dpOVg5K2VKNk04TTI3bEJ4NzYrTm83L3pta1Vtand6c2F1ZytqVzJoV1NSNURoeU4vK1F4TDdJSFFvVkIveEVqRE52cnM4cWRmNTNpOTU5L1pRSUtaWXRDNHhKU01xZGJZNEpMc0haTlhUWSsxZ2RWVlRKN0orYThNN2Y2Qi9RTk9kUmRmS3dsU3RlSzZPTUxEVVpTY0xMLzVGMjl3dUhtZ1U3K05naFBkd2VFVjVkZmsxandxRTg3U0NETTJLdkdtSXQzalZVYkg4NlE2K1QwMFcrN3czWTFhZWhxNnlWVGxtR2lLcnZ2cm9MNkN4VStTMmJ5Vk5mT2xtYmtCajByZDcxK3BHSUxZbTgxeWxyeURiQWk1STYwcGFkSS9CMkFCMTJIV3BNY3ZWSHBiY1dyRFFSV3Q3ZklmN0s3djJkOG0zVlpTNnFDeGRuY045Q01uaFlNb3QzYWFETkQxWnFTV21qbTAwdHJUQlFtVDZNTnRjajJ5SEZlOXY5K1NkL2JnM0M0TS85SFd0b3ZPa3VMOTVnOFlwN1dPSGZhS3M3MlFEN1B6UzE3djUxRXhWRjlhaVZLYzVIdyswOUhEVjdnZTNSM0xNM04vN1pVTk9selR3ZCtpV09ITGErMDR5WkhDUGZMK2hxMC9lcWRSdnNSM0lqS0lNbTg3NXJLNnBzYU95WUNyK1BXMzlUYVVmZk5IZHdFWEhPSCtJdnNUYUtnc0RIcWNJN3lING9WSUxlWk54ZmlhZytYbktjSGJkQTBZVldWd1FQcWtZSE5Pdkg5dHh4TEs1aklNcE5LWFRjcWE3UTBtNnZlNVgvekhGdDJzZUlENmM1cDdVNStWYUozMUhaWkRQTjgrb083dTJKWHZWTXpiRUVLL2loUzhCRzNrV3luZHFYcXN6bnVNb0M4eWJ5TnBFRVhNckhERFVXTHNSUjJTOWZrVnR6T1phUTNGZUF6UjQxeVo0SDRtbmwvK1NSYVhQdnBlSFFnbG1KNHNjNkFIWCt4eGxGTHNDbVBsZHpXVDNqeHlabllTWGphaDBCa0RTdFlKNjFqOW43MmpGV0NXSExyTlM0UFlsdC9XNUlBSkkwZDE3cTgydHd1d2J4ZEtDdVRYSUQyNllpbS8wc0YyQWlMTXorWGwyYXVrQndaU1B4N0owYUUvUGU5RzFtdFVBU2I2MWd6VjNQRC94RTFjVjNWWTJGcmJNMi95TnJZM2ZGOUJSOFBBYkZuZ3RlSnhYcFJ1ZEV1bFlQMmlyQk5FVm1wY2NienBXUVBRU0RlUTlMRzBRK0k1MVNtNEdIN3lEc3BFM1pYZG5HVXBWUGk3NG5mOHg0VHQxOGFXVmtZbmpoQ3NxN2tMMllncW9mQ3ZqMmdScnFQNnBkd3ZSM1VqdTJ0OHd4SlhZTWtaL21MajBoTWJ4UVU0WW8rbC9TZDdPVlV6MzF3ZGhhZUplRkk5RUxDNFpXenZuWVpET3JPc1ZZWHFBdmJ1RzNXYkVZMDMxbWZhS3U0MVJ3NFp4STNLWnZaYU8yTFBFRnNucFhLbXRHUUlIWW9OZVUyNFRFeDhRaFBVcGpOd01IbldCZzdoV3NVUER4V3ozdW96K0xybWR4Z1VidXBnbnZmU0NHUko1ZjZJbUlhTGpiQi9iSEJOWnpwazZVOURzbDZZNzc4MFNNK1FUaW95OE9STHRGR3RzSjN3OGVHSHJKTlh4ZHNPb3JLc2hvQklnOWZYekppaFh2SWtmdjNxZDhwS3VMTjVHZW44MWRPaC9iL0lDSm1NSUdmTUZqVUhlK25mMGdIL1JjYTMybk40VS9qcDFlZEhEbTVhR1IzWFlVK2swZ0lCRGdQOEgxZDVUbkNERVRFYjI4T200bG1QeU1KUTFnWm9NMVY5ZjlmUFZYSk0vNWR5a3ZMZ2ZPWGlnS3doVHBqckE0dVhpWkZ0b3RIVlBZL0xCWmJkQTk1cEhvUmRyaDZYdTNmeGxUdUJ1QWZoSmh5ek5aS0dBQWdnKzdoY1FDbGNBU3dPVE5nQ3hwa3FWQ0pRRmo0TjY1eUhzdjBBc2p4VGNFejhkVDFqS1drK0NSdktjZ25xa1Z6RElLTzlBZ3I1andPY0dqTmhMOENvOHcvQ2VPbW1WV3daK1pzSVhpYkd3VjN4VTlBcXZHVFowUEJzLzJEM3NqUHJoai9tY2NLU1lkcEw0VHVvT09RSXNyV0sxb3I2VHdIUXRQZjgvVEswWGk4WCs3UFR2ZnhtWFJiOUo3NFF2QXliVGtQWGtrSlgrODZURFB2d1RFdnRYN3UzSWpNTzJEMUwrY1VBWlVjZVFENTNMS3BYTG1CYmNvQjBLS09CTmt0VU9aaitpVEFNMFFGd0dad25uQ2lNeDVDakRNZHFXcU9GVXhidW16QVRBbTJaVXRKbzhiK0Y1dXgzY3F6NVViMTh5d0l5R3JpR1IrNUF4WHNWc0JudWtSd1QrVGtYUjdQTjZjZ3ZuKy9pSndsaUU1NDdBbVdCSk1rcnQxbEpyYko4SHNhRFBJbDYyN21pNjFKS0R4d0Vld0NtMW9XZjJUTnN1WlppNnhseG1xWGhFbjh0a1Erc1NLZjhGVSs3aytkUk9YbVB6SU5DZi9uMGo3NlJrZ0N3R3pzS1FBMDd3QWtkQ1hINW9DeTUxbC90czFHcndLQndydTJPVUZpMzYzL0NUQlpTTFBVaGRicWlvNG5OQzFCSCtaOG9COXpDeXY0UzhpWWphWklXKzFUbEhaZGlYMEt6ZlV1bjlUaUdLa1dqSDRDY2s0N0hxcXpPRjRYZU5aVmhPVThVdVc0WVB3bDJFSnRvQndJbXg0N1J0b0V3NjdtckxHTlZHakJNYlRHMG5oRzRvUFJweVBudkJaQ0ZESVQwYjNMTlRqR01Rbi9TMEdkTzAzMG1ZRzUraHZpOTkwY3cxN3hBbWY4aVVqb1JtVGJBU0tuNE1EbmlmMXV6STFsOE4xWEtiQlJFVVpzeEZvMytpMk1HSXFVS2pRYktQU01lSkhvR0tQcDBybTVlQnpDMlhHVk1KT3hpNWdZcXBseGdPY0VyQkJXREtvZ2E4aFB4YUN2Z0s1Y1ZlM2diRkd5Y25La1NoZFlBcURzNDJxM0ZPYlpkZFlBNkMxRm41Y0QrL0Z0MTZXanp2OUhHZitWeVhMaENkWThTUkxpOTBqeVlKNklwMkNUWDBzZ0dGb0NWVUlsc3ZDc0Q0WE9HbkdlblFvTHJuS0pKbmNYZEU0QWxpMlRYQzhodTBnT2xJVHRtZ0tuTWxrNU9aVEtCZi94SldIWHBWR0hoUlhMNjhpb1NYY0t1S2NRRHpsd1hnNW1pdnZ5NUl5M0p4V0NoMG9kblJkSjMzWGFYT2tLb3V0aUhUcGRucWljTWZubDRkQUdBUGgrZVBvMS9rblU3ZDV6RVA4ZEZ5Y1V5cUlvODgwSkFGTEhmZnFvTEIyV1Y2aFF0cWtXUmJSdVRJNFVhZG1GSDVJTUsxMzRMMGU3bHJXV3E2VEF5clZDamtiWmxNSlVTc0VnL25MMEVLRGllamdGNDgzUUJJSTVHcmNuOGkxZzN6bmszL2ErVXVoTEZaS0tOZ3J3bkF0MkhieFgxaUdsTWlVcnIxbks0a3BOVHBLTmk1eGc3VGgrR0d3VGV0YWhzWVhrNVVOMEZSL29KeXdseTJGcHNRWUpseGRMeGVvMHcwRUtSNkpPTS9HYkRqZWs2clRzYllsZ2k2eE1LUjFHQVo3ZVZlQStTRUgxbmhUN2R2VURjTkJHeCsrT0piVFpoUUVFMWVDNmpuaVhBam5DSXp0ZlJRS040aFAwK1ROYUF1K2ZoVjFOQUE2R1p4TEo5aTVaOWpoZjk2NHRxVDFjU2cwMWFHSjJVZWpEWkF1MDlybE5tTkJ2QkE1M2lZa1l3UjNpeWpmUVQ3aFpWVnBaOHBTZHF4ak9ZVlN1ZEVZeWcwNFh3SkdYSytJU1MxL1lqTW1jMHhwUCtWeW9tckk3TFFETHJrdHBEa2tVckkzS2N2QnFaNjNwaS9UR3p2VVVLUTFzUHFpL0t2UlNwVlF4dC9mbnBqN0RQVExleU5VTjFLUFMwME1mbGNmdXgzZXNkNHdBQjMvem1EY2pnRWxHZk8vQzJFQ1B6SFdjRmYrTXpMYmRoVVFRcERLYzd4MTRHL0FMakFadll6Y1pVY3UzUnAxblJEVHdUcW5CY2xwdUwrMVQ5V0QwaTdDckNIRXB0d2JrbkVQSDEwOEJ3VGtFT1BpYlQ4QlZSOTJIN0dVdEozQzJmamlhbGVUSVhHUFNrbHk1NENJbWQxM0NPb3ZFMElTa3hueW5MZG55d2dHTWlmUHNCazVWNm9FY21LZWRhemdEWE9EOFZBaWtPTy9qQWUwVzMrNFBNSVZlWkVndGpOR0RHMUU1QkU5QVZCVzg3NHhJcHY1NGdqZTVoa05YdHg0d0VwSCtQRmEyWUtXK1dtY1o2U08zcFFyM1hUQXA5bjQrS3NieGVmdVI3cVJHRzRUREtJNTRyNTBxQ3Y0SklKZnpEenNwbzhXU0pEZjQ4RERkaUJJeTBnMDlzOE9rTndaZFU2KzY4WWlObTZBTkFyeVB6L29lOTVRTHJ0UkQ0Z25zckN1dTZYcnp3UkRlSnRDaEg0NGs1K1Y2SThLdWgvY3V2MXpUR1oyays1UVh0Z253YzY1Y3NhdGIrTVRIY01MZ3BBRkJINlE4RFNjd1JmbTA0QURrb0xPK0VIUm9MeGlJd2RZVjBSekFFSWFZZ3I1MDBmNmtGU1Zadi8wc0dyVWw0VXpLWnFPbnI3TFV5NVduUUpGaUpVcFZxcXRhRHNMcUZXdDlGOGZ1OHFteTR5OFJCZFk0L2lSeDlLWkJvdEw1MXVjaVVMK2J3ck1tc1hnVmg5R21wa0xzaEhmOTZMZnNNcUV6b29lb2x6UHR1S1IrUE5xQzR0NlZFanVzVUJNSXJ5MnFGWWI4eklZNHlwSElCd1d5YVBMVU50ZE41S0V2dm9DczZZREtLSE1VcHUzdGtJdHZzYlNmb1RQV1F1c3loVTRXYmZtSTlQaFdGeHlKczRDWnRkZTNaQkxiY040Q09BNjlhNjVzeTBEZnMxaExzMDV4RTFncXZYZUNqdlk2TTVNSlV4M1RkV0VyZFdIS2RhNHZPVmN3RW5MR0IyRUZzVVFlQkM1VDhESDEwSVBjMjdTeDlxWVpmWHE3d2R4bjd2Nk5kYklJTFRnNk90eFFMTytwQkpvNG9HM3RJQ0xOWUtEVXRkZGxzU0RlMFJBL1pOK05ERDk1SEJ6WlJDcys4MnZSTGtNcVBwa05UUUJvN0VaU3FpeWJmb3FscUNjdTA3TDFpRHphRjUvUlJKb0ZFdHBQZlFsV2xTbHp3ZmNEcDZVWWF4REkreFVYMjlVaHp1cHdZWm5DaVJYTy92THI1VUtURW14M3NuRDNjSFA1NXk0ZlVGN0Y5YWNXRjFoU2ZLT25DdzRwREpaVjJ1dlhOa3VRNE5VT0xDcHRMdGtuZlhLMDQ5SVd3ODdWUWMzcU1HR1pvc0VLOG92TlpSQXpQcXlBa2VTeG9PZktBaDBsTHJqSktTZTdXajgxMUduV29LVklQelhjRFNPSFFHNVpNdmRCUVNaQW1rMHdFdE1iNHlGdk9OTi9ocVFiaDRMZlZWY1ZaNjhodHI4TFJqSFZqUDBPbTllZkpBTDVrNERDb1BKUmVDZHZJUVp2dGNKRFA0ZDRJY2xzbG5Ldjg4ZnRDVzhVdWV4Nm55M3loQS9LVkhaOXpubCs2THQvUTNqTDkrekw1Mnd4VFB3RFNUeGdXSC91cXRCbkVYOE1tVTZEN29mNEhWYzk2VGQ2WGdTd3RIai9uMTlZRHBQOWhoY2tIM0dMOHMyeERtbUxKcm04U0tpbWRwMFNJUWVwbm1iWDhoUUk5bDA1UEtnME1mS2VwVFM5d3MxcmI3OFhWSk96TmdxMVB3dXB5VmtmQ3JXLzZMQW1RMS9Hb2U4K3lreGQxZ2REcDhQVnF4THZIUFFMSmVoRHhrbjZ1L2NkaGNRcnlpZWVqRUNvUWV1UEVHdytWQ1E2OW1wc2tVZ3BtdWpJSXF6VlphSHAyU0RDMnNYY05EM3JJS3cxcEticDJURENIdXlqNkJSWkIySHRaZzVCb2dkMEJxRjR1eFM2TDB1cEN2cGt1czZFcmpQK3J4NGw0aGppQ2xUc2dFcXptTzJuS2VpendzU2FvUmhWMmU3NExlR2NDZStJT1FrQW1MdDlLVzl3WUN2aGtXcTU5cHJjcFFZZE1iN3hkU2F2T3VQcUU0OFNNS1krOFNpMHhOK1ZaaUx2V1VwenhxODNGdCtNMGZDdzFRQkV3QlhOS2hMVmFFSUVQRTRzaFFxTDZKWklyRXpqcGdDUStNMHR6RnFiRGZGYXRyQXhraVR5OVp0eVU2WWQ1OXJxc1V6alg5ckFMN3JEOEV5YmhsemJWUHllQzQrWk41WHdWQU9OMlNVTWQwYjhsb0Q3djdLT0FRV2ZsMkp1QjJJT0hHTXhUc1VyaGdsMW1EUk01ajlSZGFQVko0Uk9LcXdVOGdYa2VNVlMvQ0NQMFQvWDI2dkhJVlZXTHJBeThRK0ZXZ2NGRWprSzBQcVFzVDM1RHZaY25EVzJDSTJ5SVhvVVQ1RndSTE5jT3MwNGlYQXhrUlltbEtCS0JpOHNTbEtaQkp2QzhtSFRwNXR3eFBJVUVuazBKVTVXQWZqNmVrRXVUTUVGTVdtTUpnZXROZGRJR1hIbStrSFlUdStTSEZoUHdlVklsUDJmZGttR0pSTjU5V2kvMXltTm82R1BtZVFLMGZBR0hVZGRuYm9ScWtPSEtqV0pDTlBraEF4YktIYzU1MktyQ2hTT3h5VXRNNkoweENLY0cxRXkreFRIa2NvQ1FPZDdTbDNqS1VRVGhoU0ErRkpUSWUrVTBXVE5KdDJrVDJpZlVnSU8wRjlIbWVROVpXTFExVk5WcGV3OUFrSUcyTU4rcE8venAySGc5V1NleG5zN1RXTzdyOXNyRk56Y1NFUHpEbnFrUWR0ZG1EVzNTMHhVcCs1b0NubUZUKzN2andtejN4bm9sdGthdkNJWUd1eS9lK2Yyclo1dS9IQjEzY0FzWFAvWER0L2tVUTBmMk9CL0JMMlFyazFkY2pqd0xQMlJaM3B3SUY3akhOWWdmb0dQU25EUk9QcVZrdzROd204ZHdtZnhGdnF1UmVEVnJIdGhCdjJzT3hHWDJiNEMxbkUrL3dQWWUzUFVDNmMvc05TQUJ2V2wvUWpRV0Y4QVA0ZlI0RUs5Ym03WWtFYlh2bUlhUXNMSDlMT0ZXYzV3SlJ2ZDA0eHRCWUlxSGhVQ0pyRUEzUXdOQllWUGhpZHNLQTVEM2JTZFpWWFJDYjQ3cnlUL1Q1ZlRnZEJmM2RYWXhlY0dPOVlyS3BXK2tzeWxTNCtlb0lrbFBabnBiemp0TXZ4ZnZmaWo2c0I0Ly9wWFhpM2ZvMTBnWGl1TUlBb1NiT3QyY1E4cTdQMDc0T2I0NVV3RVQrd0svK1F5Y3Z4MEcrdlM4NTc1dmE3ODI3TklYcEJVcG83SWNCcFQ3Lzhrelk2aS94eE95ejhNdlgyVC83bTE1RVYva0x5Ym5IMW5pTjFrRHFSTndoSk9WaHBFTFdFQ0JzKzN1SVEzWXBuTU9vNlc3QWEyVURYekhnSndkTUZaQ0pOLzVqZ3AzT1RzcXN1amlVT3BnZEFNTnI2ZjV3UGQ4ZkNjbW4xSmxsTzdMODJoYW80a0NYSlJaWVdZUmg1VzVtY3A0QTBtQjUzM3BZcW45REYzeWpsOVhqT1c3KzdWVXdmaVhib0FFeC83aHAvZW1KN0JDdFc4cFZqUHcwOEhyK3dkcHp4cjBhN1J5Z0o5VWpVajFKdy85OWRRS0pNNUFYWUxZVzVOc2kvcWJhK2ROK29Ld3RzVnhCUWtDNGNseUkyU3ZVVml2ZGZuc0FyZGZqZW5Eb0haQ1JTMkpnZlZWTmlPUWJOeHgzYXIrYjM4Sk5MWmFqY0RJUzAxdDF6MDVsc1pXMFZ1OTlzS2dteTRyREE1VytYYkpIb0dyYjB0OU5PQjNEYVVCOVBYa2JEdGZnSEFqZWU3ZnRpWFRSNG9PQVNVMWVSNC9hNmYyOTZSOUpmUVNsNE83ZkpQSnJFZ01iN3dhbUtLdTFXNm4vN3pWTEp0QXJmU2ppc0lrZWYrYjBwazdOT0dNZ1BkMXkyRlhOZHhKQjZPWjV6SU4vOWhFajdQblBWdFJjRHpobWs1eTMzaC9FMVFmWm9EKzBrSVFHZ09OUEV1K05FQ1NobnhPMHAyNm5remFUZkJieWFSN3J3SnJ4WUErZktRdGhab1lmNXhnV1ZldVhnUk8rTG1oNGRuazdQQTcyWUVRUTZQMFhCNnM1RTV5UG5XYU5oVW92ZWx1UlNrODVQNGN5djRkZkFoNVZvUG0zZlJjeE5wK2NXTUxKaUdaNmExQnlmNWRxSHpRcEZMRHV0Nnl1YStYOTByYkV1bm5CM0xDbWFiVEhjYmZPWEwzN3FKcUUzeko1Z3VwWXhsRFZHVGRSM0Z0RGMzM2lKZTZFNC9vd3RwZFlIOWNXWWxGdGlzdkdxWEtsL3QrNVpWVW5Pa1dBazc1UTU4Zkx1TWk5MjNuUmR1ZisveG5XalpqNkNjby9EVnczeElDWmNrYW5MTG8wdldlZDVRSU1lVnlKY3dRcjJQOUFSeERtQmVRVkRlTWU1b2VkeHZsRmxSeW9weWQ0RGpNOHZtMG9IdDFDMXBqUWQ2RTJBRlV3TmlMYXZGTmxqTGV1WWtTdmgvWGZXcDlmMWhxM2gzMnhKUEp6dVI5ZHJ2eEZNUVRtdFlkb1ZnTGV0cUdraTloVmc1aVQyc3grZmxDUkgvY0E2bmZxVnVicTJsV3RtMGxtaE5ZdkU2QzllUitxM2M2YlU5SlExd3J5Sk9DeXlLKzVvUXFCTldnWFdhcDR6OXFKSDkvWVo5YzZ0N0kxTGFRYk91ZEpKc2oxbFoycWtaenk4Sk1UdEdmVUg2NURTRUJVbjNnaWV3RytKeVlEOVJGSVEvcG9xcXdQZFJGUGY3bVdudC9aWDlmMUNRbVhqdUJ0N1cvTFVnc0w2TUdOL25pT2VPelFMK2J5Z0lwdk5kdGVUbS9BdUsrTTJFNzFiZFBORE1IckwwajFTSTJpUXNwZzVUNFBYYjBSSmtjRlJETXdNZFdlYlNhSnV3SlM1My9ZRnZ6Z21UOWdCUWI0OTNaN1E0TXBjOTg1aHROQWdzK3B6WlN6bXZ2NzZWTjZka0xlWTVLODhKcHFXYzlkK2kxcmVTMUcrcnQ2UVVCM3B1M2YvWUxxd3d5U3JXTmNvSHhwWlhZbk8rREdrVzUyT2ozenQrV0E0S05QZkxqdkR0d1RueSt5MGFOWEZZdG5SeFcyWkdGbWNZYThwS0JXMElrNHFMdEJDK28xTE9lMThScmxyUHM5S3lVRlpDM0ZhZDhuUzFscm80NitWVzdvTElMeGFoTU5UWXJyTkMvMncxM3hhNDN3OEtySi9pZ3VRRjdCUmNaak9ucytGOW9saElYOHNqSTQ3dUpXKzJBOTM1bUFtZkM2bGlnWDVkV0ZmZVZnOEo1QkpUdWI3QmQvY252NkRDL2VudFhCN2cvSUtDSTdIQys2UE5KWHowVlVtL2VpeE9wS2s5NWxXY0hlUkpVUzhnc0p1MGtkVXNYMGdESTRoYnZadCttL3k2VVBxSTJ1M2pkSTM4b1IvOEVJLzBjdlVjVDVlOVhTYzNCU0ZvOEY1WW43T2FXME8vTzVoVzRFM2oyK1h0YzIweVM4d2oyY09YMlQxbmFYTU1GOE13Rm5oelFjMVhFalBKOHEwOEoreXJHcS82YjhoVDYzK2JuRDNGcnBnR2I3T1JjbXh6cE4yQUprYStJeGJSWk9LN0VvVkZ2c01zdHZ0c1FjQ05zenB5TmxBWDliN1o4U1ZvK0JrNHk4Q3UxajBxYjd6YkpuWVZSS1RETXZVMmZ1bDFSRFkxTzBFeE1zanhQUjQ3dWlVd25KME9EKzRQUTh1L3J0eUs5QjI0ZCs1amg2Y2hlckhiL2lJUUw5SUN1N0VET2F6MHR3SFllSzJpdG5KK2N3VnJzRjBLNXVBNzJEMUNVNUNZYmI4L3VTRkovRUJGVjI3dmcvNTZ1SWh0UVN6bGd3MmExWTJmUmZSRlM0UENRZFdtZW5vUzJEcSs1V29CTmhRV2ZXYkJHdnJoK0ZvZEpYeTdqT2VoUkVtNjVVK3BiQ2FZbWpNb2k1Uml1R0lWd1ZhQVhaSHVwQkdXSGs1U2JhWnpWSGFiYm96Z3l6Sk9sZXB0dXpZZHUyaW12K3pBVzkyV01wbHFJMU1MQmtXbUUzeTBEQ3ZGUTh4RndkMS9mU2ZSNEQ1cThlWStzNEpYVjBySHkzWVlJZDVsVm02RVU2L3pUUVYrTEkxOEJhbGE2QzZYL0F2VzA4OVBtMDAzR3RudXpLN201cFNNNUpzNXVXWGFvdTcwc29XRzRYbVRkOUdmZXV0dDF5NWVlR2toK3hmT0dsV0tYekdsRS9wZXhiK3JaVUlvTStxQzI1YTZYbnQxU25PcnVZRXd6UXJabXI1M0YvZlFzR1dsM3ZUNXdvVU5tL24zdm5aaWR2RXRmZzd3TWtjVnozMTJBYmducC9lUStUN1duYzN5Y3ZQN24zRHRiZ0g3dXRaTkVNR0pDOXZJMk5FOEdtNXhPeE53c3V0Tlc2YXpOOU5TT3E0QTZCRjAwbllSK0JiQWE5RXU4cnpuRmdCRFo5YWY2NE0xU2ZaQU5zYzB0akppYmFPMVh0Wld6VTRENXpXcVkzU3c0VnZqeTM1K0V3dG1jaXBqZkhIZWxXaXpJOFdVbDdqdnpNUEFsdlZOSWxoWGJjSXFyUkJpZXV1VjZFVWpHNWlIWlp2OG5HS2FnNGQyVjBNdEF4ZVc0T1k2Y3NPdmt5S25jajYybUhnN3RadEU4ZmNhVnllcmFldk02a0VjZEFhNGpMck5KQWd2Q0M3NjhLK1ByYTRndUVkcTZGVWZRbGN1dWQ4OHhNbXVTcDBPT3pHbjArOGY4eS9aSnlhZ1RHYXkxR3dpYm1JYXJicVh4MGpMVFpzUWtHNlZ6ZEtqbC9yc0FicVVoeGFZTmxkcWI3VThZNVJWeGJncjRTZWFWaEdTZnRkbnBDQmMyU0RyNm9JTWRKMkFhZ0dDTzE5TWJxT2ZtNnlsNi9RTE1oTXFBUERJM2UwcUNHSmV5TXYvbGRud0d0UENTbmZQVWM5dWFkUktoOTdBYjRQV0VyZmczWXZjNkVLamN6VnJQQythb1dhMnRxQWoyc1pNWkZUTDRzNHlUdm1uSnJCVjFkQU8xOE9YdTg0ZWF4bVVLUHpGVFRPd1NGMDlSVFRNazZnVDBwRHVUZ3JtRDFMbGV0K3FqMHpjU2xKdU1IYVVhazBLL0ZGTTZ3dVdVZUFrbGNha3d4aFRTTHdoVERKMnVndGk5SVl3enJqK004SDF1TlByYTZtZ3k2WlM0RTBzSjVKZmU0eDFPWHVQR1dVYjhTdE1aclBpT3Q5bERzNmliQlN2MVZ3V1hwajFJcjZWd3FuNmVyUzkrZU9udnkxRTdOdlpjUzVtc3ZWeU5rZWUxUStIYi9TRWI3TFp4Y3hpaFQ0NitpUEpMNmJwbjU5aDZpd3FsM0NWeTBlNXBYSDJIZ1Jnd0d0anlrcjU2eFJNbnF6RG1hbVR1R3JSaHBQQmVyNWVWQmpKYm9UWnF1SHFyZ2FlL2JCWkEvMmErbVIrT0J4OTF3NDd4d0llREc2b2oyblpDZDY4TUJXR3B6Ly92OEZnUWJNR1JYVXFndDJid3BEN1RKZEgyU2ZEbmcvMXU0UzlPWFBTcURZMGFQNWU0OWsvUGZ5My9sRjhSVWl6cEdOZlF3anM5UGwvQTBtd2lKZGtKWmd0WnhpRzRRM2lObTZ3dzI3S1dLcjhjZjgwMHN4QWpuVVRIV0UwL0g4d1R4b3l1YWR2TkRnd2tQY2xNOFVoVVBVQlRQTnBhMlVNcW1XRm0yd3pab1FQeVQxU1hobmZCK0ZsUzZDZWZIT3dmZnVlamRmRTk3anY1cldyalZHUUxCTmNjQ0hIOURYNXl6UlpWRGN5eDYxNTIxL2FNTDR5a3BhU2Z1cVBETDVoNzBkdmp0Rk52ZEhxblZ5Yy9JNFdpQU1PdlRmWVpJMjF6VTNhNVdTSEQ0b2NMaXJjYi9MNFJaNTI1KzFkVkszelgwT0R0d2tNaU9iOWtCeWxmYk1CaUVaRzc5L3BTUFNKalVRYTBoL0V1WUZtVWdzbzJ0ZWR4NElRNkh4QytPdGpSbUZJaHhoUTE4ZWxHaFFGRkptQUxtSnJlNFZnem9laUhtckhJUW5JTDZDOVJRaVhZeEprTlN3TFY0VDl1YUpreEdzUmxuYmpMQXdkdzV6VnlmY2VodmhNeVpQQm0vb3lDd243SkdVL1VJVjIyV0tMN1F5b3d2Y1BBUEVNQVR3QlRPZG5lRGhsTGV0bFl3bm1TZkMyTnpoSzErNm0yaklNMEdxVEczWklrZTZDckxsL0FwSGh3Nm1VQTNRSHFUTU4wUkc4QUVUTENDM2FHOTNIamM1R2lZcWVGR1RkbG9qbFQ1by9STEJhTVNKeWEwTS9RbWNBaUtPRzBrcFNlWlFoL0lnUVBTN200eDRITElPU1hVZmVVZ2ZiK3ZVUHhQTkJXQmFSZU56RDM4ekxUcHR1S3RPYWpVbG9sZzJtTE9sWFpOTUdNZ2I1UEVodWNnTjhNUk5zOWhoRUcvWHVmNDhNMlk0dzB3Q0lXNFFweHcwVWd6Z0hSWXo0TnkzR1lsUW91QTdXQjN0dWltQTcrQ2xDdlN1V1pURitTYmNvVjJUVEo1WElQeFBmSzA4dzA1OS9ydlQyQVQzOEF1dWxXZXVSS2t6L2xQbWVKN0tsNzl2NExTOW9GMTBVVFQ5UGUxSEdQeWNqSWc5NFU2cDVTV2M5TmEwNFUyVGNVYlVJb05iOVdLNG9CRUFQOVNpeWR0SWdRVUk4Qy80cHhsc09GTDNOQ0VJVU40M0cwekl5cHNaT2p0elAwVVFaNWNEb3NJQjZhdW1tUHFuTTdXMjZWUXBOWi9Vd3VVTUtzOFNrVlluOXhTdnlsOVd5aFBpcGZJanVwOGVqMXJoMHVTNGhJTmhPR1Fzbyt4OVd4QmNsNUZrbFlmbzNoZk5venp5cEV3ci80bTRmM1FTSkRCbU5VV1hCYzlNZmlub0JiVFNCaVFEdGYvQSs3SElOQnJ3MUNWL0J6K0dQWU9BRE4wMTV4dnYrYngrWE45N2JXRnR0dG5iV2ZlWis3SDdyTEFKcWhkRnRCMkl2aHBXQUJOekE5amdzRUJQRUEyb3F2bTV1eFdWcDRhekJIU3NrU082QU02WHV4RXpWYm50Tzg5YXpUMGd0WkdtSEZETlpnQ0l5cUd5dUpRbElOVmVsNUhFSHN0RmlyRWE3NkZZUnMzbGk3dmNseE5lS0RUbXdvMVc0aHphd1M2RkRpSXd3dFBoNEZjSE55VkV5dkxZWWlVc05vb1NEVHBYYXg0Wm56M3ltay9mMUhaZmFpaEV2WVlFMk1yWjRaVE54cFIwcXJ5cW4xQ1MyWlMwUGlCQTVFb3pUS0FMUWRnMTJKeUdIa1BHazBhQTNQc21iTXVYOEFhMkxaL2hVZC9HZ3lJVkphUDZaZTNKV2ZRWS9odCtDQXY3eEcxeHdYN3FmdVQrNEtSRnVuTytRMGdwRlhMQm1QdGhOTkRac0ZCVU1RbU43cWN4cnVFVUpSZnJ2UU9ZeHhUTDkyRWRtaURVeW45YnhZSXF4MldWUUhqVTZlNTV4N0Z3STl2MFI0WUhRTDAyUWI2bysxSHVVMEtCK2gvcnVVdkYzdk5aRmh2V0pkWXdRUWdCTjNJOHdEMFFMTjQ3YWdxR1ZGMEQxQ1V4czZmWTBZL0Y3NVY2RW5TUlJaeVdtcXR6ZVRKblJZeXRkYW4vV1ZGVHJDYUl3bGZjTHdXcEVKSFlZeXpJZ0psd1U4QVkxVWJOOW1hZ3hkb2tqUVdJUnY2V2M3bHF5dEdYcGtPSk5LQ2VTeU1kS3ZERUNVV2ZVWjFFZCtVdTN6S0UxcW9ST0xEUmVTWUJuZlpmeEJEakxGbUgweHFuSmFBOUNjTTFTbWtIS0NrcUxObGVIa1RaVVd1TTBJMS9tYUZaTTREUk1uQmZjSXQrM0pjazBydHhCOFBPTUxvMXZJdDJNbitJVWFLWEE5TmhvMElWdUcrMmxycXJXRXZHcVVXMm9vQ3Rxc25PRytPTE5ITTlPVmFHZlFRakJDWGNJbGhTZHlud1A4VXNveVVMV251SnNwVWxoK2RRMGZHcGE3YjYvK0cvWDB1a3V4KzNOdnpmQWJ2ODZ6Mk5vNG9vUmRzUFhEbmVqd1dKWXZNSGU5UHpTTk5td0J3S1pIcklHWHB2bUQrdWVFcUVLYWVaaUwzUUVscmpaeWRMaVdtb2xOU0JpbWR1RkREVGU1b2t1SU5WbWtVWlZWYVo1QTAvUHN4THIzTVRocHFkeW1ZWVNwYlVVaWFoSy9JaG8zZS92Y215dFltRlIxbFl3aTdZS08wRzFZYkl6R0xtb3lKY2dDWEZGSy9TOWg4RGMvdENHR1licTlqb1BPaU9IYUlnS1RKaEUzQ2pCQ2NrbFZ3bUpZODlKSUJDemZQVDF0UlRBcEgwNjkzVEVFQWFzMk1nVUJYU3gyRGt1WlUrQlZhMk91MC9RSE1IWTJSWVVPZnVHV2dKYmxlalhYVUFNM0JpK3NQMDN1dDd2QVBnaHVxcDc1Q3cwdEZKYkc2ZkpZR0RZd083aXgrUld6cVp4L25Nc0NRalQrejJZY28zaTh1aFcwazZFZUJ2V0FCaG9WQ3k2R0hHdDV4RnJoamZZMlRqa3JKMWdvRkZvdkRjeVg5RDd6bjdlc0d0Q21NUFUwWklvczQxTzhXdUhMUlpZQ0hCL1hyQ1BGR29vVFB3YU5QUFdEMXp2Y0RveGVwa3hCZXY2QXlmaVljTFJ2NFYxY2Fsd0VZa0tKY0dvcTVOK0htc2lVSXFjTzhJUE43TEFsWU9EeG1ZVTJBUHdZR2dLSVg3NEpLQ2ZSVk5vY2pNekFvb0U1UHR3eWlzWnJpbWtLdzRGTUlpR0FLUU1XZlowOFBETXcrblBZYUIvNzk2enZQbDNJSmtuZitNak0wZEVKY2FWRVhNK3JmSjJ6eGVzZE5WWVV1anlTTENrN280eDNHbnY5aHBmZkhlQjhZRzVwR2NnUVdFdE9XVEUzRVhTaXQzR0xvZFhmdGFEQTVBYmNmQlcyWGc3dkcwemZCdTh2VTFlZUlNai8wWGVTNGtNNkNkZi9nSDlObkNqRlRtblQ3R0liZ2N4dlZIVnkvelBlZXR0clVyQTdmeEJHZnlWNitOSWpzSzN5SFBpV1ZhdlV3cW9abGhkb3BtMnVrQjVtWk52aWtYcjhrSGFGMDZqd1E4aUZpSmlrVzlDdlgyamdyY2p3MS9EVkxzZ0w4eWdlaExycC9XejFzWGJ1MnRpZ3hIQzVxMXdHR3oydkprM1ROOHJsemRBWWYzNXdlZmpOYldjT3U0Ly81QzExNWwxSmtHeStpUGNPVUxLOWhpeVJ3UFBWUkw3K1pTTVRQV1FscWU4bkcxVlVibDRPaW9zaXFYSjZ2ZDZrNzNxTWVwQk9SSFJMVHVFTTlDZFloV3lYODM2Q3U0eWllREFuQzI2M25IV29JTlB5QkpZMEsyT3ZmL204eEhFNWtEQ3ZRam05a0xjV3hkSlllQU9DdFVxWFQvb3RhYkNZc3g0TW5wOTVScmZpd21QZ2ZvTnpIempOME1BVGFkMzV5WTBHNzBXSGNJb096b01pMElBTXpZTDFqY2llZlMzNEtLNHFjZTdJQkhLN1JDWGg4TkljdFZGODV4YmF6V3NDcllmKzFmNHBCY05BMGc3ejQxNlpQRFFQZ2Z5Yjl5TWFJZnVIRGlCZUx0QVlvSG1kNlMzRVlWZkM0TEVCM1JwWDFaa0p2bHZuTU41Z2lJNlFlR1FCcE00NDN3SDhHdHdVMEpLb3Qwd2Z4UjloaGE2VWZ1N1JLMjhDRGQvd2FUbkJ1ZWhaeDZZWTUrUWE1V1gwVlFsc1FGamJjRmVSR1hjQXptajNOY3dScWhVSWdVYWl0NWZNMnBjNmV0SmU1YmMrS3FqenRmR0xOL0l6VUFQd1RQU3FMQUZxdTFKM2UxK2hvSGJSWGJIRVJLWlNLOVpFTzNXUjdJcHRyZzdaWDY0amIzcXpIdUtreUhTbS9vZUxqc3hvTml4UVU3MkxDM0FQRWM0MG42akd0M3kxOW9QZUJ1T1Y0NVI5Sm5HZUdkRVZKYmRQbHNaK1V1MmRNQ3FFUjlURWlaNWQ2VDZ1SFA0Y2YzajhtTkJ6U05DMytYSE42TnJEalU5NTZHYnZlMXhKUjVmUVh6Q2taMng5TTcrL280Zm03S29pVDh0T21hZVVBMmRzRDNrQnFERndzZzVHcVN3clV4L1ZMZ20yUXAvREtzWE5EVGJONmV3cjEyaWVQU0JyeXlwS3MxanpjeWVaVWg1dDJxM2ZXam4xeHh2MTJjbzVvT1A2ai9ScWJDakpVSzJlM3dJY1A0eVM3STVSajBrM2I2SG9icStWNzV5SnVVL1Zma0RMbUk1bWZzakVwblZVWVdwdkxjZ1F2aEpCbEhFVDhkSWRwVmhudnBCc1lUYWFNSVY3Tmo3V0xvb3FtYWpYaGNuam9Vend2NGlUanh4UUM1OGNVa3ZuTFVPK05WTzRZZzBPSGRXR3Jmd0dKWHRadEJkQW9wamFza3E3VXFLV1l4NkNXWmVjLzZRZjA2QWVYU1ZHdTRhSTVvQmhmSW5nNGRVTm5LYllGK2dPR2xnNnlxeTlkZ2hyNlB5VFR1V3hOVlF0M1hBSm15YVF3UzZ6cE0xUE9rVnV0d0RXdFJ4ZS9OTkZ1ZEZGOG5wdlczUkcvS2V3c0Fkc2twWGdjd3pVcnp0NTcrTTl2eTE5czVzTU9yQldqeldVS0dFdTVsdnZqMm1iOGo2a0xuVzg5WEM5UmFwRmRST0l5ODZPaUpWY3hHL0NCWG9UbjRNQmZPNnRuSE1DQUhrREs0c1pQVFNBMG9DRnUrallyKzZQN2lxekNQUDZkU1l4S0UwUlErY1Z0TmpFTHlPUEFkam5vNTJUTUk2b0xncEpvTFA4SlVKQnc5bDNGSWJ4VGQ1R29TWW5CM05tVkE3WEoyR0JXUU1BTGpCK0h3d216eVlWM09lMlR0SjJBcFZUNE8waGRlS05XOFJzWERnbHJZaGxIMkdjV2x1R01wZHd2QS9HRWwzWmozNG9zRllZRXFpYXUrV1dNbzEyQzRvSzhKQ1M0elVzN21JeFR3NXZXRVk1MWdsbXd1OHo2VnBnQ2tZRWVkaVlxYkxDMFloOVFFZjNaa0l3Z205REJLVVFSRW9NNUlraW5ZTnk4T241UFBvTHlLRWw0UlMwUnB6RklHeTZWYkdOcVZpSURBUGMrMDBFa212VnVRNkFTUEU5M1FMZ0JpR0RodE14QXBZSzYzUXg1bTg5RW5vS0FkdkI5V2doai9PYm5hWDkwWmk4OUY0TmpPbzZ4Z2Z6VHloZ0hFZTFSeE9IaW1TWEJMNEhEbmhFS0ZoS1NwSXNQTituSHNiNlJGTm8wdjBlSGtqUzJqMW5oUW0vaUVEYzM1NkFWaktJYWNJTGNsYTlHZ2lNMXhKb2p1U0JhTzlidUFGb2UyQ2U5TE5sL25tUTlOaGNRWWh4V1VyZk9wRitGMndGNnRQcjhVdE5TeG9PTGhIU2JzUTViOVZJSDRmRjVrWUhhZmxFRUczaS82RWhrNkE5emt4Y3FlTWgxQVpqWXM1WjFtTi9QWVZ4eG1SY0NqL2wyaXpQOHRSNVpKSGdUUkltenI4R25FVFlvSVc4SG5rNi85NC92Vnl3VXZJVkhwS2tYSUs0b1JzUGtPWTFRWnhOd3JqTExiaENaeHl6cUIxb1gzVSsyc2drL0tsWVhjM2tBUkVRN1FYampjbVFqdkplSU9HVnROWStBczhya29oTVFsWWpLUTlrMUZnVExQNjdHMjNqc1NjaUdDY3V4aUlMeS9yR3JMNTI2cVVxZGphVS9ua00xM3pXOXFyQTdiWUN1b2dnOHNPdllyNG1RRXl0NGNiaGJzemEzT25wc01XSmt6eUZvWFZ1U3ZNTUtQaGVZYVF1UjNFcXR6RThZd0dUcHRvLzl6RFRjdXBlTnFONk9Oc0hzWGpPcExWTytOWEo5TytXU29mYUlmeWNSYlk1Qjl3TytPUUl0MEJjZ1JnWHZUdlFLRzNJRmxJWmcrNGg0QTVxZzhSOUd2SGdyUVBiNkhEbkVLdWo4cVlHTXBaWUdRUEhEUnNmdkNHT0I4Q1hEYTJMUno1NDJaSzIvNUJxbGg4TUZLNWxNZDdnWTBtcHlwbnQ0TmIxNEFtN2phSWRHdysxV3d6TVRkUUxBc01ZUWc5RUU4MkhEMzlOUFczQUhuVW50TTNKcmpRd25zYzhlREVKYmdQemIrNTd6U2NhdDB0dlZlY2F4Mnk1MGVDYy9URmphd2NQWUhEeG5MZ0YxZTBXSGgwSVU2SFFYK3NJYm9FeGlCV3pWQ3k4NnQzdGw1QU1zM0lrN2VOTGRWNGZlWjZzb1B6Ty9MSmxVaXVxM3oxZ0dlRitOcmVXWkRZR0czSXRlcmQyRUZhdkJyUTRIbVpSNWNVakEwZmU1NGpNaUJIS0dHQ3NndXFxWVJORVFPSU53WWN1Z3l3SUNEWUtCVHFDbEFQQUJlbTU2OXU4aGFXeFZCblpHRnBJQ3JCbXhBK0xWUUJqNWpJSnZQeVRaeWhhdWp3MFYrMXpudkEzYkdEN2NSK2NaSjd3QnM4ZGtzTmN1VFdHWXAyY01ZR2J0aXhzSUlRWHcvQXBxbXpRODh0TUR2SjlCc1BRa3FCbnlCUENucExmN2xIcUlkYXNCMjJGYTV3SlpBQ1ZzVDNYWEpNcjFJZTNyNjc0Sjdya0VHaTFqak9qN1N3Y3ZPQWg4TWlCcS9VL2hoaDhiWU84SU5nUlNLdHAwb0FWeEdvS2prQ2tpV1VTMGdVWkdXbE43cFJVcWhSazJKWUFjR3dzbTdRT044S25MSW04RERVL0tTYVhDM2JIbTBRdFJtNXE4ekM4WG92MmlmZVdZOVN4VHhVRjVtQWI1bkVXU3FCOWpFUlpWTGxQNFhxUXkvVk1rV0V0d3BQM1dmd05UdFg4QkJGL3lhQW1la1d5SitQTkhVaVYvb1BxRWFMNEFHMVhONjBuaE1CN2hOT0ZvS2VlNUIrbnVXTE1lRVRPZUtNZ0RESlVBTml4QmIzbFRTaUhjQ2U4cmREU3g1NmdBN09reFNpK29Ka3hWcE04VE5lcEdMQ1YwTzh3T3owUW82Smc4azhtUEpDY0RPdUJKNHk3WlZFR1JKbUY1a2xPNWdXTGp5NGMxN2xVOHJ6aGlGSHM1RFNuVzBLa2dsWHhjcDB3cS9UZGNWbzE0S0prMmpyckgzZ1RoRVRWY3dCSm5GOE9HY2Y0SGtqUlNZOGgvUmtrdS84MlNRR2hvZysxN2hoMWFnc0pUTXdNM2JkVXV2dnh0SHpibzNCN25odHF6eGFXVkNaM25ZNTlNcE9kcVA0WlZPVWZxTUlnbTl3MFh4bGZtNythQWJxNjY5M0puNGFmeFIvRThtaGVEK0dGS0VlTEZ4bUN3QVBZWUNZc2V0Q1ZJOEFlVlpSV2dBVm8zRVA4bkhPTTNNQnN0R2FEMlEwRU9uK05sRVNvazFwWmlwVjNFQ0JoZExUZGszYlVySksxalpSZmoyNWw5RGhlY0tLclZRakNwRHlnazcwRkNtSEVBZjM5S0txVXlhNzRlZUJacCthUVh0dVMyQlhYeHVEdVdxN3l4b1d3UThtZndzTHhPazhZSmxlaGxlc0RqbTFtdWRLSXpkcUx5bjdETVJsZkJld1huVGJSL1lLUTBqWmtJTDFvbGE0MmYycTY1UnNYcXY3am13Q2hNZTFMZnBJcGpFNU5uZS95SzNFUlhubWJIWnprY3RYOE5RTitkY0hTUG9HRXFYT0lla1pwTURuYzJBQVpzeWxQcm45QkRhVEU1T3V1anJsd1Z0LzZOLzJZMis4Yi84My81MGVyQUlQSy9wUW5WVE1veVJQUXg0WUNnTHFFdW1hU0F6QmZUU2NIYXFNR0tTRjBpbDUrYUNkd2xDUnlvQjMzdTFBRTh2OHFCYWoyL2dtQkxVaTRnVTJXQ2llaFd6ZTNpMXZZZDV5d2dxaXpxaFZBOWJyOVpMOXgvSlVuMm9VWDJ2d2ZTQTU5OVZENjQrMWZBZ3hFbG52WmMrd0czVGxOZGR1cHhSaGZVSkdiMk9oRjRmbkpBcXJnRWhrOUhuU1dJekZpeDJEQzM1bGFYMHhoS2x1a3RjU3k2RDA2QVdxZHE0RnU3L2dmRlh0UTNMWkxmZnJUN3ZUNTBzZWQvSVhpdmhWaTlaeHQzRFlBMFhuYkJYRXJ4V1g0RUUrUnQwL2VBVEExRmMrZHNEcDgrcWtBOERqdWRkeEtFNGRBY0doSUtEVVpCa29HOUZEUWFoOGU4T1JDZnB4aWJ3VEw1OE9Ianl1WDlRU3dmMUdhdmltbis3bVNaMCt3ZGNNWDNXdndWTjJmdjc2bzVMdWxISHVSbm00WG41VnVmalpzUmd1cWYzMEI3TmVsNzdyT0QzM09HRHlKRGVpWlZXbnE4S3pzc2YwWmZlS3RjSjBVWGZycFBzQ0tkSXlpcFNpNjVHRGtkSDdQU2R0WmF0K3hzNkh4cUt3enNwWG1KVnZwbmgxV0tVL1liejBnSnc5OGtOdS83cUZyL01ITktGWnJqcjRlRmdTSUdMMlVrUUU5MlZuVnZSSUkxU05wbnJ2U1A2OHF4WmlXWTNMUW8ybk1ScmxZa3JNaHlORWhZOUZLcFozUkZRb082L0JZbWtuZ25CbHl5Nkg4MkIxUFhtUHY4RGl1aktGRS9DSkFES3h0YStMeWszM0E1Q3A1Mit0YmR5VFFlVmVpc2RSUlQvekZ2T25lQml5bVlzRnlqTXFQU2VrZjhlVFRqK0ZnSEhpMDNVQmhPeG03c1dyakp6L0QvenQxVmlXN0hoY00wdVBOOEpqRFFrVnB5UEk0bVZXS0FvYzIzOENvUWxlNnYrQm5yemZsa1VZYyttWFl2elgrMVBmejN1VTRqSUVmYkFkYmF2SFhuenNwVXpRaC9CR2hTK1lCUHI0c0tSQUhiSkdmbGhpcTdoekMzeUhxTmRWeVJCdUZ4ZmllcXhUb2FreHZXaXYyNFppNnc1cG9hMk9acENCMU42S09YakIyNHVXZGtFVmROaXAxazg5YlphS04ySGwvWm5UYTlpU0s0NGdlVEV6dkp1dk05ZDZoSXVOdFk2dTZ0ekpKY3lqU0Foamo1UVprSWhYMmE5c1Y3MnRieDQ2WmxPWndkdmE5UmgwZVlHMmhRSUpkMXMyYVZxeDlzVlJwZ2RTNlVMV3ZZblN3b01kckY0cEVqWlh5V1ozaWdMdUYrMG54SjhkUEgrQ2tJM29zQ2N3bnd1SDFwb2VZYXhXbjQvVjl0SE1BRGY3N3FXWmg5djJOdUtNc3hCRmU5dW5ta1g3SWY3aWx6NWEzYTlDOTUzbGZ0MnY1SjZWSjMvcVhDTHd3VXF0SHZyclhyNDlQRU56WlR4MGN3YXZCeGkwWWxKOVhCUGc4WUtra0lJQUxpSEpWZzJMeG81eDM3WHJ2Rml4amFFRDByM3RQR2UzZXZsc1FESS9lTGxFNTdEclJzSHRDL29XOThPblVxRnJPUll2UlZUZ1J3RHppTjM2eHBpMGdLQjRmOG5VRFZVaFgva3lZSVdPbVVtSTVyVDFQMnQ5SjRqRzhPMGhyMGF2SmRNZHpBb2M4cXhkRisxNWpRVmZPdGtueTBxS3JJcW9JVFRNd09XemdkeG16ODdOK2pWTHp1VUplNzlZdUhjd0tKcDZjOWE0d1kyalgwd1ozVkZaS0JxbTAwd0Yrc2haYStnUW1BYnM5K3dGVHdKbHdRcDN0dExOSFNvYU1lSlUxN2pNbzlLRldxQXBlMGFQRERLMHBWRkJtMDJmNGx0MWV2WVRuQkQvbkpaMFMyM2FxOFJWMXZDTmpsa2RmeE5tQzVRWERyM0hQd2xZdDZaYzEvd1Y1UDFEZVExeElpRmtMd1ZpZnRzTHVNV3BRMk9yQmU1cXFUYmxmR3Z5VG8vTFNXV2FIazlITFhyOUtFL08va0hVVnNXN2xsTTJOblFyejZnb0w1Tzd5L1pPcmxhdXAwRWt2ejl6eG9jWDh1T0tFVndLbFpTQllxRktjY3NwV0FjVUV0TEN1UzJlcEN0ZGlSbmFxZTdVQlYwUW8xak51NVhOQ0ltNmZJY2lYcDJPL2JBQWx5UEJoTHVoa0M0YzVjWjFjSWpGT2RVQ3BZRithR1lOV0Z6UDJPMzVvU0lUZ3dRSk9ZOHlDOE5aR2lvSnNDcFpHYW1rVGhZdEVCeTREdEd3bzBjSFBQNUZoQlZNMGFnK0JwM1M3LzFBbTVkTHMrNTMwWWdzaUVsUE10RGwxd2xHVjJmVnFXaUcwanV0UTlmdFI3SnBySnNZZTNqL2U3d25uZGxlNEd2NjV4SzhmdkkxMlEvMzhCNStZL04zVjluWlVHaS8reDM5a1ArcS9SMUtJTXNwazNvWlptK2t5bE9aVVY5R01GamRkRVlxRmgrOSt1WTd2citWOUlJL2tleW1UL0FDWHZWZlpmUWZ3RHY0OVZ1L2ZtNTJPZlUxRjRBNUNEd3dLN3ExWWx4ZmJUMlIxbkJidUg1cEpOMTRKRjluMSt5U2pzejMxamE2bXhKdjd4bzZmczQzSU9DNDhHVjBLODY0dW1JVmt4KzY1Z3NKYmlwSVBVSTNzTWVoeUpiK251bHIyTU1TTElQRzBBSGdrNU5WdFV6ckJHTE9ZOEN4MWwzUFJZaHlQQUE0UzFRbTZQRlRqT2hucE1UNU9ZUGs3eFJsVExpOFJSNExwU1hmVDBuM25DZjZsZDg4UC84NUczMDZNNzZsQVI0M1JjRE1mcE1iM05nKy91SVBqR3F4K2ZQL09lMk92L2pqaDJBSG4rQWFQdWwvQnkvNzczZmhQWGNKNWxGT0FjMStiMDdZVS9BU3E3a3FEU0lFV2JlZXQrZXZ3K2cybzl3bDJOMm9OVGFtT3BSSE5QdWNtdTlBRDErWG5seXFzTEpwV0J2MFRrK2hLN2FQT3d6Y2R4djJLMEVTakhBK2RsRytlWS9PNFFqcEpEZ3RIcVFseFVxNXRUOW1uSUpVQTQycE9VSFJIU3RYVU9pZ1NFajhCRCtGeEc3NHJPbG5xSm0zaUZIUXZuTFhibHVnTzVoWVBJekRZTHR0UGhhZkk4K2UxK0NNenpZSldpSFRQU3hXbEM5dTBSSTJ6R1lzYUFqaHUveEVIOUxmRVJRQ1FsZFJ4MjNiRnJveW1YZmR1VXFwU0hOREo0RnRlTGJqVDZYVTBaOW1HWVNBanJzbHFwWXhQaVUrRzN4S1FqdjBCNTBrcXNQQzBVOFcwUXptaVN4T0crd2pRQVJBWWtHbmdEUnBOeDJMNXgrM3ViL0R4L2ZrZ3BZZ1pCV0FRZ2tDVU9oRUFRb2dRQUdzSTNtVTZoaG5aenBCRUI3RE5qOHhCbkdNdXFxUFlGTm81TXhEd0NwNlBCL2taTWxqa3U1a2J5MHYvVjQ3N1Q0RzJVSHBIdXA0Mm1sZS9CYStyNzNTZW5IeVRzSXNqWnJhd1VvNHY5OVNCRDJsQk5kdWRxdnhLRnpWL2pFRTBJOHdlVjdKaXZaVDczRW5zd01PUnhuS2xXNnJkeGNoNjJBN0ZQcGhwd3JIdm1uYm5UWTNXMHg2T2p4cmZYRnI1ci9FVXZyU1BFaXpIWXdZbTl3R3h3UHBHaDNqb3BFZ0VRaWNQb0w0SnFHNDJIajArWVQ3K0o5UGxRNDVZWXVOcnBZUVJyaFE1b1hmbStUdVhldG5hT3FOa29wZ3dBVzUyam9iUmI5RmVma2p3VWh6Q0g0SWZvOFpOQVZNYzVUYnRuMTlyTjFxOGR5WDFyU0NxVU9DYWFIaEZDRHduc1VuMVQ1c2EzdEZuZHRvclNyTzV5N2tmdS81ajQwNlVxVmNKY2tydkRaTU55aUgyK00wMG1LeGNaenZ6bENkbUhUZndtYjV3TmFOZ3Exbys0TEtTUng5TnJ2RVU5cGNnaFFrbFpZeGJqYWZiNUpaTGxLazZweWFVd29QeUlVcjdUVTF3aHpsR0R3RXp6Qjl3Y3dqbG1tcVl4S1B1cnQ4d2FLZi9nOStERjhWZkJlYzRkNjd5dGtPc1U3RG5lUVo3dzdIT0hkWWFBVStKbjJpOW1palVqaGhnQXFmT01BQmJuUXRPWnZlSHpFbmwyUnZ6K3RHZzRCUU5EMzdjREhzUmd3WTc1VkpDMnN2bzIxRU4vME93NXhqd0JpRHlXUE1ZdzhEcmdiTUczcldiRjg4cG5UdlB0ZDhaU094ZTY4RE5GRi9rM0MrUmhIVm90enBTVVVpTjJiRXYzSXgrcUVvbW1WcktveXFRcUUzcjlGTUVQSERvaldkZHdWNG9HdWNrQ04zTUNBMi9zWVhwSmk4VjVzVEdCY2ZtTkE5QXNRcTJOTnhNQUV3Y3hGSWNRNW1oVzRUUURxQWVrWXdLdGd6Yzc2b3UwaUlxSjhlZ1ZVUk9WRkp3N3VKV25xdjZ0dlNVK2NBZ1VrYjk5cUZyQkJjVDRCdk9ybU84OEF1N0M3T2dTN0tNQzlEUkUydlhXellCcGVyYTEzRUlDK01EeURKaVVmRWhxZkVVcXpFL1RVUU9US3N0ZlNVMm5vNlFMTCtoU3YvS3NEbXlWb0FyZ3RZNmZIWmF1cWNYa3dsOTNla1ZtSDBSNHFXSjFvc3Q3WFlObjl5dS8wRkEvRmxrSGdZWkVNd0JFa044cVUvYk1sOW5nM3lJQmlDSVJnZ3ZSS2Z5dFo2ZE8rTHBXdWlmcmNzZzBaa2I0dHRvNldsSWthUFlndFFZbWtHdVJKcEJya1NKeCtJSUE5RWtLOEwyZTN4aGJaaUMyd0VJK2tLajNEY3JWRUVCQ1pUdVhQbDdOU0xaUmlsL2NybHZrWGpOYmlVNTFoUmFRMlh4WFZ0R2xpZXV5VGQyRk5tS3RwMkdDL3NyZXE2K0hHMURkWDIvaXJiZDN4K3pwU1dxeGR0ZlgvOTRYcGd5b2FraFNiQUVIaExjR1F2endsdFVHOWpxSCtuU0p1V0JzdzdNS3YrU284aURhZ0NhelFvZUdPOGlhU1d1V1QrU05veWVTT24vTm1KV3lHUm1LNlFmbm1nb2s1ZkdEbjNGci9XWFJZYU1lS0MyRkxiRnFvNlVVZjlOeUhCZUl2SG1XMmpjNXNUdUhXL2lOMGhaZjNldktreU1BcS8vOC93eGFWRHVBK1A0ZHU2MzAwUlpkTTl5VmVTTXNBZ2Qwc2xHZVlveTZ2YU5ubC8rMVQ3Y1pUdFg3REFyalBFYWk5dnVqNEdIL292STN6YlgrZkQzMllPNGZtanZMV3ZZd1RPclgyY1ptT1prbHg5MlNEcGQyM1JZZXdZZmJSK3FLdWpuYk1kTzVnT0ZiRGh4cjFDU3pNdnZzSUp0VXRYY0xVR0tPWmM0ejA0YzZVTURxNnVvL0RLMDdkbGZDeU5LRlpMSXcxanRVVWhrUGNMdHBDYi9YeGtXV01yQnJhOUxCdW5LcFNkU2FBQ01mZDZIOHBKU0ozOTdSYWFRUk5xSVBEV2t5SzB6T0lRR0FUcGxUQkN5aGNHd1g1ajdNWklWM2N6OW4zKy91aGcrMVE4dW4xM3djaml6TzY3MjVPRTJxL0pGWWRleGV0enZxNFpjeENGOHpQNUFZYXI2NVY2cTJ6YjBZZFhmNDMwSVZoQ2g1ZkdEUjd3R2w5Y2ZYVWIyMTlPY3JFU1MrQmxwNEwyWC9XNVpiem42ZEp0WVpFalZUaDJuM0NZcjU0MldzZE5oVnZjNDVHQzRaVHBIbys1NndOOUJpK1gzZ0NGdCtFSFlpbStKQ1Z2a01INnJoNG5iTTM5SldJbEpURXRaVklBV0QvazZaZG1xVnBzdTdJc0tXYzVBY2o2Q3hoL2dPbkxUZlQwKy9LeE1pS3JNYTAybUV5U2RrZnByNDJIS0VTMmZiSFg5allRZXAvWkw3WllObHdPZHF0ZFJBQW1tVS9kVmpCK3dXNndXQzMwTmN3NHczeWE5VVYwcTFtWExCK09XYkNDNGFhMk1kVGdZWUI4YTh6djVPSkpQUGVxclpKRGtuelF2SVZha0pZMjhFSGk4cllPY3RiYTVzcnBoTXl3L0VMdGRYMVVjd3JvcDBNZjBDNjBDZStER3FwZXdVblJqejRxK1NJYTJ3WElOLzJ3UjB1c2RLVStXbG1ONXM2M0FVTit5RWdPbFRGbkxYZTFUNVBhem9BZnV6ZDZOcllWbDJXZUU1OFpJR2NtNVkyUHZCTzdYaWlRMHdLazhlSGNQZXdyYkwveTA4RDBtdU9oOW4wa0h1NXdSL1gwWkhSYW52NEhQMC8xdGZmOVVEeDBYNlhaTGxYL3ovaTMyNzhGd1c0YnNIWnI1c2JCbHVEeDZYWnZyNHJjM3lIZU85MHhlejhGZVFJYklXSERZOWFZRVVLNFZxbmtVakEwUm5YTjZPU1QxSURKb0RXYzBRTkxFRHhVRDZQampxL0ZEVzVzT3pSSm1VZ0JNQXlQRjVJUTA4SGljeEJhZjZmNWFoVTJXSm4zN3RBYktsUjIwdWNlcUcyVWhZN0EwZ3dDWDFHcVhCTWlvaDdEVkd4ZTRjd1RKYmo0ak1LN0plQ3djcXV6UkpsYWRlWng4ODQ5dDViY3BQSVpiOVhlcWxMNXlOSHBEaEVpeDBzbmxMSGllWWtkT1dnRHVrbHl5OUpsQmhFZlBOWW1CL0FNdHdqdXNGUm9rSnZ6RnpqODIwZ3NTMkNUU0piTHMzYi94dTRma090YkpBdGpPZGNjc1l5SE8rTGFyLzhaYmZud3lieG14N2tZeWlZQitwcVdFR1B0cHVZY3Y2R3ZJZWxYMloybVBkYUhlY0lnTnVQVDNUZjRZblBFazdoVCsvSDFlY2I1S1duSjlLMCtBNVgxUnI1VlBBMnduZytzc2t2dmV5ZVNJSHQrSG5BTXNEL1p5aUQ1cFI4SEM2YVJKc1diVU5mRWY0dzRnUGY0SE5OR2huTFFPSEI1RER2YlUrMTRaQS9wc3ZzNmp1VE5JUmVKajZGdzFzZ202QUJmMlNreE1TMVRPTlVSWCsrL3BRTWZndC9vcWUxWUhCL3IvYnBTSGpiMURTVVhxNGRXWFVQUEZidk5KOFA4VG00WThzTmg2QzBWYzF0dWh4VldqdFBEOVNIWHlQT05Day90VThRci8xVWhRWllhMkhqV21SQmh0eER4NlJQdzd4cHduSmRuUEs0Y0c4L3NxRGI3MnZJWmNTczJtbHhmTVVIY0pXUzQ5RWJ2WExkM0xsck0weWx6Q2pNYWxqL0ZDRHZYVndwYVJTRklBTGRISlpJbUJUbXYxbDZqRVhFaVFqUHVFMzJIdnA4aHJCNDI5V2dTbUlCdkNIS3I4QUFDQ2MrekdBMmw5c2lrRHl2b21ncDZGUVpRWFcvSkVrdzhOdUdBNTZPYmJtOUloeitsWXVIczZvM0Noa1hoaVFtcDFOeUNrZ29tcWQ5WDN3ZVV1R3dQNkkzZVAyaXVHQW0rVXBaZnNGbGh1S3lVUUc4ZmNIbUtmRTlVdXRUaEFnY1M3TkVVSzhsZC9WeXMrV3k2eUliZFZrK2ZWMmRXOStiMG1BUEVaSW5mdVhTREszbXJoeWV2MzVpMWVhTHZ3ZzdSZVprekc3aEE4cTJQdXo4b1ZRc29RTXBiTFhaTFRQc1BBZVFCRGs4aDdxMy83NWE4ZmZMbGJ1bUxsL1lqTlJpQU1Ud0RWWU1XN1ZZRGNuSzhOT2RiazF0UjRBNlZ4cU82d0x0ZkU4RUg2c0gvNzJIMTNaU2VsK2FWRWpRdVI1MU8xeS9EdWw1bnFZOFBHSEExbW9uUCtjb3dSWWRsWXpiZG5qMCt0MjNGSnAyN1RGTW9WM2Y2OElrTjJIUW9vNkx0L1pRZzlUbVFqNzJ3ZUFmZHdSYk5nRmJKUlltSVdEVGtJV05RbjZTSFdCNnVDR2dWejU2V3ZJbmEyY1plS1ZJMDdmSmdDcXhlMHNXWUZxVTB0QlBRQUZNK253UVhONElsRHJ3VHVjOVZGazhhTDBBUElHazdaOUNkSXlVWUNpdVpadU5CSXA0YUZjSWNKTmFFS3pLR2xxd3pDWklBMndLck1KLzRjTEFUQUNFNkNTVm9Eekh5elFCMUQ3Y2FQc0pRY1ZVL3pCU1hoTEUvYzRhVWlxVmVKcXYxWThSRjhXejlPL1MzRDUzNWpCcXdXcC9Bc3pZYU9GMFloK041MEJ3Y0ZWZUJtM05KdXZlcFhJVDc1ZEVTY0l6UE04MmRyTVRTcnJNZXlFWWRmTVZ4VHFhTDRlc3JnSURZbzBEZWVoL2p5K2tleE8yek9lL0xQV0FlQWhxYXp1VXRrajYxSVA3eE1ZVmo1NHZhNVFPN3psNEthN3BDTTNQRDk3a3NIZ2RPNzFHVDczdlhtR01WaGNOaTM2K0FPMVRoMnJzb1NxVzBNRExPc1p3clcrTk5lY1UrSDBrRmd3bUlseS9MdzlhZXBqM09aUGdEd1lEUW9UN3lDcHpCcFVpS3BBV1FhaHhvRHloeUZVYzNLQisxQW5XcDd3QmFEY1NJSDJDRURVVWIxNm9nNTFsY2t1THdJekRjaHVNVld4Z1d3aVJnUjA4QUtPUjdSa0J3akI1dXNPS2U0V1pLSkVnOG9INGovSjhDRk81VHZLUzZtNTlzMWE0Nk84WHVMaU5Qdmc0TElwb3NYUE9wQWpwT3BlTG00SG5nL3p2MEhpd1dGeWxzMldwK2Z0eWNZamQ3aFhqUjdYOTJ4TitTMmVXdXBZSjdzSUtTbnBNZ3FBSUNaSXZ4SDBHeThEbng1a3IzYk5nanJTR1NoUW55em04anBMMVYvZVUybFVUTUpzcm9VVEYzeFJRWWtrV0cyRHhKdWU1bU9HOTlFUERyL1NjTUo1a0hZWXNEdUVPWFpqVkdGTXhaSkhmSEh3ci9HSXFXTmFSQVErVWNQTExlMk5DRmVjYUwzY3hlYlFnUUlSTWRZN1M4YlN2MjAydzlQdXh6VUlyQzY0enlQczY5VzlDMkdjQkI2UVY0dllRZUNoeCtDa0NYa1NQbzBWdkRSd3lBb1VtaVBhcG15RkRMcHBwa3pGT3hMeXpKQzJRWE1TUEhXVUtqaXl5dXZjbW9lMHNWQzhSKy9IREN0eXlrSExTSHhEWWdKV1Zwa1A3U3U0Q3QvaTVQcWkxZmlJNm54NFVkSTFDTitPOXQzT3VmS29od2wzejFpcjFwZng4akRQWDI5c1dtMHJoNWxGZDNMbHJLRzlRWm1JcDdwR2cyMGNLQ0FoZ2N1WFhGRTBzWGtBQ3AvQUVDTkVGVmVJSHVwMk1lSTdxcXF3QXNuT1cwYUhzdmxmdDdtcVgwOHpISHRDaExxa2FVVmVJTXJVRzR6NVJ4UG8yRURmbzYySGpLMHh0SXlGQXg1dVpXMTdQRHE2UGFXR1kybzdGN0xMdHljeTNUYUgyMjRjdGJ1S1JlY0RaWUU0UXNqSVQxQUFOUnhmdDI4cTVVVk1oQkNFTjdjT3VLR3ZWVmRVSnRCWHBwdXFzNUhONmxBL2xKLzduSEVKY0RrTStIdm0yVG4ybTRQS0txb1d2NUsxOHdheTRqK0lEQ0ttN1pja2tzaVRGNlZYZ0EyT21NbzZtL2dBYzg0dEQyd1pIbEpVdFBCelhqc1ZkMGNZcVFZVWxmL3NocWpObkR5Z3ZxWGhiZGFsZVltLzJST0JWcXFDck5DVEx4YmtvUGZjclR1ZWltK1ZXWHZ6TjBSM09sVEhVM21LL0tBVWZFTG9jRWljajhpSFN1VTVtaDdxcDZXcVdMdDBQYU1NZzZzaTZsbFdsNVl3VEkrcmhjeXB4T0J2MFJ3WFpzRDlpWjJoUTlPMUNCbWlxWWF5WGEzdGU2NlJ5YTB6ZjVUYkYyMk1ya2szdjVsZzFtY3JOaVpaYTRYYmR3djg5L1c4QlhPNENaU09rakVXYnBkanV0aW9ZcmJ2RFdpam5FaWpGTmJoYmVMK2JxZHQyZEUwaGh5MXJFT1BWeXNwTkZvcTU2WTBLUVNTdVpiOHRkWFo0Rlo3WHIxbWhXdDIxUTc5V1FrVU5WVEN3VTVEY1BFM0Fad1lnZCs3NEtCdlZtd2o3SVZHSFgwYkpNeEhMTnlqbDZkR3VidVNLVGE1aHFoVVN5Ujd5Ynh5K2JEODlnUGI1MkJ2VVJnQUlTSFFZekhKRVdObHcvbSt5K21kUGlubXBLR0tpUDBWMDFrSUZVRWdZZGpqdzNxKzlSMEx1TmtiamxpcmVIZVdHc2ljeDJHeTh3SGJJT1NkOUg1ZVl3WmNZRDJhL1ViOGpjSzNSOUkyVnRraks5d241d2IwTEpEZjJ1U0tFOHFoNmVkU0o3MU1TUDhtSEp1VjUwRVplWXBmTHN6eHQ2eGZyRktsNVJva0toL0dFRExnUkt5bkIrWmQyK0JWVDRiV0crYS92cWdDdStUN2tvemJrbUZVMjRlQUIwMUJQZ2cxNElYbUFVSDErVys1V1doaXZYNVRjN2RxamozYmZSN1pibm54aXJhN0tDTk94Ti9DeFJMYUsrWlRSa2ZZdG5td1paUFhUSnViVWYzQ2F0b3ltRE5tajNXc2pKb1NwMzdOVjA3RnZHMnpPTy9wRmZGZkZkaDZ5b2cxZVR4eDhuaGl1amV5Sy8ybjBJd2hFaUZ1Q1V3a29EUlZQK1RQMTY0SDMvMDMrUUFBOHFiMTVUWnFnTFlqajZ0OXV2N1dDSGNuTTM1NWE2RnZyM0pGeXMxalJGVmJXN1RqTDRpL3JjMEtxUFpQbGRmZVhSMjFFMWVveXcwVDJVbmk0b0V3eVo3L1A3b0VjWlM3RjBnYWxybHVnRkQ2Z3VubW5jNE5FUktCd3pmMFlvdEtxeWM0VlY3d2xNWnNMNGZ2a3NiZDkrYVA4Q3VaaWx2VlJTMnc2TmFtNXM1ZElRWU5IcEJFYStJc0FmL1BtdjhBRjhGeVFBZUh5ZThCMlFZKy9nWjZMeGVtVXpuUTg3Q0g1ckVaTGk5UlR1bk1NNTdSVXR4aDlYSnV6UU53Yk1sck5sdEhTQUZ4Um9SUTNSbFRZR3hBMThPY1dGbWRGTzl3N0dPV3FyYTMvL2xwNmZ0OTF0Rjl0ZmxydTNqNzZWSW5reWpGVm5HZUhMN0E1WnZ5dnF0L1EyUWp6SGhCS2x3RTdheGl1OWkreHA2bi9IaHhhMmFUWDA0QXFkazc3dUM4TERaTHNPcVovcXI5elFETjNvdXlQTXQvcUNld3lua2FqRDNITWZoaXB4RnM4bkQ2K3E5NzF3VTdQRzhrL0IybHlDaWhScE1yYW1mRFpxSUZqc2IyeUR1Sy91dmZKaUdPeVZsbzRiVEE4N3Nqdm9iZlRkSy9HTCt1djdmM2ZmYlFnQU9kSHdZbStQdFZselJ6eDM2NnIrQTlnZjl0ZENwWEJYTGdPYmFZeVI5RnF4TENyVmdQSjBWbTdhKzlVaHFjc3hzUnVwV21wZmJZR3MzYnVqakZFanN1cHplWGJOaC9pLzRnZU5xT2lWZm5rRS93Vkw0b0VBL3dyRlFnbDV0dGRyQjhRbWQ5MmdEblFJRTlqaEowb0pXN1FRSnZCa3FMVWlja3diQTI0VWlEcWpveUJiREtlUzNSSS9mdkJRSlErWFlxa2NjYUZmMWRTL2ZmRnozWGtmUEJxZHp5cWV4UGxXS2NXSFU5RmZzbEZ2Z29lQUNrVDNycTk5Tm91RlBqREV2S0lFYnNFeHNpaVNZbVJ3NzlzS0I3dmdFQktMakYxZnJNZ3Bqbk9IcmNwQ1dUM3dkWTkvd2EvMWhQWUpiK2lzSTNIYXlmcitVVkVxMSt6d1JBMmREdDN6aHV5UkdWbUFxT0JhSFQ0S2ZFbEIxWVlIVlhlNEFkM2N1VmFsanhSUS9mNE41MjRLeFZ3OXNqbGF4UE1EdVpHNEQrRWxxRnd5N1JSeGVCYWsxN3pLdk9jcm00d1Uxc2ZvQy9Pb0F3UklBVVFRZWxLMEFFTlBZN1lxSFFBR2tXU2wyS1J2ZE5MeUxYWmhsbU9TNldkUzkvV2paU3F0Y3gzbkJnSk9iU3o0WDBhcDdjdVVYTzFDdmNsTW5SL2VlK2lGeDNqZ3ZaYVJPU2lVcUtnenlmV3NJay91eWV2cFE4UGRWbmRkM3RURTVsalJ2UXU5amtQWHVWbGwvdkR1UXpmY3hnMEQ3Y3VxUjVacUN2VEIrdHRCb1J2dEoyTFdFcExWQjlLNUlaeG5nSUFSNHdQSU9xbnp0SHRxL1ZlTmREZGw3eTBZSDViUHFLOWJNc2pja3dLYlh4ZmFESVNBd0pzSEhPWkVHREhTa0txUFR2bXp0dVpOdG1ZV05jNGJLNnMyUndRem5uN09OS3VNcnZ1NEk3N0VxaXlXeUd5dlRXbUJUMFgzaDhlcjhZZHl0b1F5dHBBTnl3Y1RZZW9FNmxvVTZKRW0yOTFhSlVYQmFBZGV4cVYwckp3ZHV0aXluK3FYdGpvbzM3WlVFbFg5Y0EreW5oWkdWK1BvdVl5Q1pTWk1uZEJhd2ZaU0IweXJuMXJUMXgvRmlxOTRrbnVaalNtOXA2djZuTFhMbnNjeTk0ckFBbzQzNFoweEFZSHk4aUJocWd1eTd3TmNZYUhJaWpYc0c1N0x5ZHRKTlhsTUJuSHg2MmthYVlyczBHc0tlak1YcjByaGF4QW5yajJWcU9XNlJWTnZLcHBIU0VlVG1rbGtrNTFXL0d3M0s0Q1dYTmg1WFExd2lQa05zajNiSFJZNlBMU0laRVh3S20vL3dlM3RqbCtGUm1nQ1hrelV3Qk94T3ZzTk50VFA3V0VqRDBCNVM0RGZ4NUFzYm5mR3RIak5VUjZiM3ZXNmZ3T0d5RDVMMkhSZ1dld1VGWnRVdTA5ZmFjbFAvaFB5a0VpK1NIRWNOSlF4VzFRdnFRZEFKUTRmeVFyZzhoTVVhZUhkeTQ0Y3JVUmtnUzFlR1hQb0VST0ZJM0w4aUFNY1VPWUZVd0lkMGlXQkZLbEQzSVhLcU55MlZHMnIycUdNZC9tMFdEemNLWDVPYkphYTJydmVFYnQrODB5TkdOc1dqbnp5MEVXZTg3WWx3N2FJL2UxWTNFaVJIcDIyNmVkazVKTTI5SjNpRUUyWFdteS9nKzJTdXhYSzhzVjY2VWR1Z1UxYVBHTFNEcXY0a3Q5NFZERTNPS3Z2QnVkeEMrellpbDEwcXZvVDVvTVM5K3NvWFZ6bUJkZWNWVXpqWUZwVktsV0Q2TTdhOE1KRmFrNFR0TUx3WGF1N1d4L2tIVmlWSk5rYUFwTFlZaFBrZmZrbWF3RzlPU0JEbWlkUkdoYTdocXhydWVwTVFUNGMrVzl1T0ErWHYxUXltMjF0NXhLeUZjcUdRcWpDV3AzNHpGektlM2lSYzZBckw4WmtGYjg5WjV5UW9hZVR0b3dMTWs5aDFxd2JMZEk3TEZBa3dQUDVKMnFqYThDMXJXMWtWMXRJRXpBY0lYQTBtcWtrMjdMb2JXd2dMMDh2TE1rNkRVaElSaitCRzRCMmRJUkRhdVhCS2VkRldBeEJSMEV5R3pMbDFwcXp6cFh5VWIxUGVhWnUrMmdQVDFMa1BUM1o1dUZ5a0ZXSjVhSFBuYXZVMVlzWkJuL285dWJzdlp2Mk82WFBXa1BQZjFPSXdiN20zeERLdkxranQ5WDhaRWlGTEl1WlFtK3JaRnU0R2FJcTJwUXZ3anJWNlJEQkR3cEFseEMxTEpudWFWWVlOSDZjNW9RYTVhc0lGUFNmbHBtam9lb3hySXBTOExyZzFPVUlnZjRhZjNYNnFEM3dGbi9ETzhvVmdqNllKOEFaNzJNdkJjbmtPazhsU2lCMThtOWFIWW9DSGxXdzJXSldFM0pENk1LaTBxSGpybnZWOUd4aGtPZjhlcGxLbEtEV3ljZGJsVmg0THI4dzgxTFV4K3NZbkd4S1hoTkEzYVM3YWxsRVArK3l5aDE5QzVubDlza21PM0pOUU5wMTNQYUFIRWRzamlNMlJ3ZVNaT1pFdnZSc0NhQ1pCcU5OeVJVQjFKU1d2cHZvWUxkWWJqc0w0dldVU3BTZ2hDUTFIWE1QMEM0SG4vMlZ1ZzlyVFRUVXpjNk51RjJuTXdKaGgrc1YvaWVBRGlKbHBSVCtha0ltTTV2aFByV2J2bFJMaDc4bnU4a3FVTmpzOXBkdGZpQThXbm4vRUQvNkJoVTdYWDFwS3hOdDNHcjU0NVh0T3E2MjltQjRiZUkrcnFKUW1vRENvcWh0WWRiWXFMUEN0VDY1eS9kUnpxYnBQSjUybnRYTzcva3A1ZFhQcDY4KzdLLzh1SkRVZ0g2WHA4MWJnazlvVjMrNXd5KzErZE1PNjRSSlF5RDgrUHhoUzJvT3NEc2EyOVhsWHE3VGJpKzZkbW9CcTRHc1NUWHd4cU12YWRtcUh1a2NaNkVTdG11RDY5UkVLelRqOXlYV0YwN04vRCtjeUY5T3l3VlhSd2R6TnpIMzI2RWQ3QlFJOWJvcFJPMXQrZ1EyNmd6bkhGQzJhbk4rdFYySGMwYUZnOEtOK3JMaHhQUFQrMHQ3WlNXMnp3dTNKN0tFa01rT0RJeC9KQ0ttRVVIRWVyc05BN2dHeTdDakorQWdWd1JSUzJJZmVXN2JwYm1Pc3F0VFFDVTh2YzFrZkN3aCtPNjdPWnVIMkN5ZjllVnQvMmQzeUVGWG5tVitldmZIY3NobGVVRWFBL0xLOTMyeXRabW8wK3FzVzFnU2lsT0pjcUtDS2hYR2orOTRDZ3F4d29OU0V0Mzk4WXhBYkRCcGhNK3h2Y0ZHV3dxUGJheXp3aVE3bmVtZk5VVlFVUXFqRG5Jby9ka3JBNVZWZEdVVFNoTkFYVlBYZzMyS2o5VmI5L2l4anVzRmxlcHpKd3NRS051VnpsRkY5L016dmVKVUNHTkZ2ZDBCVFFRd0dYR3NVRmdaMkdpVnZsbkV5UXp2anpsODBzV3lIaExsYXVNUzRTbDBJOExUWnNpZXRPRjJEU0JWNWlyTG1YZFpSSU1QVGNLQkY2RlpCUFhkNkxUNWlIRnRKbGNRUGIrYXdxZ0VWaXIwY2Zxcm9Hb1BvaVdHTDlmLzlTeVJLSVdvQ2hFS1hyZDlwMlRxZ2l1MDdzNStxeEJ5d0kwY3J6eG9RaitNYVFna241dk9tS2VtNGEwRklCbmdPU0xWZmtBUDBOWEpkYXBlUnZLb0poMjRWNS8zK0pFcG90Qm5DQnQ3VUZDQnpIY1JSL0QvakUyUTEwZHFaWFRxOVRUT2RKU0NWd1dIL1J6cDJRa3BKNjJDNS9QMFhTK280enBjRWpZR1NpYW5FWjNUaU01cFJPVUV0QXA0RktHenhxanVxRlZoclFvVHBtVk9lUnBFT3AwMDgvQjRZWlVvdlVvZFYzbzI0Y2dtSjcxbCtaR0ZmMlMyZ21CTzdpazFRcm9Od1lKS0p1amxjV0ZXMFlJbzBGcDVtMTEvWWdKYi9oVjcwOFVrcG16WEFTZlhDczdydHoweGJRV242RGNoRlJ1NElpYTJIbGZtb3Z3VXNZTVYxaWJ0OUtIV0N2aGlUaU5JcEV2bnVHYjQ4REVnZzFmTUc0NjhCem5MODd5azNmdW9aenhLL29YSkdKbzhGa1FobkRhSmJCaGUzdkc0ZEZKV2dUMDdoTCsyUkNaSitDOWVXN1RqZXpyUjZqRW1oWTRHZzVBYmtaWWtoMWh5bjAxeDl6aGJLMjRyeng3L0t1QktiVFlyOThJZzRzN3ptRU5xS3ZaeHJWR0hzQ2dSbnI1dGpJSHZYbEQvSFA2dXRqRkE1MlV0SjE4QVZ5RjVPa0xDUms1aiswQ2NMd0dyMXdxdDh3NmlUbEI5NzI5cTlyNndTMHZ5SHlpYktKSkpQVytwbUcyZnlqZm93b1VaYnZwNVhubU12Y1ZlTURubGtKLytyK1N5dlBYNU1STk8xWS83QThwelNPMVA1Lzhjc3B3aHk0M3h1NlJsdFBKNWptZE5Ca3A4QWErZ0Fpa1hsYWFmdzJwWkhlalk1ZnlHKzV3MitBSnRDSHMzc21rQldtdDZrVExIZXFsMGhHOEpzNXAvM2pJVk9LY2Q1UlJyMEdsTXVROHQvemhFbmUxTHVQWU5Bc3RxYkRIQkxuSUJBUTVJVEFBM1lQcnJlVkdTT29zbDFkaWZ5bkVBeWN1cXVScVVXRzBSajkwQzNtbmp5ekUwTll4QW1DVmo2RVNwNnFuRFlNdURiQUhCZWtTakhwQ2NsSEFoY01DZE5xRU1TZnF5dWg0VFJwaUZUZGdzRnlrQTNVRGpOdEFnSHF0c0syOEpmVlJDT1VxeXdieUxZNU5xSEUvbGVCR0EvaUFxRFl1dVFOWjVyWnluZElsV01xMlhHYzZJRXhLKzBiSkZScXh4d3AyVlRDanhhcUhjbHY4TFhrQnkwdVdteEE0ZkxNUUp3NFNQRXc0L3kyOW11Mzd1NFZsMExHUDhRRU1wZU9YT2pCU3VmK1c4SGNCQlpEZ2pUaWdtN0ltRWFjS09xREFUeHpob3FhcStPb0dxL3dVVXBOYmVMUVBJTzZIY1hrcU9LL0dHeTZPL3dVd2NNVTdZVGpoTVdDYWNzTGVsOXpaZUtSUHZXQWVGdmZVT0tOU09lbDE0Q1lVcmhZTTZILzcyWkJpRTZORFZLdERwaVdDd0tnZ1kxR1UwNkcxVzFGWGhDTUZLb1hnam45UlRCSmNYK0s1bk13V1UwWkEreW5rS0lJcE95SDBWMWROU2E3dXUzSXJCNmNhZ0xWNFFQVmh0UEs1dFpxa3IrOFpRRWFzUWRRUUc0Z1U3cnB0aXRuSisyZnk5eFhDWFkyZDFmbkYvTDFQeUY2YkVGS1NtTXdSM0lqamo4LzJWWXBtR2FuUk1LTkVadXBraXlxRnMzem8yWDBCc2VPbUdGMk5NMGF2elNrVmx4QldLM09IOWFnOFlmWko2Z1BPU3Niai80VVVaVkZFYWUyK055eU82STdpNFJWZGlJY1BYeXVrelJuVGhPNHF4Mzl2WngrSUZST1IwUFZaZlNnd3BOMlVzU3NzektFaVd4bHdra0Y3SityY2FickdvOGhSYmxOZENTcHVKVDhsMUxCbHFseXhtcmNob25aRzJ2ZUtoa1RCckpzNXRUYVQ3cW1EMGlFc1lFdCtzQTNsUjhQZVhNLyt5WVBGbG4zK004L3d3SlIvRHZlcHh2VDB1UVZXWUdlaFUzWjZlK0tFWFMwWjA3dDRhMFF4b3BwQXJMZ3FXbWVmUGl3ckRjbXlablJtYUcwM1lCSHVSdytQNmFHRWJoOGZmY3d4Z0I1aUsvM1ladWY3cEFOME4zaVZmeFFEUXdSSGEzWW9aTDBIZmlDWkxpSmg3Vy96WHZKZ1pHUXVCNXN4L0d4RlVGbVNDVlQrYjBuUm5pK3g1RmlKU0FnYzV1S09VVVEvTGhrSWVROE15dHpxUC9zeHBERFp6LzZFWkFjWU5TSGw2SjR0eVNRQzVwUTBRSUE1Qkd2aEtidHdEUVNLZDVpN0N2dmRwVmZrR2VNSVdBVkp0dWVLUzZrNkFVc3ZrZ2phRE10WGRpRzhSUnBYVTdUdURFRGxkRFd2V2VlUkZSRnRyNzFGM3RYbXZMN1hEdHF2dk1XWW82Y0dGQjArbnNHNVl1MmpKSFo0STl0NVo0bW5GWHBoZU9BRi82Q1BBdVhPNUxRMHpSN2NON29GRld3Snd3M2pZZ0MycmtZOHJvblFPdm0rQVZMZ2hubWRUd1pIaVpVOWY2MDRvMEUyRmFsbTNEeE9PaVZpOWs4NGRZNklzMWZhbGF5RVdTM2xrcmNESmxjelduTzB2Q2w0aFJVVkJqczhzbVRWMm1iYUJ4OUhRc1BBK0NqTHpRRjNBQ1VTUGhCRit3bTZwUWxMQWFUS2xRMWNMdWNvWXcvek1OK0thR0RuVVVVVVpWOFlKMHFaTmN5Vm9KS2NFYm1Qc2QveFBnWU10QlV5VU9Rdmp4NDh6d3M0SERDZmh6Z2cvZ1JhWU5xTHlhN1JaUXVGUm1FODZRSkpCUXlsRU9KVFg0RzVnSlN5WTNBRFg5SWdDVk5FOXI1Sk11UWlrZkNGT1FxbDFoYTRIQ2RGUlhVWU1oaTFLRVdIMHRZaGZRSTJRZ0tjVXMwbEJFTml3b2plNFk5SXQ1eGxEVFhXeWFKSHBwUzEyb0d3QlNwblVrZURJUHhaVFRmWC9LdHhvQUFRQXMvaTJtUHZoai9OdkZ0RXZBQUJQL3NxN1BZQzNsUHByYzZQODhFLzlWUUFvQmhRQUVFRG1xdzhJZ09LWXZ6NkZGejhMQ0pTUEpoS21CRjNsRm5adThMKzE0Wm5LSGZDRWpXS1R1Y2ZDRDRZbU0rbUVYWjJTN1h5SlZCam9Ga2tLa3lVZko0NFh6cWZtbkhkMGhwUzdzYVBmZEtXOWI3by8yT3RHQW5icGd1UUtaM3Z1MG52TWpjWkJJbHU0ZUxMRkRVZkpxWExNVnozNW82VXNSTWpKVjJRb2ovdEVpZVh6R1RjdC83Rkd2SDdmQ2Q3eWNJS0lMY1U1eWhrRGljZGJmZHlobW40aDlBeUZOSnc1V3E0QzRNd2tUZTdCSjcrckpzTUVSWnlvYVNsSDRrS25iWFY4Z2lLUnMxOXc5Y00ySWdGWHY4QWVCaHhrY0ZLQmVHTkxrRm9FcXJQMnd1bGlCKzZUTm00ZzlCcUJWYUtQWDZWRlRmM1pwellpZWJZcnlzRXNGc1lRV2VDL3gxb0lQdWJtQVkzREdRYUpjQ3UzV3hoSnN6NG9Hazg1MGhkYlJCcldleTE2cjBGZldvYnB4ZysxU3A2N1A1blhlMHNldHVSMXh0d2pIMXVpY1RUbGM5cE9mZzlRb1U0cEszeHZhT1dZRmdOd3JkR3NFeWFDSHVkMElkTWxxVGZkOHFNYmtxUXJWSHErOFlJQ3AyY3o4L0UwM0w4OVN6NmRlSjNsSHdaYUVHbmk1SlVETVdOMzRtWEVtemlYY3JuR2tUTnM5Z3N1MVZtVWtSTExMZXUzSVVWYUsrakpMc2piRnZSZ0N2SUdCVDBYZ1B4ZEE4TlhpR0JHQ3R6OHlKdHRVcExIRkZjbC9NU2VSVDRxdFdkRmYycG9FbWlHU2pTcm5rR2dnSElVV0hyMFRNQjBTcGtsdGZzUXZwRmxFd09iQkU4bVFmSmRKcGdRRSswNFd5blRoWngyU3d4YXhMMFRFNjBuLzNpVXk1YS9ac1ZmTSs5a2FRamZmVVR3WWlpVW5IZ0pWZ3p2elBkbXQ4SnNnLzR4SWMxdG4rWVBGeWZmL1RucGZxUkN4OGdYRmw1bUh2ZXg4VlhrMUtRWXBzV2RwN3JocW9KQml3SktSUitXVkN5YjVHWFpIZXV4LzZhNVIyNDBxNTZWWlRMVDVHRm5nMVBlU1o1d2Qwd0ttNENlYWkrZXA1RHJYU05oWTgvSm1mbDlaMkgvYWpRYy9wZVA0bUNUQ1owNkRyN0tlOWRja2N0cElUd1IvSkNLNFB1NXpKMStGejhLWDU3TGJyRWc4bDE5b1RGUmg4Z0JpTVlOQ2xwaXJqa2dZTWZTbXU2ZWNiTUFBczBmOHdVOUg1UHNPVzlPRlA1ZmZPTFZkQWQ0ZVJJeXd5ZU1FUStGbk16MXdoVk91Y2tMQzZkbmk0UmhpMG8xSDRleEVjQkwvbkV6SmRwU3JpRk9PSHF4NXlKUDlqdjlYTjNQYTZkNWFvYXJKcUtvbXYwRTU2Q3laRW5Kdnk1WXdaUjBsMmJZWG40NExob1JOdGVsS1drenFwQmxlZW5rdGNxK0k4VXhnajFKdUFsMGR3Ti9pZ2xtSmxnNHJzWTh0VG1zbWhnQ0hKVERwcDZuNkFsVmtRT0tJWk1nQW90blE5dGthenhidU5uc2hMZXNxREhrcUl5Z2RZVGtZZ2dVWXBObnRDbGtRWkVkS0E5bVI0QUpBVFFOaEgrQnFZRzJBQUhBYXdDQWVjajY3SmtZTHliSWliY0x3dFdvWTR2NmZ6SzUzMEZkWTlaZGRSTEw1QzBkTkZKcUR1TjJqelBGNC82SDVFeHBVN3h4MHFzOXJGYkxLcHhqeWNPKzNZUkltUis5L1g3aHlXTXBjNENUZjVDNUl3V01SeFJLVFNKZE1GS3lZTWtYbVQrb0YwRXdSY0hWV0pQTlRmUmNvaDhLTlkxRzA0QmpqM1phZU9qUStPR05TSHdzUnhaRGpEeU5yZ2FPMklVUFFwM3hoY3BOQ2d4YVBxdmpoaFMrVVRjamtzdlNrVk9ETElBaWQ4Um5TK3VoWmdsSHhDR1FnL0szSUFtekhJSU5GR1VONE9veDllam94RmdRVFpjOVhvcTVKcEtQemFNdkY3UldVQmlhcWNIVkVvcTkraUhrZW44RDZVeTlTTmd2WFQ2NXFLWDNlWG5qdDFia0JrSE1udkIvOGs3cUpGZG9vRDhXUDlPWWE2Z294TmsvV1VpR2JENUdIYmljazR6SlQzTFJuUHVkakltbGdnRkNDdEU2ZVlNaGtZTVdPUVJJVHdpR0RQVkR3MHd0anJHSDdBdEtuTVNmZWljbjlzNG5RbG9BRnlXRkR6Z2l5UE40eVVnUGlsaEJkSmZzWWN2V0NGbk9wQTFLenhnYUpUUExHczZjbGsrN3MwWnVUSVdKQ2hCUW9BYUQ5OUZ0am1NZDhNVDNNUGhLUm9LT0gyOHMrZEJ6bGdDVDlpRC9ZVlp0QU12ZGNrWDBLMCs5eldaQkQ4WFBUUHB6RFpBRWkvZkRPNFB4UnB2ZUlHZmQwZGhKS2JPV1k3S3RmT256ZSt4WjgzWFB5TExOSkNIMG9nWnlHVERUNHhIYlhjazBJeWg0dHZwenEvaFhMWmhEQm15d29oSnJJREZkOFJjRTA5aWRvb24rNUxheFB5RXJMQXZBNVdpcTVZakZiclMwSXFnUDIwY0Q2KzVjaCtBUllaRWJtRTdKRFNZdmdOUUh6cnkzVnFySVJzSnl3bWFEWWZIN0ROSzhUbmhvVUhVTmpMVWpFZTdLcDc0V0NUbDFMdGM5ZC8ycWNYcVl0NnJBV2gwQW5ocEtNSlpWT25LcmY3YjFtb3ZyN1oydVphc3FjRlVIQU9hblc2MVdNbW9vd1pyN01VU3Vhb1plQlk4NndWQmlQM2p4TlRtMXVqK1dxTGFyTFd1M21vRjd4TGExdjk3a1pxV3ZmSU9MYXpGU1lOc3hTWDgxMGZOK3dlMld1NkM4cTN4c2N6N29OeGxWN0pQUnVsUFlVVld3TVQ1TmNsazZydWNUek5wTG9uMitoS09ST2JVVEhJbmdjVXdNa0xrY0cxY3JSc1drRUhoMHZiUmZQL3pWM1E4bHZJR0hkT1JXUDJqRE5VZlgyN1pWenVETjFNQy9PK0R2VmQydW5DNGRVY0RQdTVqWUd6K0dwYzFyR05kaDR3Y1JzTUM1U0JqYjBoVUdDanF6aVpRa29xSURPeWt3OTJFUVU5WWhJYjRTd3EzOHk3YzlIMzR2NkZBVlUxa1Z0d3JrYXRlMXNnL3pXZlFFcDhtWjdCdWhXWXd0bkZUdTRobitjRGoyeGt1WUcxZkxFMndwdDhoS2N0Smd2dEc1SnhWekc0ZjMyWkRRY3k5aUFYQjFtYzAzRXlXem5QYk9OTGE0YThWdVhqNmNjczk4N2hwUEc1WHlYOHBxNDRMbndON3JLbVRoU1RLZ29wOXRYR3JOMXJKenlOVHJKcDdkTnNZeWoreVl2U25QbVdlUVcyU055TTgvR092KzlCQS9KT3ZhMkQ5N0ZuMlp4aTdrRE5uQVg5WDc4djBVNzFxdnBzdGlQdmxOMFRXRDhha1cvNGhNWDBSR2tTUHMzSXJWS3R2SUh6S04zQ0ZQbDVrT3IxK1UwUjQ1ZW5yM3RkSjNGZTdabTR3NzRoY3YrNFhkdFE5QjAvbGRYZXVWN050SHFwNllzbkkvS1o1WnhXU0RQNGNNbUhidkRsZzM1eGVSdEI5MjdNM1B5Tnp3L3REZnVkdHZYR2lqbGR3RTI0YzdYVThSbmhIcXYzVmVyWExGRGp0dTZkUDdzZGRrcEhPMDFTMDVKcUJoVy9yOHVwLzNTekdUYTdHMzEzNHNwUFV6Y3JkdVR4U3pTcWtwU25Nc1prbVkyYnVsTkxiNHo4emZNWGZtVm56bFgwUDhKdGR5dHlsMkRyTDFrZkg2djhYVUpCcjFsV1VENmVnd0N5dk9mOTNCWkFwNFovVDJlWmMrL3ZrUXp4N0R3WXRUVGhBNy9rSkVOSHNVYnp6bEdNRG1SWHRxai81Wkk1cnR4Y2xwSEt6UURjdzl1ZmMvL2NEaWt5TmFJUytzSHhlK2xiem9yWkZpSUg5OFc3MGo0ME5zbnYvVFRSQklLcUNjdm5Tc2tMOHBOaFhuR21SVE9CQmd3d3NFZDFzN2dQY2tteGNjTHZNR0Q4OXg3eG9QWkQ1QmovOThpb1NrK1F3cTArZUw0Zmg3dmhRaDJiTHNYTGIwZGpuT050bjQvZTFkd0lCQjBPbm5mVEdQaURWaG5pRFJuSEdtYTV5U2VSYnIrMjZlUTNrcjVua0VOeWNGMU96TGVSR3lHNTBYWXozcHZCYlQ1bkJiUXZyWTJYa0lzOWFQWlV6M3hxODdwMHRvcmx1U2ZMWDFQeDJubVpEb0d6bkZ5dWNQMjRBZFVZY253T3g1aHZ6ekZhdlVZWlZySVd2NElDTUltUW9QUGZFUHJ5TVoyZ3czNHpPcmVMbGw2TE5DY1NoYit0WmlwaUFCenhic0lSTjhNcC9USUh2THRFQkI4N0xNVTZtYUxmekhLTWJuWHdGSU1KZ0dtcXJLS3RvZ080Sk9GU2pESUtXeVN2bjJPVG9Ka3JFZFZtczNITHBWa2NyU1Z6UjFwWlJKL1JzRzhZcmJ4R0tsMzZFU212aWgwdFJTMWJvK2pHNDdlQVMwVDNwNGp6bmZKTHZiVUhYUkYwQnRhQWxrMEJwTnF3N0NjU1ZISmxBbHJSTkxlelVKRlUyWnNoMjFZQ0hUQjFhRHMwRDZyQ3JKenVoYUxhanp4akp1dHRzcXFQVmpUSUppbFJSNmZEWVNDVTB3SmFwdjhzT1QwWHRkUkpBakVaZE5pWEZDM2tkcXdWZzVDU2tYYnFOL1Rtb2pjN0FEeStsbDllM3BuT2E0ZXRHaW5lcWxKbjZHejlyZVpIOXRFVXhlK1ZRMmdMWlhYOVB1OFNuclBWcHEzU1NDWmFNbnJ3bkcrRHNiSzJsQ2RsZTFsUTVwd3JSb2J5c1ZUYVE1RndmVjBVU0xFN0NPeXBwWXNKZWR2cXgySUNmTzEwNXQrR0E1Q1UyamlkOHVDemR4MWlSa2VjVEZtRFJKWjVuRHF0TGFJWmlOb1pwc3Q1UTYzS0lWUUprTXU4aVZFdUFXN2s2ZGN4TURaYzdGUHFnU01pL0xtc09vZE5Xb1p0US8waWpMbm5OVHNhcWs0NUE2ZUU2SWVrOGFBZVRGcWd0Umw5US9jZ3NnbFU3NnpVK0JNcCtkbXFCTVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2Fzc2V0cy9Sb2JvdG8tUmVndWxhci53b2ZmMlxuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTWdBQUFESUNBWUFBQUN0V0s2ZUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeU5wVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTURFMElEYzVMakUxTmpjNU55d2dNakF4TkM4d09DOHlNQzB3T1RvMU16b3dNaUFnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdUVTA5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5dGJTOGlJSGh0Ykc1ek9uTjBVbVZtUFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdmMxUjVjR1V2VW1WemIzVnlZMlZTWldZaklpQjRiV3h1Y3pwNGJYQTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzhpSUhodGNFMU5Pa1J2WTNWdFpXNTBTVVE5SW5odGNDNWthV1E2T1RrMlFrSTRSa0UzTmpFMk1URkZOVUU0TkVVNFJrSXhOalE1TVRZeVJEZ2lJSGh0Y0UxTk9rbHVjM1JoYm1ObFNVUTlJbmh0Y0M1cGFXUTZPVGsyUWtJNFJqazNOakUyTVRGRk5VRTRORVU0UmtJeE5qUTVNVFl5UkRnaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElDaE5ZV05wYm5SdmMyZ3BJajRnUEhodGNFMU5Pa1JsY21sMlpXUkdjbTl0SUhOMFVtVm1PbWx1YzNSaGJtTmxTVVE5SW5odGNDNXBhV1E2TmpVMlFURXlOemszTmpreU1URkZNemt4T0RrNFJEa3dRa1k0UTBVME56WWlJSE4wVW1WbU9tUnZZM1Z0Wlc1MFNVUTlJbmh0Y0M1a2FXUTZOalUyUVRFeU4wRTNOamt5TVRGRk16a3hPRGs0UkRrd1FrWTRRMFUwTnpZaUx6NGdQQzl5WkdZNlJHVnpZM0pwY0hScGIyNCtJRHd2Y21SbU9sSkVSajRnUEM5NE9uaHRjRzFsZEdFK0lEdy9lSEJoWTJ0bGRDQmxibVE5SW5JaVB6NVdIb3dxQUFBWE5FbEVRVlI0MnV4ZGE0eGQxWFZlNTNYdnZEMmVHUS9sWFFjS3VEd2MyZUZsQ0FHblVuN2tUNlQ4NkovK2FOVGdzV1BjaEpKWWNpRU9DUThoRitHMGhGQ0lIUlNFcUF1SkJDcVJhVUVJRWJtQnBwQUlCR25FU3daamU4Q09aK3k1ODdqM1BMcStmZmFkR0ppeDUzSHZQZXZjdXo2MHhQamVjODlaWiszOW5mMDQrOXZMU1pLRUZBckZ6SEExQkFxRkVrU2hVSUlvRkVvUWhVSUpvbEFvUVJRS0pZaENvUVJSS0pRZ0NvVVNSS0ZRS0VFVUNpV0lRckZvK0d2LzgvWUgrZi9uc01XU0hITUNoeWh4cVBUVGR5bmNXeUozU2NEL3p0aXBpQjN3WFNxdTZQMTdhdk4rVHlGQzVnZ3Y0dFJubW94V1RQMSs1RitNejE3R1B2UGw0OUVLQldkM1VzZlhsbFBpc284VmNZdG1QYmEzZk51S3JCVlhyR0ZDYnJkUHdYbmRGTDQ5bHRJMzY3cm9PcFNVSTRwR3lwdjlzN3ErbHRqNkp4cU9RMDdCby9EZ3hHYjIvYThjWDBDbkFXWEo1ZXR6MlRxZEhpWEhLbEtqOXc2aTlYWDhJYzQxRG1JOEZWSGhtbVhrODVNbVJoQ3pKb2lUV25pZzlMZkpSSGloZ3lkeHpBeEpoQnI3QmgvaEszeXUrcDk1NjhGbGlUSkYyYUtNWmZWZC9rUU9jS1A2T0JtUzkrUmptNHpKNmZhb2VOMGdPVW42MU1uY0xYNENKK01SaGUrUC9kUnhoZmV3MkRmNENGL2hzNGpXZzh2UVlVS1lNdVd5UlJrTGplSFE4WVAwWjltZWtWakE4UWozVlZjdW9lRGlYdTYzbGtVRTB5bTZGQTVQWEJhTlZyN3F0UHVtR3lQUjRCdDhoSy93V1VSNWNobjZYSllvVTVTdFVITDhsK1hFeDJheGhrUzZ5aytjaEp1UDRyWEx5T2tJS0prUzBCNjdhZGNxZkwvMFk0cGl4eFN5c0s2VjhZbDlNejdpMzI3Mk5SRmxoekpzdTI0WjVsOUU5QWhtd2ZycG9qN3V3M2ZadGt0c1JaS2pJWG5uZGxMeGluNytXOFpUQndQZjZJK1RnOUh3eEsyT2I4Y2l0YkNvQm9heEJ4TUN2c0ZIK0NxakhDdFV2THpmbEtXVWNwd0I5MWd1cEc1ZjkvUnR4MzlaWkJ0bVd5SnRwaEt6SFRRVzBkaVAzNmI0YUptY0xqL3pHYVNrSEpQYjRTV0ZpL3RPSmQ4YlRxZDlzNDhWQlJoNFJLZVVYL3ZqZ1hnOGNweUNtejA1eGtKeWx4U29hOE01UkYwZUphVklJa0dPc2cyeVRjM1VncEQ5NHBzaVd4RU9xRE5Zb09JWHVIbkd3RTVBWFVURmk0NkZUblJ3NGwvZHdFbTcvcFN4Y1luQ0YvZ0UzekluaDUyUlJKa1ZQNy9NbEtGUWNnQ2JqaWZIVEFRQmZzYjJxc2dCTzNlMUNwZjNVWEJlajNuUkpLS3J4VS9yY0gvcEt6ejR2TklRdVJKVEVtWmtsYmc2RUw0U1BzRTNHUVB6aW5tZmhiSkRHUW9sQityOHc1OGFiczV5OERxUnQ0QUJlcHRMUlI3a29ZOU5sZXliRVl3L01QaXN2Ri9heVQxL1N2RGV3Y25JY0czMndmaUNBYkV2b0NaeUdhR3NpdGR5ejZYZFRjdFFKcTZmY1Q1bWxvTmZZdnU1eUZaa3BFeitSVDBVckZvcXB4VkJWK3ZReElya2FQbnJicWR2WHM2aGNqYlUrSnE0TnZ2d2QvQkZSTmVxMm5wd1dma1g5NWl5RTlwNlBNNzJQL01oQ1BBTlRCU0t1NVdJVEhjQzA3NFk5Q1VUa1lnbEtCZ2NWL2FWdGxNNUtwcC9SSEZqRGRma2E3TVAvMndHNm03MjY2MVFOaWdqbEJYS1RHQnRzaldLTnM1YXRDZjQ0VWRzM3hjNVlEOFdrbmQyQnhXdUdqQ3pJeExXUXpsRmorSWpVMTA4T0w3YmFmTTVzbTVERGRma2EvOFQrOUFKWHlUTXBxRnNVRVlvSzVTWjBOYmpWbHZYNTAwUTRIYTJBK0p1Q2NFdmhWUzhxcC84TXpzcEhoTVNmTzdtVlBhUDM1Qk1ScDlKc0NRbGRiWCtobXZ4TmZuYW16SmZxVnZ0V25HWm9HeFFSaWdyb1lzNlViZnZPR0huNE9SVmtUYUliRVd3dHFnM01OTytacWwwSkdDZFZ1Q2F5aER1Rzl1SkI3dnArb1IxN0ZiWmMrTmF1Q2F1TFdMbUtrcVhyNk5zVUVZb0s2R3R4d1k2Q1hYbkVzMG4yZmFJSExDUGhoUjhiaWtGS3dSTit4WmRkSFd1NWE3T2w5eUNaMlp3SEtkT3h1ZkdOZUtScVMvaG1uTFdXMVZNbVFTcmw1b3lFa3FPUGJadTAySUpBc2ljOXNVN0IrNXVGOWNPbXFVZmVMT2RPYUFaWWIvQ0ErTS9JYzlOeFVvWU1OZkQvUFQ4NGY3eEI4MDdFQW5ycmJnTVVCWnQxdzFTRXBDSXFmakYxT201RXVRTnRoMGl1MXI4dFBMUDc2TENwWDJ5V3BIRGsyZEdIMDE4cDZicnRENWhPSGYwNGNSM29rT1RaMGxxUFZBVzNnVmRsTWhkcmZzVFc2ZHJSaERnUnJZSmNiZUtaUXhUa2VudmVnTnQ2WUJRd3JRdk94RytQM1pIRWlhOVR1Q2xTOUJyMVhLZ2U4WG54TGx4amVselovMnc0dGlqRE14eW9ISXNWUWcxenZZUGN5N0tlWng0akcyenlGYWtGSkY3V2h1MVhUMlF2aGZKZXJ5ZVZOZHBsWVBvNFBpOWhLZDdWVnhWQzhPNWNINCtONjVoWGdvS3VHZkVIbVdBc2tqR3hJNDlOdHU2WEhPQ0FEOWllMVBjTFNlcGpETlkwMGZCOG02S3BTeUp4L2pnZzlMZkpFZkxLNDA4MTh3K0xYWTVlNXpLYU1mS2wrRGNJbFNDWnAwY2QzVTU5aWdESTQrV09hMkx1bnZmdkRvRDlScmNOTHFBakR5M3l6ZnJ0S3FiQWtnZ1NESVptU2xZeHp6OWE4QmFKMTAxekYycmgzQnVTVEphQ0tHTURFR3VqSGJlZFhjaDBYMmViYmRFa2tEQzZhOWNRb1dWZ3VTNTNQMEpQNXhjSFkxVy90cHBEOUt4Z3JkQXc1UXhud1BuNG5PdWtyUGVxa3pCSmIwbTlvSmx0THR0M2EwN1FZRDFJa01BZVM3L2h3MEJYTWh6SndYSmMvZVY3a3VpeUlOOE9PR3VVaExQMDZKVWVveHo0RnhpWkxSb3VUc0RNOVdPMk9kQlJ0c0lncnpIdGsza2dIMDBKTytjVGlwYzJTOWpxeUNhbHVmMnh3Y25mdUI2TG5kSHVFc1N6ZFA0Ti9ndHpvRnpTWkhSSXNhUVFpUG1pZHlYZ3R0c25XMFlRWUR2c2gyUk9HQlB4a01xWGpOQS9xbENGc25aOFVkbFgra2ZrMHB5bWxuTVdIMkpPQmZ6MHNXSStDM09NUzFkelBwaGhQVldIT1BDNXdkTXpJVU96RkZIYjFsd0IyQVJGK1pPUHQwZ3NoV0JQTGUvd0NSWmx1NkNJa1NlaS9jRTBmRDRnMlpiVldjZXl4SDVXUHdHdnpYcnJTVEphRG5HN29Cb0dTM3FhQ1VMZ2dDUHN2MVc1SUFkOHR6TGxsSnd2cHgxV3RoTUlmeWc5T1ZvdEh5MVdWUTRWMzd3c2ZnTmZrdVNaTFFjVzhRNGxydVUvUlZiUnlrcmdnRFhpd3dOM3VRV25YVGExeE1rejJXL29uMmxuZE5hanBOdEFHZVB3Mi9NT2ljQk1scXMrOEs3R0JOYmpyRmdHZTJpWDBuVWdpQXZzKzBTMllwZ25kYUZQVlJjM1NkbVZhblpsZkdqaWZPaXc1UHJUL29HdlBwRy92RGtFSDRqWjcwVnQ4NnJsNXJZaW1tZFA0MS9zM1V6YzRJc3VwOVhOeHd2eiswdHlOQWxPTlBydE82aGN0UitRbmx1S3FOdDUyTzNweHZ0Q2xodnhUSDBlZ3RtRXdiQk1sclV4VTIxT0ZHdENIS1liYXZJQVR2M2o5MHoyNmtJZWE0UVpSdGFoZmhJdVQwYW5yakg3TzNycGpOVkh6UElhTEczTGg4VGo1VGJSUWloamxOeWVoeFR3VExhcmJaT2lpRUljQmZiUG5HaE10cm9DaFhXOUpOL1ZxZVlkeVBFWTRud3dQajZaQ0w4QzFUK1Q2MUpoRHFSdjhNeFpnd2xKRzJCeHpFc3JCbWdlRXpzZXF0OXRpNlNOSUlBOHQ2d205MDFlRkRaNjZkN000VWtRNTZMVmdUVHZ2dEthUnFGcW9UV3ltanhHYjZMcFV6ckltWWN1emFPSVdLSm1BcHRQV3BhQjJzZCtWK3l2U0Ixd0I2czdxWGd3aVV5QnBiSmRCcUZxNk1qVTE4bUtDS2hSc1R5RWJ4NTU4L3duUm1ZSnpMaVYrRFlCYXQ2SlEvTVg3QjFVQ3hCQUtIeTNJUXJINlc3TWhZOU1Xa1VNTkFOOTQ4LzhNbTM1L2pNRElLbHBDM2dtQldRdHNBamlma0U2MWIzNmtHUVA3RGRMN0tyVlpYblhpWXBqWUtaeGowOUdoN2Y0a0I0eUlhLzhabVUxYnJJSVlpWUlYYUozTmJqZmx2M3hCTUUrRFpiU1Z3SXpmSUlLODlkSmtTZWExOElodStYZmxEOXlQenRDSm5XNVJpNVZSbnRwTmg4Z2lWYjV5Z3ZCSUh1OXlhUnJjaFlSTzZmRlUwQ1NUUFFsREx0ZTZ6c2h4OU8zZzNEM3lKYWp5U2Q0RURhQXNRTXNSUGFldHhrNjF6dHkrWVRDWFJxamY5ak8xOWNPTG55WVYrcDhRZmZwY3JlTVhKN0JlUmdoNzdEczZTSVloR2JNQmdCMnRsZDFEVzBuR0w0VnhiWmZLQmJkVUhkaG9sMWRsN21PaTBNT2p0dEdnV1QxMWxBd1U5cjFtTVNzWDBveHdTeGdZeVdPdktYdGlBdkJQa1YyMzlJN0dxWmRWcVg5RkR3MlY1K1VvWWlwbjJudC9XUk1LM0xNUWxXOXBvWUNaN1dmY3JXc2R3U0JOZ2dNclJZZGNMZGhqYXMwK3EyOGx6Sk9jOGJPVTdqV0xoMkF3ekV5THhjbFltNloyWnVCRUUrWUx0VFpFVkE5dHpQZEJoNWJpSjNxNXJHRDh5UmpYYk5BUGtjbTBSdXlqVFVxZjNOUUJEZ2UyeUhKRmFHZUR5aTR0VUQ1SjNXSVhtenM4WTlORGdHM3VuODBPQ1lJRFpDSHhxSGJKMmlaaUVJR21uQjh0d2d6WUlrZDd2TXhpQk9ONTlHTEp5QlFMS01kaU0xcU9QWHlNbjJmMmY3WDVFRGRzaHprVWJoQXRFRDBvWk1YQ0FHaUlYZ3RBVy9ZWHVzVVJkcjlOc291ZkxjZ21QMjB6S3kyRXJyTlNOR1J1dW5NVUFzaEw3ekFCcTYxcS9SQlBrZDJ5TlNuNTcrWDNaVFFaQTh0N0gzSDVwN1J3d0V0NktQMkRyVXRBUUJJSVVzaXd0OTlLZit0eWRGbnR1b2NWaFZSbHROV3lCVFJsdW1Hc2xvcFJOa2hPMW1rUlZsTENUM2pIWXpxeVU0OFdTTisxWldSb3UwQlpEUnlwM0p1OW5XbmFZbkNIQTMyMTZKbFFXeTBnS3k1NTdkSlNhTlFuMG5LTkwxVnJobndUTGF2YmJPVUtzUUJCQXB6elZwRkhxc1BGZElHb1c2QWZlRzdjTXdyY3YzVEMwaW84MExRWjVtZTA3a1UzV2tZcVNsaFl2a3BGR296OEM4Yk83UnlHamxwaTE0enRhVmxpTUlJRk9laXpRS2JwSStXZHNER2ZMY1d2Y21zYUs1M2I0Z2RVVzNsRU5aWGp4cmdyek5kcS9JQWZ0b2hienpPcWw0ZVYvempVVWN1OTZLN3czM0tGaEdpN3J4VmlzVEJFQlN4V1BpaXFZcXo3MW1HZm1EUXVTNXRTSUhzdEh5UFpuZDcrWEthSStSZ0tTeEVnZ3lTV21LYVhrVmFTd2k1eFNiUm1HaVNkWnB4VlpHeS9lRWV4TXNvNzNSMW8yV0p3aXdrKzExa1FOWnJOTzZvbytDYzd2ejM5V3kwN3E0bCtDS2ZuTnZRdS9uZFZzblNBa2lmY0NPQVhxN1I4VzF5OUpkUnZJODdRdmZuVFJ0Z2RQZXVqTGF2QkxrdjltZUVQblVIUzJUZjFFUEZUNjdsT0tSbkU3N211bnJzcmtILytJZXlkUFhxQU8vVm9MTURNaHo1VDJpclR6WHBGSG9LZVJQbmx1VjBYWVgwbWxkdVRMYW1JUkp0S1VSNUNEYmJTSXJHUGZYL2VVZFZGeVRRM2x1a3U2T2FOSVcvSG1INUxRRnQ5azZvQVE1QWI3UE5peXhrbUduZFVoUnZUTnlKTTlGMXdyWmFNOUlaYlFtRzYzTW9jZXd4SWVqUklLZytEYUtiRVhHSTNLV0J0VDJoVUZLeW9uVVplRWZCM3hrWDR2c00zd1h2SXgvSXdtTXFDdTBXSC9COXFMSXB6RzZXcC9ycFdCRmoveDFXbmFDQWI0RzdMUGdhZDBYYlptVEVtVHVrRG50aTB5emdadktjd05QdER6WHlHalpSNU9ORmluY1ZFYmJWQVI1amUwaGtVL2xrVEw1RjNUWnpRMkV2anlzSnIxaEgvMEx1aVZQVHo5a3kxb0pzZ0I4aXdRc041aHBsSVNuczVIbjloWGw5ZXVyTWxyMnpVenJWc1F1azVtMFpVeEtrSVhoS05zV2tRTjJ5SE5QaHp4M1dicVFNUlpHWUNPalhXWjhGRHpqdHNXV3NSSmtFZmdoMnp2eU92aFdub3ZzdWN1NzVHVFB0ZGxvNFJOOGkrVytzM25IbGkwcFFSYVBJWEVlVmVXNTNWNDZZSmNpejJVZjRJdnhpWDBqdVcvOWgvSlE4ZkpDa0dmWm5wRTVZSzlRc0hJSkJaY0lrT2RXMTQxZDNHdDhFaXlqZmNhV3FSS2s2Wjg0a09jNmR1T0RqbXpsdVVaR3l6NGc2UTE4VWhsdGF4SGtYYmJ0SWdmc1J5dmtuUXQ1Ym9iWmM2ZGx0UDNHbDBTdWRtVzdMVXNsU0oxbVBVYkZlV1ZVZXBEbkRwQjNTZ2F6UnRXMEJYeHQrQUJmaEU3cnlweVZiQ0tDVExGOVUyUXJnalFLZzNiN3pza0d2M2VJMCtYc3VEWjhFSnkyWUpNdFF5VklIZkV6dGxkRkR0Z2h6NzI4ajRMekdwaEdvWnEyZ0s5Wk1EdXdpSDNuZ1RKN09HK1ZMWThFQWVUS2M5dHM5bHdrNDJ6RU9pMnN0K0pyWVpJQTF4WXNvMTJYeDRxV1Y0Szh4UFp6a2EzSVNDclBEVlkxWUoxV3RmVllaV1cwY3RkYlBXN0xUQW5TUUh5REpDb3lrRVloVE5kcHVVc0s2WURacVE4NWNHNWN3NnkzQ3NXbUxZQlhHL05heWZKTWtJOG9WUi9LRzdBZkM4azd1NE1LVncya00xcjFlQjJScEROWHVBYXVKVmhHZTZzdEt5VklCcmlkN1lBNHI2bzVONUJHNGN4T0kzbXRhZVd0eW1qNTNMaUc0RndtS0pzNzhsekI4azRRVklzTjRyeXF5bk43QXpQMVNoWEljMnRZZzNHdVNwSk82L2FLbHRISzNLV21oUWdDUE1tMlIrU0FmVFNrQU5selY5UncycmM2TURjeVd0SFphUGZZc2lFbFNQYVFPWVZZaVNueGlJcHJCOGtwZUduK3Y4VTJtWkQ4Rmp4elRweWJLanF0cXdRNU9kNWcyeUd5cTRYc3VlZDNVZUhTdnNXM0lsVVpMWjhMNXhTY3RtQ0hMUk1saUNCZ04vQUpjVjdGNlNwYmpCZThnVVdrVWFpbUxlQnptT1VzVTJKbHRPTWtjYmQrSlFpTmtZQjhFck5WYlBlME5tcTcyaTRrWE1pd05VbmZlK0FjT0pmZ2ZDV2JiVmtvUVFUaVIyeHZpdlBLeW5PRE5YMFVMRjlBR29WcTJnTCtMYzRoV0VhTDJOL1hUQldxMlFnaWMzQllsZWQyK2VrZVZmT1Y1MWF6MFdLTkY1OURzSXgyWGJOVnBtWWt5UE5zdXlXU0JCSllmK1VTS3N4SG5sdk5Sc3UvOFdYTGFIZmIyQ3RCY29EMUlyMkNQSmYvd3hTdDJ4bWt1cEdUOWM2UXRvQ1BOZE82NkZmSmxkR3ViOGFLMUt3RWVZOXRtOGdCKzJoSTNqbWRWTGlpLytSYkJka3RmSEFzZnBQSWZTbTR6Y1pjQ1pJamZKZnRpTVFCTzFJUVFCcnJuM3FDUllaMjBTT09NVExhY2JIcnJSRGpXNXExRWpVelFiaVRUemVJYkVVZ3orMjMyWE5uZTU5UmZYK0NiTFQ5b21XMGlIRkZDWkpQUE1yMlc1RURkc2h6TDF0S3dma3pyTk9xcnJmaTczQ01ZQm50S3piR3BBVEpMNjRYNlJYV1pSVnR4bG5QK1ZnYUJaTzJ3RXUvd3pHYXRrQUpVays4ekxaTFpDdUNkVm9YY2l1eCtyaFZ1WFlWTUQ3RGQ3SGM5VmE3Ykd5VklFMEFtZjNrYVhudUlIbTlxVHdYaHIveG1XQVpiVVhrK0U0SnNtQWNadHNxY3NBT2VlNlo3VlMwOGx3WS9zWm5nbVcwVzIxTWxTQk5oTHZZOW9uekNxdEl4aXBVdUtxZjNMNmlNZnlOejRSTzYrNnpzV3dKK05SYXdOdmVwOFMxSWhNeHVjaWUrOFZUMG8rNlBJcVBpQjE3ckcrbEN0TnFCUGtsMnd0czE0Z2JzQ09Od3FWTHpUOEZyN2Q2d2Nhd1plQlM2MEhtMUdTU1R1K2E2ZDVFWTZjRXlRNS9ZTHRmNG9DZDRpUTFtYTNIL1RaMlNwQVd3TGZaU3FTWUswbzJacVFFYVExQU4zMlQxdnM1NHlZYk15VklDK0dCVnV3eUxMQkwra0NyM3J6YjRvVi92ZFovalpFU1pIYjhpcVM5RjVHRnAyeU1sQ0F0akNFTmdjWkdDVEk3OXJQZHFXSDRGTzYwc1ZHQ0tPaDdiSWMwRE5NNFpHTkNTaEFGRUZLT3N5RFZBUnR0VEpRZ0dvSnBQTWIyR3cyRGljRmpHZ1lseUV4WXB5SFFHQ2hCWnNmdjJCNXA0ZnQveE1aQW9RU1pGWnNvM1RLbzFWQzI5NjVRZ3B3UUkydzN0K0I5MzJ6dlhhRUVPU251WnR2YlF2ZTcxOTZ6UWdreVo2elhlMVVvUVdiSDAyelB0Y0I5UG1mdlZhRUVtVGVHOUI2VklJclo4UmJidlUxOGYvZmFlMVFvUVJZTUpLVTgxb1QzZFl3a0pqMVZndVFPazlSRWFZMlB3NDMyM2hSS2tFVmpKOXZyVFhRL3I5dDdVaWhCYW9icjlWNlVJSXJaOFd1Mko1cmdQcDZ3OTZKUWd0UWNHMmptaEdsNVFXenZRYUVFcVFzT3N0MldZLzl2cy9lZ1VJTFV0WklONTlEdjRaeVRXd21TRXlEblV4N2x1UnRKYXI0cUpValQ0UmRzTCtiSTN4ZXR6d29sU01Pd1RuMVZnaWhteDJ0c0QrWEF6NGVzcndvbFNNUHhMWks5WEdQUytxaFFnbVNDbzJ4YkJQdTN4ZnFvVUlKa2hoK3l2U1BRcjNlc2J3b2xTT1lZVXArVUlJclo4U3piTTRMOGVjYjZwRkNDNkJOYld3OGxTQjd3THR0MkFYNXN0NzRvbENEaWtQV3NrZlJaTlNWSWkyT0tzdDIrYzVQMVFhRUVFWXVIMlY3TjRMcXYybXNybENEaXNhNUZycWtFVVN3SUw3RTkzc0RyUFc2dnFWQ0M1QWFOMGwva1ZaK2lCR2x4Zk1SMmF3T3VjNnU5bGtJSmtqdmN3WGFnanVjL1lLK2hVSUxrRWduVmR4ZVJEZllhQ2lWSWJ2RWsyNTQ2bkhlUFBiZENDWko3ck12Sk9SVktrRXp3QnR1T0dwNXZoejJuUWduU05NQnU2dU0xT004NE5lZHU4MHFRRnNjWTFTWWZ4Mlo3TG9VU3BPbHdIOXViaS9qOW0vWWNDaVdJRHRoMVlLNEVhVVU4ejdaN0FiL2JiWCtyVUlJMFBkWTM2RGNLSlVndThSN2J0bmtjdjgzK1JxRUVhUm5jd25aa0RzY2RzY2NxbENBdGhRcmJEWE00N2daN3JFSUowbko0bE8yVkUzei9pajFHb1FScFdheGI0SGNLSlVoTDRHVzJYVE44dnN0K3AxQ0N0RHcrT2M2WTYvaEVvUVJwQ1J4bTIzcmN2N2ZhenhSS0VJWEZYWlJ1d0JEWnZ4VUM0R3NJUkVIZmxndURreVFxYVZZb3RJdWxVQ2hCRkFvbGlFS2hCRkVvbENBS2hSSkVvVkNDS0JSS0VJVkNDYUpRS0pRZ0NvVVNSS0ZRZ2lnVVNoQ0ZJaFA4dndBREFDb2c1WU02NXp1Z0FBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9hc3NldHMvbG9nby5wbmdcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzQ5OWM4ODFcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzdHlsdXMtbG9hZGVyIS4vZ2xvYmFsLnN0eWxcIilcbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTM0OTljODgxXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzdHlsdXMtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0xIS4vQXBwLnZ1ZVwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vQXBwLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzQ5OWM4ODFcXFwiLFxcXCJoYXNTY29wZWRcXFwiOnRydWUsXFxcInByZXNlcnZlV2hpdGVzcGFjZVxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRhcmdldFxcXCI6e1xcXCJjaHJvbWVcXFwiOjUyLFxcXCJmaXJlZm94XFxcIjo0OH0sXFxcIm9iamVjdEFzc2lnblxcXCI6XFxcIk9iamVjdC5hc3NpZ25cXFwifX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0FwcC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi0zNDk5Yzg4MVwiLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJHOlxcXFxsdW9iYXRhXFxcXGxpYlxcXFxtYXRjaC1kZXZ0b29sc1xcXFxzcmNcXFxcQXBwLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gQXBwLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0zNDk5Yzg4MVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTM0OTljODgxXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL0FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFidWJsZS1sb2FkZXI/e1xcXCJ0YXJnZXRcXFwiOntcXFwiY2hyb21lXFxcIjo1MixcXFwiZmlyZWZveFxcXCI6NDh9LFxcXCJvYmplY3RBc3NpZ25cXFwiOlxcXCJPYmplY3QuYXNzaWduXFxcIn0hLi9tYXRjaENvbnRlbnQuanNcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTgyZDI2NmI0XFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwicHJlc2VydmVXaGl0ZXNwYWNlXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9fSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vbWF0Y2hDb250ZW50LnZ1ZVwiKSxcbiAgLyogc3R5bGVzICovXG4gIG51bGwsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRzpcXFxcbHVvYmF0YVxcXFxsaWJcXFxcbWF0Y2gtZGV2dG9vbHNcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcbWF0Y2hDb250ZW50XFxcXG1hdGNoQ29udGVudC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIG1hdGNoQ29udGVudC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtODJkMjY2YjRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi04MmQyNjZiNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL21hdGNoQ29udGVudC9tYXRjaENvbnRlbnQudnVlXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWVjYWFmNWE4XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzdHlsdXMtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vZGF0YUZpZWxkLnZ1ZVwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vZGF0YUZpZWxkLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZWNhYWY1YThcXFwiLFxcXCJoYXNTY29wZWRcXFwiOnRydWUsXFxcInByZXNlcnZlV2hpdGVzcGFjZVxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRhcmdldFxcXCI6e1xcXCJjaHJvbWVcXFwiOjUyLFxcXCJmaXJlZm94XFxcIjo0OH0sXFxcIm9iamVjdEFzc2lnblxcXCI6XFxcIk9iamVjdC5hc3NpZ25cXFwifX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2RhdGFGaWVsZC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi1lY2FhZjVhOFwiLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJHOlxcXFxsdW9iYXRhXFxcXGxpYlxcXFxtYXRjaC1kZXZ0b29sc1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxtYXRjaE9ialxcXFxkYXRhRmllbGQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBkYXRhRmllbGQudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWVjYWFmNWE4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtZWNhYWY1YThcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zcmMvY29tcG9uZW50cy9tYXRjaE9iai9kYXRhRmllbGQudnVlXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWUxY2NhMjM0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc3R5bHVzLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL21hdGNoT2JqLnZ1ZVwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYnVibGUtbG9hZGVyP3tcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9IS4vbWF0Y2hPYmouanNcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWUxY2NhMjM0XFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwicHJlc2VydmVXaGl0ZXNwYWNlXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidGFyZ2V0XFxcIjp7XFxcImNocm9tZVxcXCI6NTIsXFxcImZpcmVmb3hcXFwiOjQ4fSxcXFwib2JqZWN0QXNzaWduXFxcIjpcXFwiT2JqZWN0LmFzc2lnblxcXCJ9fSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vbWF0Y2hPYmoudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRzpcXFxcbHVvYmF0YVxcXFxsaWJcXFxcbWF0Y2gtZGV2dG9vbHNcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcbWF0Y2hPYmpcXFxcbWF0Y2hPYmoudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBtYXRjaE9iai52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZTFjY2EyMzRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1lMWNjYTIzNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL21hdGNoT2JqL21hdGNoT2JqLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1mYTM2YjQ0ZVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc3R5bHVzLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2FjdGlvblRhYi52dWVcIilcbn1cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIG51bGwsXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWZhMzZiNDRlXFxcIixcXFwiaGFzU2NvcGVkXFxcIjp0cnVlLFxcXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0YXJnZXRcXFwiOntcXFwiY2hyb21lXFxcIjo1MixcXFwiZmlyZWZveFxcXCI6NDh9LFxcXCJvYmplY3RBc3NpZ25cXFwiOlxcXCJPYmplY3QuYXNzaWduXFxcIn19IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9hY3Rpb25UYWIudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgXCJkYXRhLXYtZmEzNmI0NGVcIixcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRzpcXFxcbHVvYmF0YVxcXFxsaWJcXFxcbWF0Y2gtZGV2dG9vbHNcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcbWF0Y2hUYWJcXFxcYWN0aW9uVGFiLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gYWN0aW9uVGFiLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1mYTM2YjQ0ZVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWZhMzZiNDRlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hUYWIvYWN0aW9uVGFiLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zZDBiMWMyY1xcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc3R5bHVzLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NwbGl0UGFuZS52dWVcIilcbn1cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJ1YmxlLWxvYWRlcj97XFxcInRhcmdldFxcXCI6e1xcXCJjaHJvbWVcXFwiOjUyLFxcXCJmaXJlZm94XFxcIjo0OH0sXFxcIm9iamVjdEFzc2lnblxcXCI6XFxcIk9iamVjdC5hc3NpZ25cXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3NwbGl0UGFuZS52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTNkMGIxYzJjXFxcIixcXFwiaGFzU2NvcGVkXFxcIjp0cnVlLFxcXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0YXJnZXRcXFwiOntcXFwiY2hyb21lXFxcIjo1MixcXFwiZmlyZWZveFxcXCI6NDh9LFxcXCJvYmplY3RBc3NpZ25cXFwiOlxcXCJPYmplY3QuYXNzaWduXFxcIn19IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcGxpdFBhbmUudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgXCJkYXRhLXYtM2QwYjFjMmNcIixcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRzpcXFxcbHVvYmF0YVxcXFxsaWJcXFxcbWF0Y2gtZGV2dG9vbHNcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcc3BsaXRQYW5lXFxcXHNwbGl0UGFuZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHNwbGl0UGFuZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtM2QwYjFjMmNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0zZDBiMWMyY1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NyYy9jb21wb25lbnRzL3NwbGl0UGFuZS9zcGxpdFBhbmUudnVlXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBjbGFzczoge1xuICAgICAgYXBwOiB0cnVlLCBkYXJrOiBfdm0uaXNEYXJrXG4gICAgfSxcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcImFwcFwiXG4gICAgfVxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJoZWFkZXJcIlxuICB9LCBbX2MoJ2ltZycsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsb2dvXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwic3JjXCI6IHJlcXVpcmUoXCIuL2Fzc2V0cy9sb2dvLnBuZ1wiKSxcbiAgICAgIFwiYWx0XCI6IFwiVnVlXCJcbiAgICB9XG4gIH0pLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtZXNzYWdlLWNvbnRhaW5lclwiXG4gIH0sIFtfYygndHJhbnNpdGlvbicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJuYW1lXCI6IFwic2xpZGUtdXBcIlxuICAgIH1cbiAgfSwgW19jKCdzcGFuJywge1xuICAgIGtleTogX3ZtLm1lc3NhZ2UsXG4gICAgc3RhdGljQ2xhc3M6IFwibWVzc2FnZVwiXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5tZXNzYWdlKSldKV0pXSwgMSksIF9jKCdhJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvbiBjb21wb25lbnRzXCIsXG4gICAgY2xhc3M6IHtcbiAgICAgIGFjdGl2ZTogX3ZtLnRhYiA9PT0gJ21hdGNoJ1xuICAgIH0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidGl0bGVcIjogXCJTd2l0Y2ggdG8gQ29tcG9uZW50c1wiXG4gICAgfVxuICB9LCBbX2MoJ2knLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibWF0ZXJpYWwtaWNvbnNcIlxuICB9LCBbX3ZtLl92KFwiZGV2aWNlX2h1YlwiKV0pLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJwYW5lLW5hbWVcIlxuICB9LCBbX3ZtLl92KFwiQ29tcG9uZW50c1wiKV0pXSksIF9jKCdhJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvbiByZWZyZXNoXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidGl0bGVcIjogXCJGb3JjZSBSZWZyZXNoXCJcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5yZWZyZXNoXG4gICAgfVxuICB9LCBbX2MoJ2knLCB7XG4gICAgcmVmOiBcInJlZnJlc2hcIixcbiAgICBzdGF0aWNDbGFzczogXCJtYXRlcmlhbC1pY29uc1wiXG4gIH0sIFtfdm0uX3YoXCJyZWZyZXNoXCIpXSksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInBhbmUtbmFtZVwiXG4gIH0sIFtfdm0uX3YoXCJSZWZyZXNoXCIpXSldKSwgX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYWN0aXZlLWJhclwiXG4gIH0pXSksIF9jKCdtYXRjaCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250YWluZXJcIlxuICB9KV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTM0OTljODgxXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTM0OTljODgxXCIsXCJoYXNTY29wZWRcIjp0cnVlLFwicHJlc2VydmVXaGl0ZXNwYWNlXCI6ZmFsc2UsXCJidWJsZVwiOntcInRhcmdldFwiOntcImNocm9tZVwiOjUyLFwiZmlyZWZveFwiOjQ4fSxcIm9iamVjdEFzc2lnblwiOlwiT2JqZWN0LmFzc2lnblwifX0hLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vc3JjL0FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInNwbGl0LXBhbmVcIixcbiAgICBjbGFzczoge1xuICAgICAgZHJhZ2dpbmc6IF92bS5kcmFnZ2luZ1xuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwibW91c2Vtb3ZlXCI6IF92bS5kcmFnTW92ZSxcbiAgICAgIFwibW91c2V1cFwiOiBfdm0uZHJhZ0VuZCxcbiAgICAgIFwibW91c2VsZWF2ZVwiOiBfdm0uZHJhZ0VuZFxuICAgIH1cbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibGVmdFwiLFxuICAgIHN0eWxlOiAoe1xuICAgICAgd2lkdGg6IF92bS5zcGxpdCArICclJ1xuICAgIH0pXG4gIH0sIFtfdm0uX3QoXCJsZWZ0XCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImRyYWdnZXJcIixcbiAgICBvbjoge1xuICAgICAgXCJtb3VzZWRvd25cIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdm0uZHJhZ1N0YXJ0KCRldmVudClcbiAgICAgIH1cbiAgICB9XG4gIH0pXSwgMiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwicmlnaHRcIixcbiAgICBzdHlsZTogKHtcbiAgICAgIHdpZHRoOiAoMTAwIC0gX3ZtLnNwbGl0KSArICclJ1xuICAgIH0pXG4gIH0sIFtfdm0uX3QoXCJyaWdodFwiKV0sIDIpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtM2QwYjFjMmNcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtM2QwYjFjMmNcIixcImhhc1Njb3BlZFwiOnRydWUsXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIjpmYWxzZSxcImJ1YmxlXCI6e1widGFyZ2V0XCI6e1wiY2hyb21lXCI6NTIsXCJmaXJlZm94XCI6NDh9LFwib2JqZWN0QXNzaWduXCI6XCJPYmplY3QuYXNzaWduXCJ9fSEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9zcGxpdFBhbmUvc3BsaXRQYW5lLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCBbX2MoJ3NwbGl0LXBhbmUnLCBbX2MoJ2NvbXBvbmVudC10cmVlJywge1xuICAgIHNsb3Q6IFwibGVmdFwiXG4gIH0pLCBfYygnbWF0Y2gtb2JqJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInN0YWNrc1wiOiBfdm0ubWF0Y2hBcnJcbiAgICB9LFxuICAgIHNsb3Q6IFwicmlnaHRcIlxuICB9KV0sIDEpXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtODJkMjY2YjRcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtODJkMjY2YjRcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwicHJlc2VydmVXaGl0ZXNwYWNlXCI6ZmFsc2UsXCJidWJsZVwiOntcInRhcmdldFwiOntcImNocm9tZVwiOjUyLFwiZmlyZWZveFwiOjQ4fSxcIm9iamVjdEFzc2lnblwiOlwiT2JqZWN0LmFzc2lnblwifX0hLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hDb250ZW50L21hdGNoQ29udGVudC52dWVcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1hdGNoXCJcbiAgfSwgW19jKCdhY3Rpb24taGVhZGVyJywge1xuICAgIHNsb3Q6IFwiaGVhZGVyXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwic2VhcmNoXCJcbiAgfSwgW19jKCdpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1hdGVyaWFsLWljb25zXCJcbiAgfSwgW192bS5fdihcInNlYXJjaFwiKV0pLCBfYygnaW5wdXQnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwicGxhY2Vob2xkZXJcIjogXCJGaWx0ZXIgY29tcG9uZW50c1wiXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJpbnB1dFwiOiBfdm0uZmlsdGVyU3RhY2tzXG4gICAgfVxuICB9KV0pXSldLCAxKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi1kNmZhM2ViNFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1kNmZhM2ViNFwiLFwiaGFzU2NvcGVkXCI6dHJ1ZSxcInByZXNlcnZlV2hpdGVzcGFjZVwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0YXJnZXRcIjp7XCJjaHJvbWVcIjo1MixcImZpcmVmb3hcIjo0OH0sXCJvYmplY3RBc3NpZ25cIjpcIk9iamVjdC5hc3NpZ25cIn19IS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL21hdGNoVGFiL21hdGNoVGFiLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZGF0YS13cmFwZXJcIlxuICB9LCBfdm0uX2woKF92bS5zdGFja3MpLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJkYXRhLWZpZWxkc1wiXG4gICAgfSwgW19jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJkYXRhLXR5cGVcIlxuICAgIH0sIFtfdm0uX3YoXCJiZWZvcmVQYXJhbXNcIildKSwgKEFycmF5LmlzQXJyYXkoaXRlbS5iZWZvcmVQYXJhbXMpKSA/IF92bS5fbCgoaXRlbS5iZWZvcmVQYXJhbXMpLCBmdW5jdGlvbihmaWVsZCkge1xuICAgICAgcmV0dXJuIF9jKCdkYXRhLWZpZWxkJywge1xuICAgICAgICBrZXk6IGZpZWxkLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIFwiZmllbGRcIjogZmllbGQsXG4gICAgICAgICAgXCJkZXB0aFwiOiAwXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSkgOiBfdm0uX2woKGl0ZW0uYmVmb3JlUGFyYW1zKSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmV0dXJuIF9jKCdkYXRhLWZpZWxkJywge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBcImZpZWxkXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRlcHRoXCI6IDBcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KSwgX2MoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImRhdGEtdHlwZVwiXG4gICAgfSwgW192bS5fdihcImFmdGVyUGFyYW1zXCIpXSksIChBcnJheS5pc0FycmF5KGl0ZW0uYWZ0ZXJQYXJhbXMpKSA/IF92bS5fbCgoaXRlbS5hZnRlclBhcmFtcyksIGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICByZXR1cm4gX2MoJ2RhdGEtZmllbGQnLCB7XG4gICAgICAgIGtleTogZmllbGQsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgXCJmaWVsZFwiOiBmaWVsZCxcbiAgICAgICAgICBcImRlcHRoXCI6IDBcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KSA6IF92bS5fbCgoaXRlbS5hZnRlclBhcmFtcyksIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJldHVybiBfYygnZGF0YS1maWVsZCcsIHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgXCJmaWVsZFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZXB0aFwiOiAwXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSldLCAyKVxuICB9KSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtZTFjY2EyMzRcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZTFjY2EyMzRcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwicHJlc2VydmVXaGl0ZXNwYWNlXCI6ZmFsc2UsXCJidWJsZVwiOntcInRhcmdldFwiOntcImNocm9tZVwiOjUyLFwiZmlyZWZveFwiOjQ4fSxcIm9iamVjdEFzc2lnblwiOlwiT2JqZWN0LmFzc2lnblwifX0hLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovbWF0Y2hPYmoudnVlXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJkYXRhLWZpZWxkXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwic2VsZlwiLFxuICAgIHN0eWxlOiAoe1xuICAgICAgbWFyZ2luTGVmdDogX3ZtLmRlcHRoICogMTQgKyAncHgnXG4gICAgfSksXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLnRvZ2dsZVxuICAgIH1cbiAgfSwgW19jKCdzcGFuJywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICB2YWx1ZTogKF92bS5pc0V4cGFuZGFibGVUeXBlKSxcbiAgICAgIGV4cHJlc3Npb246IFwiaXNFeHBhbmRhYmxlVHlwZVwiXG4gICAgfV0sXG4gICAgc3RhdGljQ2xhc3M6IFwiYXJyb3cgcmlnaHRcIixcbiAgICBjbGFzczoge1xuICAgICAgcm90YXRlZDogX3ZtLmV4cGFuZGVkXG4gICAgfVxuICB9KSwgX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwia2V5XCJcbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLmZpZWxkLmtleSkpXSksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbG9uXCJcbiAgfSwgW192bS5fdihcIjpcIiksIChfdm0uZmllbGQubWV0YSkgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1ldGFcIlxuICB9LCBfdm0uX2woKF92bS5maWVsZC5tZXRhKSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcIm1ldGEtZmllbGRcIlxuICAgIH0sIFtfYygnc3BhbicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImtleVwiXG4gICAgfSwgW192bS5fdihfdm0uX3Moa2V5KSldKSwgX2MoJ3NwYW4nLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJ2YWx1ZVwiXG4gICAgfSwgW192bS5fdihfdm0uX3ModmFsKSldKV0pXG4gIH0pKSA6IF92bS5fZSgpXSksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInZhbHVlXCIsXG4gICAgY2xhc3M6IF92bS52YWx1ZVR5cGVcbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLmZvcm1hdHRlZFZhbHVlKSldKV0pLCAoX3ZtLmV4cGFuZGVkICYmIF92bS5pc0V4cGFuZGFibGVUeXBlKSA/IF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY2hpbGRyZW5cIlxuICB9LCBbX3ZtLl9sKChfdm0ubGltaXRlZFN1YkZpZWxkcyksIGZ1bmN0aW9uKHN1YkZpZWxkKSB7XG4gICAgcmV0dXJuIF9jKCdkYXRhLWZpZWxkJywge1xuICAgICAga2V5OiBzdWJGaWVsZC5rZXksXG4gICAgICBhdHRyczoge1xuICAgICAgICBcImZpZWxkXCI6IHN1YkZpZWxkLFxuICAgICAgICBcImRlcHRoXCI6IF92bS5kZXB0aCArIDFcbiAgICAgIH1cbiAgICB9KVxuICB9KSwgKF92bS5mb3JtYXR0ZWRTdWJGaWVsZHMubGVuZ3RoID4gX3ZtLmxpbWl0KSA/IF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vcmVcIixcbiAgICBzdHlsZTogKHtcbiAgICAgIG1hcmdpbkxlZnQ6IChfdm0uZGVwdGggKyAxKSAqIDE0ICsgMTAgKyAncHgnXG4gICAgfSksXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5saW1pdCArPSAxMFxuICAgICAgfVxuICAgIH1cbiAgfSwgW192bS5fdihcIlxcbiAgICAgIC4uLlxcbiAgICBcIildKSA6IF92bS5fZSgpXSwgMikgOiBfdm0uX2UoKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LWVjYWFmNWE4XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWVjYWFmNWE4XCIsXCJoYXNTY29wZWRcIjp0cnVlLFwicHJlc2VydmVXaGl0ZXNwYWNlXCI6ZmFsc2UsXCJidWJsZVwiOntcInRhcmdldFwiOntcImNocm9tZVwiOjUyLFwiZmlyZWZveFwiOjQ4fSxcIm9iamVjdEFzc2lnblwiOlwiT2JqZWN0LmFzc2lnblwifX0hLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovZGF0YUZpZWxkLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYWN0aW9uLWhlYWRlclwiXG4gIH0sIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwgMilcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtZmEzNmI0NGVcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZmEzNmI0NGVcIixcImhhc1Njb3BlZFwiOnRydWUsXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIjpmYWxzZSxcImJ1YmxlXCI6e1widGFyZ2V0XCI6e1wiY2hyb21lXCI6NTIsXCJmaXJlZm94XCI6NDh9LFwib2JqZWN0QXNzaWduXCI6XCJPYmplY3QuYXNzaWduXCJ9fSEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9tYXRjaFRhYi9hY3Rpb25UYWIudnVlXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzQ5OWM4ODFcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuL2dsb2JhbC5zdHlsXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCJkYmFjNjE2OFwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zNDk5Yzg4MVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4vZ2xvYmFsLnN0eWxcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzQ5OWM4ODFcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuL2dsb2JhbC5zdHlsXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTM0OTljODgxXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3N0eWx1cy1sb2FkZXIhLi4vc3JjL2dsb2JhbC5zdHlsXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzQ5OWM4ODFcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xIS4vQXBwLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiNTE5ZWYxMzFcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzQ5OWM4ODFcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xIS4vQXBwLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zNDk5Yzg4MVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTEhLi9BcHAudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTM0OTljODgxXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc3R5bHVzLWxvYWRlciEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTEhLi4vc3JjL0FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zZDBiMWMyY1xcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcGxpdFBhbmUudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIzZGVhYmNiMFwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zZDBiMWMyY1xcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcGxpdFBhbmUudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNkMGIxYzJjXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NwbGl0UGFuZS52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlciEuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtM2QwYjFjMmNcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi4vfi9zdHlsdXMtbG9hZGVyIS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9zcmMvY29tcG9uZW50cy9zcGxpdFBhbmUvc3BsaXRQYW5lLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWQ2ZmEzZWI0XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuL21hdGNoLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiNTlhMjJmMGJcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZDZmYTNlYjRcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4vbWF0Y2guY3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWQ2ZmEzZWI0XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuL21hdGNoLmNzc1wiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1kNmZhM2ViNFwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9zcmMvY29tcG9uZW50cy9tYXRjaFRhYi9tYXRjaC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lMWNjYTIzNFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbWF0Y2hPYmoudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIwZTk4ZGUwMVwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lMWNjYTIzNFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbWF0Y2hPYmoudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWUxY2NhMjM0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9tYXRjaE9iai52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlciEuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtZTFjY2EyMzRcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc3R5bHVzLWxvYWRlciEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovbWF0Y2hPYmoudnVlXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZWNhYWY1YThcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vZGF0YUZpZWxkLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiMzAwNDlmNTBcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZWNhYWY1YThcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vZGF0YUZpZWxkLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lY2FhZjVhOFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9kYXRhRmllbGQudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LWVjYWFmNWE4XCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4uL34vc3R5bHVzLWxvYWRlciEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vc3JjL2NvbXBvbmVudHMvbWF0Y2hPYmovZGF0YUZpZWxkLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWZhMzZiNDRlXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2FjdGlvblRhYi52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjA0NWNiMzc0XCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWZhMzZiNDRlXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2FjdGlvblRhYi52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZmEzNmI0NGVcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vYWN0aW9uVGFiLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1mYTM2YjQ0ZVwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuLi9+L3N0eWx1cy1sb2FkZXIhLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL3NyYy9jb21wb25lbnRzL21hdGNoVGFiL2FjdGlvblRhYi52dWVcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbGlzdCBmb3JtYXQgcHJvZHVjZWQgYnkgY3NzLWxvYWRlciBpbnRvIHNvbWV0aGluZ1xuICogZWFzaWVyIHRvIG1hbmlwdWxhdGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi40LjJcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3QsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cblxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobnVsbCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmaXggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAqL1xudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuLmNhbGwodGhpcywgcGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMpIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSBpbmplY3RbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyArXG4gICAgICAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpICtcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgXCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuICAgICAgXCJwcm9wZXJ0aWVzIGluIHRoZSBkYXRhIG9wdGlvbi5cIixcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICAobGFzdCkudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChjb21wLl9fZXNNb2R1bGUgJiYgY29tcC5kZWZhdWx0KSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgY2hpbGQuZGF0YSAmJiBjaGlsZC5kYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBjaGlsZC5kYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICAgIC8vIG5vIG5lZWQgZm9yIHRoZSByZWYgbm9kZXMgYWZ0ZXIgaW5pdGlhbCBwYXRjaFxuICAgICAgLy8gdGhpcyBwcmV2ZW50cyBrZWVwaW5nIGEgZGV0YWNoZWQgRE9NIHRyZWUgaW4gbWVtb3J5ICgjNTg1MSlcbiAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICB2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuc2VycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhICYmIHBhcmVudFZub2RlLmRhdGEuYXR0cnM7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3B0aW9uVHlwZSAodm0sIG5hbWUpIHtcbiAgdmFyIG9wdGlvbiA9IHZtLiRvcHRpb25zW25hbWVdO1xuICBpZiAoIWlzUGxhaW5PYmplY3Qob3B0aW9uKSkge1xuICAgIHdhcm4oXG4gICAgICAoXCJjb21wb25lbnQgb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgc2hvdWxkIGJlIGFuIG9iamVjdC5cIiksXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KSB8fCBjb25maWcuaXNSZXNlcnZlZEF0dHIoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ2NvbXB1dGVkJyk7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIgfHwgbm9vcCwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAodGFyZ2V0LCBrZXksIHVzZXJEZWYpIHtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSk7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnbWV0aG9kcycpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ3dhdGNoJyk7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAga2V5T3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goa2V5T3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc291cmNlKSB7XG4gICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IHt9LFxuICAgIGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlQ29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIGlzVW5kZWYoY2hpbGQubnMpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2RlcyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQob3VycywgZXhpc3RpbmcpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycywgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycywgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzLCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzLCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSB0b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgVnVlLnByb3RvdHlwZS5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtaW5pdDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGN1cnJlbnQsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBpZiAoY2FjaGVkTm9kZSAhPT0gY3VycmVudCkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5ICh2bm9kZSkge1xuICBpZiAodm5vZGUpIHtcbiAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG59XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZVtrZXldKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cblZ1ZSQzLnZlcnNpb24gPSAnMi40LjInO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxuXG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKHJlZiQkMS5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuZWxtID0gZWxtO1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgIWJhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cblxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cblxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5cblxuLyoqXG4gKiBwYXJzZSBkaXJlY3RpdmUgbW9kZWwgdG8gZG8gdGhlIGFycmF5IHVwZGF0ZSB0cmFuc2Zvcm0uIGFbaWR4XSA9IHZhbCA9PiAkJGEuc3BsaWNlKCQkaWR4LCAxLCB2YWwpXG4gKlxuICogZm9yIGxvb3AgcG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3RbaWR4XVxuICogLSB0ZXN0W3Rlc3QxW2lkeF1dXG4gKiAtIHRlc3RbXCJhXCJdW2lkeF1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtpZHhdXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2lkeF1dXG4gKlxuICovXG5cbnZhciBzdHI7XG52YXIgaW5kZXgkMTtcblxuLyogICovXG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgdmFyIGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKFxuICBlbG0sXG4gIHZub2RlLFxuICBjaGVja1ZhbFxuKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHxcbiAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrbGV5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICB2YXIgZiA9IGJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZSQzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUvZGlzdC92dWUucnVudGltZS5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==